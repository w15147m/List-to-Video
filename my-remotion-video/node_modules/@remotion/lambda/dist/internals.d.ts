export declare const LambdaInternals: {
    executeCommand: (args: string[], remotionRoot: string, logLevel: import("@remotion/serverless").LogLevel, _providerSpecifics: import("@remotion/serverless").ProviderSpecifics<import("@remotion/lambda-client").AwsProvider> | null, fullClientSpecifics: import("@remotion/serverless").FullClientSpecifics<import("@remotion/lambda-client").AwsProvider> | null) => Promise<void>;
    internalDeploySite: (args_0: {
        entryPoint: string;
        bucketName: string;
        region: import("@remotion/lambda-client").AwsRegion;
    } & {
        siteName: string;
        options: {
            onBundleProgress?: (progress: number) => void;
            onUploadProgress?: (upload: import("@remotion/serverless").UploadDirProgress) => void;
            onDiffingProgress?: (bytes: number, done: boolean) => void;
            webpackOverride?: import("@remotion/bundler").WebpackOverrideFn;
            ignoreRegisterRootWarning?: boolean;
            enableCaching?: boolean;
            publicDir?: string | null;
            rootDir?: string;
            bypassBucketNameValidation?: boolean;
        };
        privacy: "public" | "no-acl";
        gitSource: import("@remotion/bundler").GitSource | null;
        indent: boolean;
        forcePathStyle: boolean;
        requestHandler: import("@remotion/lambda-client").RequestHandler | null;
    } & import("@remotion/serverless").ToOptions<{
        readonly logLevel: {
            cliFlag: "log";
            name: string;
            ssrName: string;
            description: () => import("react/jsx-runtime").JSX.Element;
            docLink: string;
            getValue: ({ commandLine }: {
                commandLine: Record<string, unknown>;
            }) => {
                value: import("@remotion/serverless").LogLevel;
                source: string;
            };
            setConfig: (newLogLevel: import("@remotion/serverless").LogLevel) => void;
            type: import("@remotion/serverless").LogLevel;
        };
        readonly throwIfSiteExists: {
            cliFlag: string;
            description: () => string;
            docLink: string;
            getValue: ({ commandLine }: {
                commandLine: Record<string, unknown>;
            }) => {
                source: string;
                value: boolean;
            };
            name: string;
            setConfig: () => never;
            ssrName: string;
            type: boolean;
        };
    }> & {
        providerSpecifics: import("@remotion/serverless").ProviderSpecifics<import("@remotion/lambda-client").AwsProvider>;
        fullClientSpecifics: import("@remotion/serverless").FullClientSpecifics<import("@remotion/lambda-client").AwsProvider>;
    }) => Promise<{
        serveUrl: string;
        siteName: string;
        stats: {
            uploadedFiles: number;
            deletedFiles: number;
            untouchedFiles: number;
        };
    }>;
    getLayers: ({ option, region, }: {
        option: import("@remotion/lambda-client").RuntimePreference;
        region: import("@remotion/lambda-client").AwsRegion;
    }) => import("./shared/hosted-layers").AwsLayer[];
};
export type { OverallRenderProgress as _InternalOverallRenderProgress } from '@remotion/serverless';
