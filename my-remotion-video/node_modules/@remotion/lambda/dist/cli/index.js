"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cli = exports.executeCommand = void 0;
const cli_1 = require("@remotion/cli");
const lambda_client_1 = require("@remotion/lambda-client");
const constants_1 = require("@remotion/lambda-client/constants");
const renderer_1 = require("@remotion/renderer");
const serverless_1 = require("@remotion/serverless");
const suggested_policy_1 = require("../api/iam-validation/suggested-policy");
const full_client_implementation_1 = require("../functions/full-client-implementation");
const args_1 = require("./args");
const compositions_1 = require("./commands/compositions");
const functions_1 = require("./commands/functions");
const policies_1 = require("./commands/policies/policies");
const role_1 = require("./commands/policies/role");
const user_1 = require("./commands/policies/user");
const quotas_1 = require("./commands/quotas");
const regions_1 = require("./commands/regions");
const render_1 = require("./commands/render/render");
const sites_1 = require("./commands/sites");
const still_1 = require("./commands/still");
const help_1 = require("./help");
const quit_1 = require("./helpers/quit");
const log_1 = require("./log");
const requiresCredentials = (args) => {
    if (args[0] === policies_1.POLICIES_COMMAND) {
        if (args[1] === user_1.USER_SUBCOMMAND) {
            return false;
        }
        if (args[1] === role_1.ROLE_SUBCOMMAND) {
            return false;
        }
    }
    if (args[0] === regions_1.REGIONS_COMMAND) {
        return false;
    }
    return true;
};
const matchCommand = ({ args, remotionRoot, logLevel, providerSpecifics, fullClientSpecifics, }) => {
    if (args_1.parsedLambdaCli.help || args.length === 0) {
        (0, help_1.printHelp)(logLevel);
        (0, quit_1.quit)(0);
    }
    if (requiresCredentials(args)) {
        providerSpecifics.checkCredentials();
    }
    if (args[0] === render_1.RENDER_COMMAND) {
        return (0, render_1.renderCommand)({
            args: args.slice(1),
            remotionRoot,
            logLevel,
            providerSpecifics,
        });
    }
    if (args[0] === still_1.STILL_COMMAND) {
        return (0, still_1.stillCommand)({
            args: args.slice(1),
            remotionRoot,
            logLevel,
            providerSpecifics: providerSpecifics,
        });
    }
    if (args[0] === compositions_1.COMPOSITIONS_COMMAND) {
        return (0, compositions_1.compositionsCommand)({
            args: args.slice(1),
            logLevel,
            providerSpecifics,
        });
    }
    if (args[0] === functions_1.FUNCTIONS_COMMAND) {
        return (0, functions_1.functionsCommand)({
            args: args.slice(1),
            logLevel,
            fullClientSpecifics,
            providerSpecifics,
        });
    }
    if (args[0] === quotas_1.QUOTAS_COMMAND) {
        return (0, quotas_1.quotasCommand)(args.slice(1), logLevel);
    }
    if (args[0] === policies_1.POLICIES_COMMAND) {
        return (0, policies_1.policiesCommand)(args.slice(1), logLevel);
    }
    if (args[0] === regions_1.REGIONS_COMMAND) {
        return (0, regions_1.regionsCommand)(logLevel);
    }
    if (args[0] === sites_1.SITES_COMMAND) {
        return (0, sites_1.sitesCommand)(args.slice(1), remotionRoot, logLevel, providerSpecifics);
    }
    if (args[0] === 'upload') {
        log_1.Log.info({ indent: false, logLevel }, 'The command has been renamed.');
        log_1.Log.info({ indent: false, logLevel }, 'Before: remotion-lambda upload <entry-point>');
        log_1.Log.info({ indent: false, logLevel }, 'After: remotion lambda sites create <entry-point>');
        (0, quit_1.quit)(1);
    }
    if (args[0] === 'deploy') {
        log_1.Log.info({ indent: false, logLevel }, 'The command has been renamed.');
        log_1.Log.info({ indent: false, logLevel }, 'Before: remotion-lambda deploy');
        log_1.Log.info({ indent: false, logLevel }, 'After: remotion lambda functions deploy');
        (0, quit_1.quit)(1);
    }
    if (args[0] === 'ls') {
        log_1.Log.info({ indent: false, logLevel }, `The "ls" command does not exist.`);
        log_1.Log.info({ indent: false, logLevel }, `Did you mean "functions ls" or "sites ls"?`);
    }
    if (args[0] === 'rm') {
        log_1.Log.info({ indent: false, logLevel }, `The "rm" command does not exist.`);
        log_1.Log.info({ indent: false, logLevel }, `Did you mean "functions rm" or "sites rm"?`);
    }
    if (args[0] === 'deploy') {
        log_1.Log.info({ indent: false, logLevel }, `The "deploy" command does not exist.`);
        log_1.Log.info({ indent: false, logLevel }, `Did you mean "functions deploy"?`);
    }
    log_1.Log.error({ indent: false, logLevel }, `Command ${args[0]} not found.`);
    (0, help_1.printHelp)(logLevel);
    (0, quit_1.quit)(1);
};
const executeCommand = async (args, remotionRoot, logLevel, _providerSpecifics, fullClientSpecifics) => {
    var _a, _b, _c, _d, _e, _f;
    try {
        const providerSpecifics = _providerSpecifics !== null && _providerSpecifics !== void 0 ? _providerSpecifics : lambda_client_1.LambdaClientInternals.awsImplementation;
        await matchCommand({
            args,
            remotionRoot,
            logLevel,
            providerSpecifics: providerSpecifics,
            fullClientSpecifics: fullClientSpecifics !== null && fullClientSpecifics !== void 0 ? fullClientSpecifics : full_client_implementation_1.awsFullClientSpecifics,
        });
    }
    catch (err) {
        const error = err;
        if (error.message.includes('The role defined for the function cannot be assumed by Lambda')) {
            if (args_1.parsedLambdaCli['custom-role-arn']) {
                log_1.Log.error({ indent: false, logLevel }, `
	The role "${args_1.parsedLambdaCli['custom-role-arn']}" does not exist or has the wrong policy assigned to it. Do either:
	- Remove the "--custom-role-arn" parameter and set up Remotion Lambda according to the setup guide
	- Make sure the role has the same policy assigned as the one returned by "npx ${constants_1.BINARY_NAME} ${policies_1.POLICIES_COMMAND} ${role_1.ROLE_SUBCOMMAND}"
	
	Revisit ${serverless_1.DOCS_URL}/docs/lambda/setup and make sure you set up the role and role policy correctly. Also see the troubleshooting page: ${serverless_1.DOCS_URL}/docs/lambda/troubleshooting/permissions. The original error message is:
	`.trim());
            }
            log_1.Log.error({ indent: false, logLevel }, `
The role "${suggested_policy_1.ROLE_NAME}" does not exist in your AWS account or has the wrong policy assigned to it. Common reasons:
- The name of the role is not "${suggested_policy_1.ROLE_NAME}"
- The policy is not exactly as specified in the setup guide

Revisit ${serverless_1.DOCS_URL}/docs/lambda/setup and make sure you set up the role and role policy correctly. Also see the troubleshooting page: ${serverless_1.DOCS_URL}/docs/lambda/troubleshooting/permissions. The original error message is:
`.trim());
        }
        if ((_a = error.stack) === null || _a === void 0 ? void 0 : _a.includes('AccessDenied')) {
            log_1.Log.error({ indent: false, logLevel }, `
AWS returned an "AccessDenied" error message meaning a permission is missing. Read the permissions troubleshooting page: ${serverless_1.DOCS_URL}/docs/lambda/troubleshooting/permissions. The original error message is:
`.trim());
        }
        if ((_b = error.stack) === null || _b === void 0 ? void 0 : _b.includes('TooManyRequestsException')) {
            log_1.Log.error({ indent: false, logLevel }, `
AWS returned an "TooManyRequestsException" error message which could mean you reached the concurrency limit of AWS Lambda. You can increase the limit - read this troubleshooting page: ${serverless_1.DOCS_URL}/docs/lambda/troubleshooting/rate-limit. The original error message is:
`.trim());
        }
        if ((_c = error.stack) === null || _c === void 0 ? void 0 : _c.includes('ConcurrentInvocationLimitExceeded')) {
            log_1.Log.error({ indent: false, logLevel }, `
AWS returned an "ConcurrentInvocationLimitExceeded" error message which could mean you reached the concurrency limit of AWS Lambda. You can increase the limit - read this troubleshooting page: ${serverless_1.DOCS_URL}/docs/lambda/troubleshooting/rate-limit. The original error message is:
`.trim());
        }
        if ((_d = error.stack) === null || _d === void 0 ? void 0 : _d.includes('The security token included in the request is invalid')) {
            const keyButDoesntStartWithAki = lambda_client_1.LambdaClientInternals.getEnvVariable('REMOTION_AWS_ACCESS_KEY_ID') &&
                !lambda_client_1.LambdaClientInternals.getEnvVariable('REMOTION_AWS_ACCESS_KEY_ID').startsWith('AKI');
            const pureKeyButDoesntStartWithAki = lambda_client_1.LambdaClientInternals.getEnvVariable('AWS_ACCESS_KEY_ID') &&
                !lambda_client_1.LambdaClientInternals.getEnvVariable('AWS_ACCESS_KEY_ID').startsWith('AKI');
            if (keyButDoesntStartWithAki || pureKeyButDoesntStartWithAki) {
                log_1.Log.error({ indent: false, logLevel }, `
	AWS returned an error message "The security token included in the request is invalid". A possible reason is that your AWS Access key ID is set but doesn't start with "AKI", which it usually should. The original message is: 
	`);
            }
            else {
                log_1.Log.error({ indent: false, logLevel }, `
AWS returned an error message "The security token included in the request is invalid". A possible reason for this is that you did not enable the region in your AWS account under "Account". The original message is: 
`);
            }
        }
        if (error instanceof renderer_1.RenderInternals.SymbolicateableError) {
            await cli_1.CliInternals.printError(error, logLevel);
        }
        else {
            const frames = renderer_1.RenderInternals.parseStack((_f = (_e = error.stack) === null || _e === void 0 ? void 0 : _e.split('\n')) !== null && _f !== void 0 ? _f : []);
            const errorWithStackFrame = new renderer_1.RenderInternals.SymbolicateableError({
                message: error.message,
                frame: null,
                name: error.name,
                stack: error.stack,
                stackFrame: frames,
                chunk: null,
            });
            await cli_1.CliInternals.printError(errorWithStackFrame, logLevel);
        }
        (0, quit_1.quit)(1);
    }
};
exports.executeCommand = executeCommand;
const cli = async (logLevel) => {
    const remotionRoot = renderer_1.RenderInternals.findRemotionRoot();
    await cli_1.CliInternals.initializeCli(remotionRoot);
    await (0, exports.executeCommand)(args_1.parsedLambdaCli._, remotionRoot, logLevel, lambda_client_1.LambdaClientInternals.awsImplementation, full_client_implementation_1.awsFullClientSpecifics);
};
exports.cli = cli;
