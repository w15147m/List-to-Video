"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findFunctionName = void 0;
const lambda_client_1 = require("@remotion/lambda-client");
const constants_1 = require("@remotion/lambda-client/constants");
const version_1 = require("remotion/version");
const args_1 = require("../args");
const functions_1 = require("../commands/functions");
const deploy_1 = require("../commands/functions/deploy");
const ls_1 = require("../commands/functions/ls");
const rm_1 = require("../commands/functions/rm");
const get_aws_region_1 = require("../get-aws-region");
const log_1 = require("../log");
const quit_1 = require("./quit");
const findFunctionName = async ({ logLevel, providerSpecifics, }) => {
    const remotionLambdas = await providerSpecifics.getFunctions({
        region: (0, get_aws_region_1.getAwsRegion)(),
        compatibleOnly: false,
    });
    const lambdasWithMatchingVersion = remotionLambdas.filter((l) => l.version === version_1.VERSION);
    const logOptions = {
        indent: false,
        logLevel,
    };
    const cliFlag = args_1.parsedLambdaCli['function-name'];
    if (cliFlag) {
        const compatibleFunctionExists = lambdasWithMatchingVersion.find((l) => l.functionName === cliFlag);
        if (!compatibleFunctionExists) {
            log_1.Log.warn({ indent: false, logLevel }, `The name passed to --function-name "${cliFlag}" does not match the naming convention this version of the CLI expects: ${lambda_client_1.LambdaClientInternals.innerSpeculateFunctionName({ diskSizeInMb: '[disk]', memorySizeInMb: '[memory]', timeoutInSeconds: '[timeout]' })}.`);
            log_1.Log.warn({ indent: false, logLevel }, 'Remotion relies on the naming to determine function information. This is an unsupported workflow.');
            if (lambdasWithMatchingVersion.length > 0) {
                log_1.Log.info(logOptions, 'The following functions were found:');
                for (const l of lambdasWithMatchingVersion) {
                    log_1.Log.info(logOptions, `- ${l.functionName} (v${l.version})`);
                }
                log_1.Log.info(logOptions, 'Prefer using one of those functions by passing their name to `--function-name` or removing it entirely.');
            }
        }
        return cliFlag;
    }
    if (lambdasWithMatchingVersion.length === 0) {
        log_1.Log.error({ indent: false, logLevel }, `No Lambda functions with version ${version_1.VERSION} found in your account.`);
        if (remotionLambdas.length > 0) {
            log_1.Log.error({ indent: false, logLevel }, 'Other functions were found, but are not compatible with this version of the CLI.');
        }
        log_1.Log.info(logOptions, 'Run');
        log_1.Log.info(logOptions, `  npx ${constants_1.BINARY_NAME} ${functions_1.FUNCTIONS_COMMAND} ${deploy_1.FUNCTIONS_DEPLOY_SUBCOMMAND}`);
        log_1.Log.info(logOptions, `to deploy a new Lambda function.`);
        (0, quit_1.quit)(1);
    }
    if (lambdasWithMatchingVersion.length > 1) {
        log_1.Log.error({ indent: false, logLevel }, 'More than 1 lambda function found in your account. Unsure which one to use.');
        log_1.Log.info(logOptions);
        log_1.Log.info(logOptions, 'Possible solutions:');
        log_1.Log.info(logOptions, '- Define using `--function-name` which function you want to use.');
        log_1.Log.info(logOptions, `- Delete extraneous Lambda functions in your AWS console or using:`);
        log_1.Log.info(logOptions, `    npx ${constants_1.BINARY_NAME} ${functions_1.FUNCTIONS_COMMAND} ${rm_1.FUNCTIONS_RM_SUBCOMMAND} $(npx ${constants_1.BINARY_NAME} ${functions_1.FUNCTIONS_COMMAND} ${ls_1.FUNCTIONS_LS_SUBCOMMAND} -q) -y`);
        log_1.Log.info(logOptions);
        log_1.Log.info(logOptions, `The following functions were found (only showing v${version_1.VERSION}):`);
        for (const l of lambdasWithMatchingVersion) {
            log_1.Log.info(logOptions, `- ${l.functionName}`);
        }
        (0, quit_1.quit)(1);
    }
    const { functionName } = lambdasWithMatchingVersion[0];
    return functionName;
};
exports.findFunctionName = findFunctionName;
