"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getS3DiffOperations = void 0;
const getS3DiffOperations = async ({ objects, bundle, prefix, onProgress, fullClientSpecifics, }) => {
    var _a, _b, _c;
    let totalBytes = 0;
    const dir = fullClientSpecifics.readDirectory({
        dir: bundle,
        etags: {},
        originalDir: bundle,
        onProgress: (bytes) => {
            totalBytes += bytes;
            onProgress(totalBytes);
        },
    });
    const filesOnS3ButNotLocal = [];
    for (const fileOnS3 of objects) {
        const key = (_a = fileOnS3.Key) === null || _a === void 0 ? void 0 : _a.substring(prefix.length + 1);
        if (!dir[key]) {
            filesOnS3ButNotLocal.push(fileOnS3);
        }
    }
    const localFilesNotOnS3 = [];
    for (const d of Object.keys(dir)) {
        let found;
        for (const o of objects) {
            const key = (_b = o.Key) === null || _b === void 0 ? void 0 : _b.substring(prefix.length + 1);
            if (key === d && o.ETag === (await dir[d]())) {
                found = o;
                break;
            }
        }
        if (!found) {
            localFilesNotOnS3.push(d);
        }
    }
    const existing = [];
    for (const d of Object.keys(dir)) {
        for (const o of objects) {
            const key = (_c = o.Key) === null || _c === void 0 ? void 0 : _c.substring(prefix.length + 1);
            if (key === d && o.ETag === (await dir[d]())) {
                existing.push(d);
                break;
            }
        }
    }
    return {
        toDelete: filesOnS3ButNotLocal,
        toUpload: localFilesNotOnS3,
        existingCount: existing.length,
    };
};
exports.getS3DiffOperations = getS3DiffOperations;
