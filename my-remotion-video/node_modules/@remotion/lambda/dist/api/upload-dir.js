"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.uploadDir = void 0;
const lib_storage_1 = require("@aws-sdk/lib-storage");
const lambda_client_1 = require("@remotion/lambda-client");
const mime_types_1 = __importDefault(require("mime-types"));
const node_fs_1 = require("node:fs");
const node_path_1 = __importDefault(require("node:path"));
const make_s3_key_1 = require("../shared/make-s3-key");
async function getFiles(directory, originalDirectory, toUpload) {
    const dirents = await node_fs_1.promises.readdir(directory, { withFileTypes: true });
    const _files = await Promise.all(dirents
        .map((dirent) => {
        const res = node_path_1.default.resolve(directory, dirent.name);
        return [dirent, res];
    })
        .filter(([dirent, res]) => {
        const relative = node_path_1.default.relative(originalDirectory, res);
        if (dirent.isDirectory()) {
            return true;
        }
        if (!toUpload.includes(relative)) {
            return false;
        }
        return true;
    })
        .map(async ([dirent, res]) => {
        const { size } = await node_fs_1.promises.stat(res);
        return dirent.isDirectory()
            ? getFiles(res, originalDirectory, toUpload)
            : [
                {
                    name: res,
                    size,
                },
            ];
    }));
    return _files.flat(1);
}
const limit = lambda_client_1.LambdaClientInternals.pLimit(5);
const uploadDir = async ({ bucket, region, localDir, onProgress, keyPrefix, privacy, toUpload, forcePathStyle, requestHandler, }) => {
    const files = await getFiles(localDir, localDir, toUpload);
    const progresses = {};
    for (const file of files) {
        progresses[file.name] = 0;
    }
    const client = lambda_client_1.LambdaClientInternals.getS3Client({
        region,
        customCredentials: null,
        forcePathStyle,
        requestHandler,
    });
    const uploadWithoutRetry = async (filePath) => {
        const Key = (0, make_s3_key_1.makeS3Key)(keyPrefix, localDir, filePath.name);
        const Body = (0, node_fs_1.createReadStream)(filePath.name);
        const ContentType = mime_types_1.default.lookup(Key) || 'application/octet-stream';
        const ACL = privacy === 'no-acl'
            ? undefined
            : privacy === 'private'
                ? 'private'
                : 'public-read';
        const parallelUploadsS3 = new lib_storage_1.Upload({
            client,
            queueSize: 2,
            partSize: 40 * 1024 * 1024,
            params: {
                Key,
                Bucket: bucket,
                Body,
                ACL,
                ContentType,
            },
        });
        parallelUploadsS3.on('httpUploadProgress', (progress) => {
            var _a;
            progresses[filePath.name] = (_a = progress.loaded) !== null && _a !== void 0 ? _a : 0;
        });
        const prom = await parallelUploadsS3.done();
        return prom;
    };
    const uploadWithRetry = async (filePath) => {
        let error = null;
        for (let i = 0; i < 3; i++) {
            try {
                return await uploadWithoutRetry(filePath);
            }
            catch (err) {
                error = err;
            }
        }
        if (error) {
            throw error;
        }
    };
    const uploadAll = (async () => {
        const uploads = files.map((filePath) => limit(async () => {
            await uploadWithRetry(filePath);
        }));
        await Promise.all(uploads);
    })();
    const interval = setInterval(() => {
        onProgress({
            totalSize: files.map((f) => f.size).reduce((a, b) => a + b, 0),
            sizeUploaded: Object.values(progresses).reduce((a, b) => a + b, 0),
            totalFiles: files.length,
            filesUploaded: files.filter((f) => progresses[f.name] === f.size).length,
        });
    }, 1000);
    await uploadAll;
    clearInterval(interval);
};
exports.uploadDir = uploadDir;
