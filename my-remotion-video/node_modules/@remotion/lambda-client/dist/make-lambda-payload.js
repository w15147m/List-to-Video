"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeLambdaRenderStillPayload = exports.getRenderProgressPayload = exports.makeLambdaRenderMediaPayload = void 0;
const serverless_client_1 = require("@remotion/serverless-client");
const aws_provider_1 = require("./aws-provider");
const serverless_client_2 = require("@remotion/serverless-client");
const validate_lambda_codec_1 = require("./validate-lambda-codec");
const validate_serveurl_1 = require("./validate-serveurl");
const makeLambdaRenderMediaPayload = async ({ rendererFunctionName, frameRange, framesPerLambda, concurrency, forceBucketName: bucketName, codec, composition, serveUrl, imageFormat, inputProps, region, crf, envVariables, pixelFormat, proResProfile, x264Preset, maxRetries, privacy, logLevel, outName, timeoutInMilliseconds, chromiumOptions, scale, everyNthFrame, numberOfGifLoops, audioBitrate, concurrencyPerLambda, audioCodec, forceHeight, forceWidth, webhook, videoBitrate, encodingMaxRate, encodingBufferSize, downloadBehavior, muted, overwrite, jpegQuality, offthreadVideoCacheSizeInBytes, mediaCacheSizeInBytes, deleteAfter, colorSpace, preferLossless, forcePathStyle, metadata, apiKey, offthreadVideoThreads, storageClass, requestHandler, }) => {
    const actualCodec = (0, validate_lambda_codec_1.validateLambdaCodec)(codec);
    (0, validate_serveurl_1.validateServeUrl)(serveUrl);
    (0, serverless_client_1.validateDownloadBehavior)(downloadBehavior);
    (0, serverless_client_2.validateWebhook)(webhook);
    const stringifiedInputProps = (0, serverless_client_1.serializeOrThrow)(inputProps !== null && inputProps !== void 0 ? inputProps : {}, 'input-props');
    const serialized = await (0, serverless_client_1.compressInputProps)({
        stringifiedInputProps,
        region,
        needsToUpload: (0, serverless_client_1.getNeedsToUpload)({
            type: 'video-or-audio',
            sizes: [
                stringifiedInputProps.length,
                JSON.stringify(envVariables).length,
            ],
            providerSpecifics: aws_provider_1.awsImplementation,
        }),
        userSpecifiedBucketName: bucketName !== null && bucketName !== void 0 ? bucketName : null,
        propsType: 'input-props',
        providerSpecifics: aws_provider_1.awsImplementation,
        forcePathStyle: forcePathStyle !== null && forcePathStyle !== void 0 ? forcePathStyle : false,
        skipPutAcl: privacy === 'no-acl',
        requestHandler: requestHandler !== null && requestHandler !== void 0 ? requestHandler : null,
    });
    return {
        rendererFunctionName,
        framesPerLambda,
        concurrency,
        composition,
        serveUrl,
        inputProps: serialized,
        codec: actualCodec,
        imageFormat,
        crf: crf !== null && crf !== void 0 ? crf : null,
        envVariables,
        pixelFormat: pixelFormat !== null && pixelFormat !== void 0 ? pixelFormat : null,
        proResProfile: proResProfile !== null && proResProfile !== void 0 ? proResProfile : null,
        x264Preset,
        jpegQuality,
        maxRetries,
        privacy,
        logLevel,
        frameRange,
        outName,
        timeoutInMilliseconds,
        chromiumOptions,
        scale,
        everyNthFrame,
        numberOfGifLoops,
        concurrencyPerLambda,
        downloadBehavior,
        muted,
        version: serverless_client_1.VERSION,
        overwrite: overwrite !== null && overwrite !== void 0 ? overwrite : serverless_client_1.ENABLE_V5_BREAKING_CHANGES,
        audioBitrate: audioBitrate !== null && audioBitrate !== void 0 ? audioBitrate : null,
        videoBitrate: videoBitrate !== null && videoBitrate !== void 0 ? videoBitrate : null,
        encodingBufferSize: encodingBufferSize !== null && encodingBufferSize !== void 0 ? encodingBufferSize : null,
        encodingMaxRate: encodingMaxRate !== null && encodingMaxRate !== void 0 ? encodingMaxRate : null,
        webhook: webhook !== null && webhook !== void 0 ? webhook : null,
        forceHeight: forceHeight !== null && forceHeight !== void 0 ? forceHeight : null,
        forceWidth: forceWidth !== null && forceWidth !== void 0 ? forceWidth : null,
        bucketName: bucketName !== null && bucketName !== void 0 ? bucketName : null,
        audioCodec: audioCodec !== null && audioCodec !== void 0 ? audioCodec : null,
        type: serverless_client_1.ServerlessRoutines.start,
        offthreadVideoCacheSizeInBytes: offthreadVideoCacheSizeInBytes !== null && offthreadVideoCacheSizeInBytes !== void 0 ? offthreadVideoCacheSizeInBytes : null,
        deleteAfter: deleteAfter !== null && deleteAfter !== void 0 ? deleteAfter : null,
        colorSpace: colorSpace !== null && colorSpace !== void 0 ? colorSpace : null,
        preferLossless: preferLossless !== null && preferLossless !== void 0 ? preferLossless : false,
        forcePathStyle: forcePathStyle !== null && forcePathStyle !== void 0 ? forcePathStyle : false,
        metadata: metadata !== null && metadata !== void 0 ? metadata : null,
        apiKey: apiKey !== null && apiKey !== void 0 ? apiKey : null,
        offthreadVideoThreads: offthreadVideoThreads !== null && offthreadVideoThreads !== void 0 ? offthreadVideoThreads : null,
        mediaCacheSizeInBytes: mediaCacheSizeInBytes !== null && mediaCacheSizeInBytes !== void 0 ? mediaCacheSizeInBytes : null,
        storageClass: storageClass !== null && storageClass !== void 0 ? storageClass : null,
    };
};
exports.makeLambdaRenderMediaPayload = makeLambdaRenderMediaPayload;
const getRenderProgressPayload = ({ bucketName, renderId, s3OutputProvider, logLevel, forcePathStyle, }) => {
    return {
        type: serverless_client_1.ServerlessRoutines.status,
        bucketName,
        renderId,
        version: serverless_client_1.VERSION,
        s3OutputProvider: s3OutputProvider !== null && s3OutputProvider !== void 0 ? s3OutputProvider : null,
        logLevel: logLevel !== null && logLevel !== void 0 ? logLevel : 'info',
        forcePathStyle: forcePathStyle !== null && forcePathStyle !== void 0 ? forcePathStyle : false,
    };
};
exports.getRenderProgressPayload = getRenderProgressPayload;
const makeLambdaRenderStillPayload = async ({ serveUrl, inputProps, imageFormat, envVariables, jpegQuality, region, maxRetries, composition, privacy, frame, logLevel, outName, timeoutInMilliseconds, chromiumOptions, scale, downloadBehavior, forceHeight, forceWidth, forceBucketName, offthreadVideoCacheSizeInBytes, deleteAfter, forcePathStyle, apiKey, storageClass, requestHandler, offthreadVideoThreads, mediaCacheSizeInBytes, }) => {
    const stringifiedInputProps = (0, serverless_client_1.serializeOrThrow)(inputProps, 'input-props');
    const serializedInputProps = await (0, serverless_client_1.compressInputProps)({
        stringifiedInputProps,
        region,
        needsToUpload: (0, serverless_client_1.getNeedsToUpload)({
            type: 'still',
            sizes: [
                stringifiedInputProps.length,
                JSON.stringify(envVariables).length,
            ],
            providerSpecifics: aws_provider_1.awsImplementation,
        }),
        userSpecifiedBucketName: forceBucketName !== null && forceBucketName !== void 0 ? forceBucketName : null,
        propsType: 'input-props',
        providerSpecifics: aws_provider_1.awsImplementation,
        forcePathStyle,
        skipPutAcl: privacy === 'no-acl',
        requestHandler,
    });
    return {
        composition,
        serveUrl,
        inputProps: serializedInputProps,
        imageFormat,
        envVariables,
        jpegQuality,
        maxRetries,
        frame,
        privacy,
        attempt: 1,
        logLevel,
        outName,
        timeoutInMilliseconds,
        chromiumOptions,
        scale,
        downloadBehavior,
        version: serverless_client_1.VERSION,
        forceHeight,
        forceWidth,
        bucketName: forceBucketName,
        offthreadVideoCacheSizeInBytes,
        deleteAfter,
        type: serverless_client_1.ServerlessRoutines.still,
        streamed: true,
        forcePathStyle,
        apiKey: apiKey !== null && apiKey !== void 0 ? apiKey : null,
        offthreadVideoThreads: offthreadVideoThreads !== null && offthreadVideoThreads !== void 0 ? offthreadVideoThreads : null,
        mediaCacheSizeInBytes: mediaCacheSizeInBytes !== null && mediaCacheSizeInBytes !== void 0 ? mediaCacheSizeInBytes : null,
        storageClass: storageClass !== null && storageClass !== void 0 ? storageClass : null,
    };
};
exports.makeLambdaRenderStillPayload = makeLambdaRenderStillPayload;
