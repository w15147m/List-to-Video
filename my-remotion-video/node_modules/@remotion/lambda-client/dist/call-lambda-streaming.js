"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.callFunctionWithStreamingImplementation = exports.parseJsonOrThrowSource = void 0;
const client_lambda_1 = require("@aws-sdk/client-lambda");
const serverless_client_1 = require("@remotion/serverless-client");
const aws_clients_1 = require("./aws-clients");
const STREAM_STALL_TIMEOUT = 30000;
const LAMBDA_STREAM_STALL = `AWS did not invoke Lambda in ${STREAM_STALL_TIMEOUT}ms`;
const parseJsonOrThrowSource = (data, type) => {
    const asString = new TextDecoder('utf-8').decode(data);
    try {
        return JSON.parse(asString);
    }
    catch (_a) {
        throw new Error(`Invalid JSON (${type}): ${asString}`);
    }
};
exports.parseJsonOrThrowSource = parseJsonOrThrowSource;
const invokeStreamOrTimeout = async ({ region, timeoutInTest, functionName, type, payload, }) => {
    const resProm = (0, aws_clients_1.getLambdaClient)(region, timeoutInTest, null).send(new client_lambda_1.InvokeWithResponseStreamCommand({
        FunctionName: functionName,
        Payload: JSON.stringify({ type, ...payload }),
    }));
    let cleanup = () => undefined;
    const timeout = new Promise((_resolve, reject) => {
        const int = setTimeout(() => {
            reject(new Error(LAMBDA_STREAM_STALL));
        }, STREAM_STALL_TIMEOUT);
        cleanup = () => {
            clearTimeout(int);
        };
    });
    const res = await Promise.race([resProm, timeout]);
    cleanup();
    return res;
};
const INVALID_JSON_MESSAGE = 'Cannot parse Lambda response as JSON';
const callLambdaWithStreamingWithoutRetry = async ({ functionName, type, payload, region, timeoutInTest, receivedStreamingPayload, }) => {
    const res = await invokeStreamOrTimeout({
        functionName,
        payload,
        region,
        timeoutInTest,
        type,
    });
    const { onData, clear } = (0, serverless_client_1.makeStreamer)((status, messageTypeId, data) => {
        const messageType = (0, serverless_client_1.messageTypeIdToMessageType)(messageTypeId);
        const innerPayload = serverless_client_1.formatMap[messageType] === 'json'
            ? (0, exports.parseJsonOrThrowSource)(data, messageType)
            : data;
        const message = {
            successType: status,
            message: {
                type: messageType,
                payload: innerPayload,
            },
        };
        receivedStreamingPayload(message);
    });
    const dumpBuffers = () => {
        clear();
    };
    // @ts-expect-error - We are adding a listener to a global variable
    if (globalThis._dumpUnreleasedBuffers) {
        // @ts-expect-error - We are adding a listener to a global variable
        globalThis._dumpUnreleasedBuffers.addListener('dump-unreleased-buffers', dumpBuffers);
    }
    const events = res.EventStream;
    for await (const event of events) {
        // There are two types of events you can get on a stream.
        // `PayloadChunk`: These contain the actual raw bytes of the chunk
        // It has a single property: `Payload`
        if (event.PayloadChunk && event.PayloadChunk.Payload) {
            onData(event.PayloadChunk.Payload);
        }
        if (event.InvokeComplete) {
            if (event.InvokeComplete.ErrorCode) {
                const logs = `https://${region}.console.aws.amazon.com/cloudwatch/home?region=${region}#logsV2:logs-insights$3FqueryDetail$3D~(end~0~start~-3600~timeType~'RELATIVE~unit~'seconds~editorString~'fields*20*40timestamp*2c*20*40requestId*2c*20*40message*0a*7c*20filter*20*40requestId*20like*20*${res.$metadata.requestId}*22*0a*7c*20sort*20*40timestamp*20asc~source~(~'*2faws*2flambda*2f${functionName}))`;
                if (event.InvokeComplete.ErrorCode === 'Unhandled') {
                    throw new Error(`Lambda function ${functionName} failed with an unhandled error: ${event.InvokeComplete.ErrorDetails} See ${logs} to see the logs of this invocation.`);
                }
                throw new Error(`Lambda function ${functionName} failed with error code ${event.InvokeComplete.ErrorCode}: ${event.InvokeComplete.ErrorDetails}. See ${logs} to see the logs of this invocation.`);
            }
        }
        // Don't put a `break` statement here, as it will cause the socket to not properly exit.
    }
    // @ts-expect-error - We are adding a listener to a global variable
    if (globalThis._dumpUnreleasedBuffers) {
        // @ts-expect-error - We are adding a listener to a global variable
        globalThis._dumpUnreleasedBuffers.removeListener('dump-unreleased-buffers', dumpBuffers);
    }
    clear();
};
const callFunctionWithStreamingImplementation = async (options) => {
    // As of August 2023, Lambda streaming sometimes misses parts of the JSON response.
    // Handling this for now by applying a retry mechanism.
    var _a, _b;
    try {
        // Do not remove this await
        await callLambdaWithStreamingWithoutRetry(options);
    }
    catch (err) {
        if (((_a = err.stack) === null || _a === void 0 ? void 0 : _a.includes('TooManyRequestsException')) ||
            ((_b = err.message) === null || _b === void 0 ? void 0 : _b.includes('ConcurrentInvocationLimitExceeded'))) {
            throw new Error(`AWS Concurrency limit reached (Original Error: ${err.message}). See https://www.remotion.dev/docs/lambda/troubleshooting/rate-limit for tips to fix this.`);
        }
        if (!err.message.includes(INVALID_JSON_MESSAGE) &&
            !err.message.includes(LAMBDA_STREAM_STALL) &&
            // https://discord.com/channels/809501355504959528/1332166561242288220/1332166561242288220
            !err.message.includes('Runtime.TruncatedResponse') &&
            !err.message.includes('aborted')) {
            throw err;
        }
        console.error('Retries remaining:', options.retriesRemaining);
        if (options.retriesRemaining === 0) {
            console.error('Throwing error:');
            throw err;
        }
        console.error(err);
        return (0, exports.callFunctionWithStreamingImplementation)({
            ...options,
            retriesRemaining: options.retriesRemaining - 1,
        });
    }
};
exports.callFunctionWithStreamingImplementation = callFunctionWithStreamingImplementation;
