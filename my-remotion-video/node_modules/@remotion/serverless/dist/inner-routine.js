"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.innerRoutine = exports.innerHandler = void 0;
const renderer_1 = require("@remotion/renderer");
const serverless_client_1 = require("@remotion/serverless-client");
const compositions_1 = require("./handlers/compositions");
const launch_1 = require("./handlers/launch");
const progress_1 = require("./handlers/progress");
const renderer_2 = require("./handlers/renderer");
const start_1 = require("./handlers/start");
const still_1 = require("./handlers/still");
const info_1 = require("./info");
const is_warm_1 = require("./is-warm");
const leak_detection_1 = require("./leak-detection");
const print_logging_grep_helper_1 = require("./print-logging-grep-helper");
const innerHandler = async ({ params, responseWriter, context, providerSpecifics, insideFunctionSpecifics, }) => {
    (0, leak_detection_1.setCurrentRequestId)(context.awsRequestId);
    process.env.__RESERVED_IS_INSIDE_REMOTION_LAMBDA = 'true';
    const timeoutInMilliseconds = context.getRemainingTimeInMillis();
    renderer_1.RenderInternals.Log.verbose({ indent: false, logLevel: params.logLevel }, 'AWS Request ID:', context.awsRequestId);
    (0, leak_detection_1.stopLeakDetection)();
    if (!(context === null || context === void 0 ? void 0 : context.invokedFunctionArn)) {
        throw new Error('Lambda function unexpectedly does not have context.invokedFunctionArn');
    }
    await insideFunctionSpecifics.deleteTmpDir();
    const isWarm = (0, is_warm_1.getWarm)();
    (0, is_warm_1.setWarm)();
    const currentUserId = context.invokedFunctionArn.split(':')[4];
    if (!currentUserId) {
        throw new Error('Expected current user ID');
    }
    if (params.type === serverless_client_1.ServerlessRoutines.still) {
        providerSpecifics.validateDeleteAfter(params.deleteAfter);
        const renderId = insideFunctionSpecifics.generateRandomId({
            deleteAfter: params.deleteAfter,
            randomHashFn: providerSpecifics.randomHash,
        });
        if (providerSpecifics.printLoggingHelper) {
            (0, print_logging_grep_helper_1.printLoggingGrepHelper)(serverless_client_1.ServerlessRoutines.still, {
                renderId,
                inputProps: JSON.stringify(params.inputProps),
                isWarm,
            }, params.logLevel);
        }
        try {
            await new Promise((resolve, reject) => {
                const onStream = async (payload) => {
                    if (!params.streamed) {
                        if (payload.type !== 'still-rendered') {
                            throw new Error('Expected still-rendered');
                        }
                        await responseWriter.write(new TextEncoder().encode(JSON.stringify(payload.payload)));
                        return;
                    }
                    const message = (0, serverless_client_1.makeStreamPayload)({
                        message: payload,
                    });
                    return new Promise((innerResolve, innerReject) => {
                        responseWriter
                            .write(message)
                            .then(() => {
                            innerResolve();
                        })
                            .catch((err) => {
                            reject(err);
                            innerReject(err);
                        });
                    });
                };
                if (params.streamed) {
                    onStream({
                        type: 'render-id-determined',
                        payload: { renderId },
                    });
                }
                (0, still_1.stillHandler)({
                    expectedBucketOwner: currentUserId,
                    params,
                    renderId,
                    onStream,
                    timeoutInMilliseconds,
                    providerSpecifics,
                    insideFunctionSpecifics,
                })
                    .then((r) => {
                    resolve(r);
                })
                    .catch((err) => {
                    reject(err);
                });
            });
            await responseWriter.end();
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.log({ err });
        }
        return;
    }
    if (params.type === serverless_client_1.ServerlessRoutines.start) {
        try {
            const renderId = insideFunctionSpecifics.generateRandomId({
                deleteAfter: params.deleteAfter,
                randomHashFn: providerSpecifics.randomHash,
            });
            if (providerSpecifics.printLoggingHelper) {
                (0, print_logging_grep_helper_1.printLoggingGrepHelper)(serverless_client_1.ServerlessRoutines.start, {
                    renderId,
                    inputProps: JSON.stringify(params.inputProps),
                    isWarm,
                }, params.logLevel);
            }
            const response = await (0, start_1.startHandler)({
                params,
                options: {
                    expectedBucketOwner: currentUserId,
                    timeoutInMilliseconds,
                    renderId,
                },
                providerSpecifics,
                insideFunctionSpecifics,
            });
            await responseWriter.write(new TextEncoder().encode(JSON.stringify(response)));
            await responseWriter.end();
            return;
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.log({ err });
            await responseWriter.write(new TextEncoder().encode(JSON.stringify({ type: 'error', message: err.stack })));
            return;
        }
    }
    if (params.type === serverless_client_1.ServerlessRoutines.launch) {
        if (providerSpecifics.printLoggingHelper) {
            (0, print_logging_grep_helper_1.printLoggingGrepHelper)(serverless_client_1.ServerlessRoutines.launch, {
                renderId: params.renderId,
                inputProps: JSON.stringify(params.inputProps),
                isWarm,
            }, params.logLevel);
        }
        await (0, launch_1.launchHandler)({
            params,
            options: {
                expectedBucketOwner: currentUserId,
                getRemainingTimeInMillis: context.getRemainingTimeInMillis,
            },
            providerSpecifics,
            insideFunctionSpecifics,
        });
        await responseWriter.write(new TextEncoder().encode(JSON.stringify({})));
        await responseWriter.end();
        return;
    }
    if (params.type === serverless_client_1.ServerlessRoutines.status) {
        if (providerSpecifics.printLoggingHelper) {
            (0, print_logging_grep_helper_1.printLoggingGrepHelper)(serverless_client_1.ServerlessRoutines.status, {
                renderId: params.renderId,
                isWarm,
            }, params.logLevel);
        }
        const response = await (0, progress_1.progressHandler)({
            params,
            options: {
                expectedBucketOwner: currentUserId,
                timeoutInMilliseconds,
                retriesRemaining: 2,
                providerSpecifics,
                insideFunctionSpecifics,
            },
        });
        await responseWriter.write(new TextEncoder().encode(JSON.stringify(response)));
        await responseWriter.end();
        return;
    }
    if (params.type === serverless_client_1.ServerlessRoutines.renderer) {
        if (providerSpecifics.printLoggingHelper) {
            (0, print_logging_grep_helper_1.printLoggingGrepHelper)(serverless_client_1.ServerlessRoutines.renderer, {
                renderId: params.renderId,
                chunk: String(params.chunk),
                dumpLogs: String(renderer_1.RenderInternals.isEqualOrBelowLogLevel(params.logLevel, 'verbose')),
                resolvedProps: JSON.stringify(params.resolvedProps),
                isWarm,
            }, params.logLevel);
        }
        await new Promise((resolve, reject) => {
            (0, renderer_2.rendererHandler)({
                params,
                options: {
                    expectedBucketOwner: currentUserId,
                    isWarm,
                },
                onStream: (payload) => {
                    const message = (0, serverless_client_1.makeStreamPayload)({
                        message: payload,
                    });
                    const writeProm = responseWriter.write(message);
                    return new Promise((innerResolve, innerReject) => {
                        writeProm
                            .then(() => {
                            innerResolve();
                        })
                            .catch((err) => {
                            reject(err);
                            innerReject(err);
                        });
                    });
                },
                requestContext: context,
                providerSpecifics,
                insideFunctionSpecifics,
            })
                .then((res) => {
                resolve(res);
            })
                .catch((err) => {
                reject(err);
            });
        });
        await responseWriter.end();
        return;
    }
    if (params.type === serverless_client_1.ServerlessRoutines.info) {
        if (providerSpecifics.printLoggingHelper) {
            (0, print_logging_grep_helper_1.printLoggingGrepHelper)(serverless_client_1.ServerlessRoutines.info, {
                isWarm,
            }, params.logLevel);
        }
        const response = await (0, info_1.infoHandler)(params);
        await responseWriter.write(new TextEncoder().encode(JSON.stringify(response)));
        await responseWriter.end();
        return;
    }
    if (params.type === serverless_client_1.ServerlessRoutines.compositions) {
        if (providerSpecifics.printLoggingHelper) {
            (0, print_logging_grep_helper_1.printLoggingGrepHelper)(serverless_client_1.ServerlessRoutines.compositions, {
                isWarm,
            }, params.logLevel);
        }
        const response = await (0, compositions_1.compositionsHandler)({
            params,
            options: {
                expectedBucketOwner: currentUserId,
            },
            providerSpecifics,
            insideFunctionSpecifics,
        });
        await responseWriter.write(new TextEncoder().encode(JSON.stringify(response)));
        await responseWriter.end();
        return;
    }
    throw new Error(`${serverless_client_1.COMMAND_NOT_FOUND}: ${JSON.stringify(params)}`);
};
exports.innerHandler = innerHandler;
const innerRoutine = async ({ params, responseWriter, context, providerSpecifics, insideFunctionSpecifics, }) => {
    try {
        await (0, exports.innerHandler)({
            params,
            responseWriter,
            context,
            providerSpecifics,
            insideFunctionSpecifics,
        });
    }
    catch (err) {
        const res = {
            type: 'error',
            message: err.message,
            stack: err.stack,
        };
        await responseWriter.write(new TextEncoder().encode(JSON.stringify(res)));
        await responseWriter.end();
    }
};
exports.innerRoutine = innerRoutine;
