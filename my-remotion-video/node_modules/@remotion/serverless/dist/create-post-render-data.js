"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPostRenderData = void 0;
const serverless_client_1 = require("@remotion/serverless-client");
const createPostRenderData = ({ region, memorySizeInMb, renderMetadata, errorExplanations, timeToDelete, outputFile, timeToCombine, overallProgress, timeToFinish, outputSize, providerSpecifics, }) => {
    var _a, _b;
    const parsedTimings = overallProgress.timings;
    const estimatedBillingDurationInMilliseconds = parsedTimings
        .map((p) => p.rendered - p.start + serverless_client_1.OVERHEAD_TIME_PER_LAMBDA)
        .reduce((a, b) => a + b);
    const cost = providerSpecifics.estimatePrice({
        durationInMilliseconds: estimatedBillingDurationInMilliseconds,
        memorySizeInMb: (_b = (_a = providerSpecifics.parseFunctionName(renderMetadata.rendererFunctionName)) === null || _a === void 0 ? void 0 : _a.memorySizeInMb) !== null && _b !== void 0 ? _b : memorySizeInMb,
        region,
        lambdasInvoked: renderMetadata.estimatedTotalLambdaInvokations,
        diskSizeInMb: providerSpecifics.getEphemeralStorageForPriceCalculation(),
    });
    if (!outputFile) {
        throw new Error('Cannot wrap up without an output file in the S3 bucket.');
    }
    const endTime = Date.now();
    if (overallProgress.timeToEncode === null) {
        throw new Error('Expected time to encode to be set');
    }
    if (overallProgress.timeToRenderFrames === null) {
        throw new Error('Expected time to encode to be set');
    }
    return {
        cost: {
            currency: 'USD',
            disclaimer: 'Estimated cost for function invocations only. Does not include cost for storage and data transfer.',
            estimatedCost: cost,
            estimatedDisplayCost: `$${new Intl.NumberFormat('en-US', {
                currency: 'USD',
                currencyDisplay: 'narrowSymbol',
            }).format(cost)}`,
        },
        outputFile: outputFile.url,
        timeToFinish,
        errors: errorExplanations,
        startTime: renderMetadata.startedDate,
        endTime,
        outputSize,
        renderSize: outputSize,
        filesCleanedUp: 0,
        timeToEncode: overallProgress.timeToEncode,
        timeToCleanUp: timeToDelete,
        timeToRenderChunks: (0, serverless_client_1.calculateChunkTimes)({
            type: 'absolute-time',
            timings: overallProgress.timings,
        }),
        timeToRenderFrames: overallProgress.timeToRenderFrames,
        retriesInfo: overallProgress.retries,
        mostExpensiveFrameRanges: renderMetadata.type === 'still'
            ? []
            : (0, serverless_client_1.getMostExpensiveChunks)({
                parsedTimings,
                framesPerFunction: renderMetadata.framesPerLambda,
                firstFrame: renderMetadata.frameRange[0],
                lastFrame: renderMetadata.frameRange[1],
            }),
        deleteAfter: renderMetadata.deleteAfter,
        estimatedBillingDurationInMilliseconds,
        timeToCombine: timeToCombine !== null && timeToCombine !== void 0 ? timeToCombine : null,
        artifactProgress: overallProgress.receivedArtifact,
    };
};
exports.createPostRenderData = createPostRenderData;
