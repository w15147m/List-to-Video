"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startHandler = void 0;
const serverless_client_1 = require("@remotion/serverless-client");
const overall_render_progress_1 = require("../overall-render-progress");
const check_version_mismatch_1 = require("./check-version-mismatch");
const startHandler = async ({ params, options, providerSpecifics, insideFunctionSpecifics, }) => {
    var _a, _b, _c, _d;
    if (params.type !== serverless_client_1.ServerlessRoutines.start) {
        throw new TypeError('Expected type start');
    }
    (0, check_version_mismatch_1.checkVersionMismatch)({
        apiName: 'renderMediaOnLambda()',
        insideFunctionSpecifics,
        params,
    });
    const region = insideFunctionSpecifics.getCurrentRegionInFunction();
    const bucketName = (_a = params.bucketName) !== null && _a !== void 0 ? _a : (await (0, serverless_client_1.internalGetOrCreateBucket)({
        region: insideFunctionSpecifics.getCurrentRegionInFunction(),
        enableFolderExpiry: null,
        customCredentials: null,
        providerSpecifics,
        forcePathStyle: params.forcePathStyle,
        skipPutAcl: false,
        requestHandler: null,
    })).bucketName;
    const realServeUrl = providerSpecifics.convertToServeUrl({
        urlOrId: params.serveUrl,
        region,
        bucketName,
    });
    providerSpecifics.validateDeleteAfter(params.deleteAfter);
    const initialFile = providerSpecifics.writeFile({
        bucketName,
        downloadBehavior: null,
        region,
        body: JSON.stringify((0, overall_render_progress_1.makeInitialOverallRenderProgress)(options.timeoutInMilliseconds + Date.now())),
        expectedBucketOwner: options.expectedBucketOwner,
        key: (0, serverless_client_1.overallProgressKey)(options.renderId),
        privacy: 'private',
        customCredentials: null,
        forcePathStyle: params.forcePathStyle,
        storageClass: null,
        requestHandler: null,
    });
    const payload = {
        type: serverless_client_1.ServerlessRoutines.launch,
        framesPerFunction: params.framesPerLambda,
        concurrency: params.concurrency,
        composition: params.composition,
        serveUrl: realServeUrl,
        inputProps: params.inputProps,
        bucketName,
        renderId: options.renderId,
        codec: params.codec,
        imageFormat: params.imageFormat,
        crf: (_b = params.crf) !== null && _b !== void 0 ? _b : null,
        envVariables: params.envVariables,
        pixelFormat: (_c = params.pixelFormat) !== null && _c !== void 0 ? _c : null,
        proResProfile: (_d = params.proResProfile) !== null && _d !== void 0 ? _d : null,
        x264Preset: params.x264Preset,
        jpegQuality: params.jpegQuality,
        maxRetries: params.maxRetries,
        privacy: params.privacy,
        logLevel: params.logLevel,
        frameRange: params.frameRange,
        outName: params.outName,
        timeoutInMilliseconds: params.timeoutInMilliseconds,
        chromiumOptions: params.chromiumOptions,
        scale: params.scale,
        numberOfGifLoops: params.numberOfGifLoops,
        everyNthFrame: params.everyNthFrame,
        concurrencyPerFunction: params.concurrencyPerLambda,
        downloadBehavior: params.downloadBehavior,
        muted: params.muted,
        overwrite: params.overwrite,
        webhook: params.webhook,
        audioBitrate: params.audioBitrate,
        videoBitrate: params.videoBitrate,
        encodingBufferSize: params.encodingBufferSize,
        encodingMaxRate: params.encodingMaxRate,
        forceHeight: params.forceHeight,
        forceWidth: params.forceWidth,
        rendererFunctionName: params.rendererFunctionName,
        audioCodec: params.audioCodec,
        offthreadVideoCacheSizeInBytes: params.offthreadVideoCacheSizeInBytes,
        deleteAfter: params.deleteAfter,
        colorSpace: params.colorSpace,
        preferLossless: params.preferLossless,
        forcePathStyle: params.forcePathStyle,
        metadata: params.metadata,
        apiKey: params.apiKey,
        offthreadVideoThreads: params.offthreadVideoThreads,
        storageClass: params.storageClass,
        mediaCacheSizeInBytes: params.mediaCacheSizeInBytes,
    };
    await providerSpecifics.callFunctionAsync({
        functionName: insideFunctionSpecifics.getCurrentFunctionName(),
        type: serverless_client_1.ServerlessRoutines.launch,
        payload,
        region,
        timeoutInTest: options.timeoutInMilliseconds,
        requestHandler: null,
    });
    await initialFile;
    return {
        type: 'success',
        bucketName,
        renderId: options.renderId,
    };
};
exports.startHandler = startHandler;
