"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compositionsHandler = void 0;
const renderer_1 = require("@remotion/renderer");
const serverless_client_1 = require("@remotion/serverless-client");
const check_version_mismatch_1 = require("./check-version-mismatch");
const compositionsHandler = async ({ params, options, providerSpecifics, insideFunctionSpecifics, }) => {
    var _a;
    if (params.type !== serverless_client_1.ServerlessRoutines.compositions) {
        throw new TypeError('Expected info compositions');
    }
    (0, check_version_mismatch_1.checkVersionMismatch)({
        apiName: 'getCompositionsOnLambda()',
        insideFunctionSpecifics,
        params,
    });
    let instance;
    try {
        const region = insideFunctionSpecifics.getCurrentRegionInFunction();
        const browserInstancePromise = insideFunctionSpecifics.getBrowserInstance({
            logLevel: params.logLevel,
            indent: false,
            chromiumOptions: params.chromiumOptions,
            providerSpecifics,
            insideFunctionSpecifics,
        });
        const bucketName = await (params.bucketName
            ? Promise.resolve(params.bucketName)
            : (0, serverless_client_1.internalGetOrCreateBucket)({
                region,
                enableFolderExpiry: null,
                customCredentials: null,
                providerSpecifics,
                forcePathStyle: params.forcePathStyle,
                skipPutAcl: false,
                requestHandler: null,
            }).then((b) => b.bucketName));
        const serializedInputPropsWithCustomSchema = await (0, serverless_client_1.decompressInputProps)({
            bucketName,
            expectedBucketOwner: options.expectedBucketOwner,
            region: insideFunctionSpecifics.getCurrentRegionInFunction(),
            serialized: params.inputProps,
            propsType: 'input-props',
            providerSpecifics,
            forcePathStyle: params.forcePathStyle,
            requestHandler: null,
        });
        const realServeUrl = providerSpecifics.convertToServeUrl({
            urlOrId: params.serveUrl,
            region,
            bucketName,
        });
        instance = await browserInstancePromise;
        const compositions = await renderer_1.RenderInternals.internalGetCompositions({
            serveUrlOrWebpackUrl: realServeUrl,
            puppeteerInstance: instance === null || instance === void 0 ? void 0 : instance.instance,
            serializedInputPropsWithCustomSchema,
            envVariables: (_a = params.envVariables) !== null && _a !== void 0 ? _a : {},
            timeoutInMilliseconds: params.timeoutInMilliseconds,
            chromiumOptions: params.chromiumOptions,
            port: null,
            server: undefined,
            logLevel: params.logLevel,
            indent: false,
            browserExecutable: null,
            onBrowserLog: null,
            offthreadVideoCacheSizeInBytes: params.offthreadVideoCacheSizeInBytes,
            binariesDirectory: null,
            onBrowserDownload: () => {
                throw new Error('Should not download a browser in a function');
            },
            chromeMode: 'headless-shell',
            offthreadVideoThreads: 1,
            mediaCacheSizeInBytes: params.mediaCacheSizeInBytes,
            onLog: renderer_1.RenderInternals.defaultOnLog,
        });
        return Promise.resolve({
            compositions,
            type: 'success',
        });
    }
    finally {
        if (instance) {
            insideFunctionSpecifics.forgetBrowserEventLoop({
                logLevel: params.logLevel,
                launchedBrowser: instance,
            });
        }
    }
};
exports.compositionsHandler = compositionsHandler;
