"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.launchHandler = void 0;
const renderer_1 = require("@remotion/renderer");
const serverless_client_1 = require("@remotion/serverless-client");
const fs_1 = require("fs");
const path_1 = require("path");
const serverless_client_2 = require("@remotion/serverless-client");
const cleanup_props_1 = require("../cleanup-props");
const find_output_file_in_bucket_1 = require("../find-output-file-in-bucket");
const get_tmp_dir_1 = require("../get-tmp-dir");
const merge_chunks_1 = require("../merge-chunks");
const overall_render_progress_1 = require("../overall-render-progress");
const plan_frame_ranges_1 = require("../plan-frame-ranges");
const remove_outname_credentials_1 = require("../remove-outname-credentials");
const stream_renderer_1 = require("../stream-renderer");
const validate_composition_1 = require("../validate-composition");
const send_telemetry_event_1 = require("./send-telemetry-event");
const innerLaunchHandler = async ({ params, options, overallProgress, registerCleanupTask, providerSpecifics, insideFunctionSpecifics, onBrowser, }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (params.type !== serverless_client_2.ServerlessRoutines.launch) {
        throw new Error('Expected launch type');
    }
    const startedDate = Date.now();
    const browserInstance = insideFunctionSpecifics.getBrowserInstance({
        logLevel: params.logLevel,
        indent: false,
        chromiumOptions: params.chromiumOptions,
        providerSpecifics,
        insideFunctionSpecifics,
    });
    browserInstance.then((b) => {
        onBrowser(b);
    });
    const inputPropsPromise = (0, serverless_client_2.decompressInputProps)({
        bucketName: params.bucketName,
        expectedBucketOwner: options.expectedBucketOwner,
        region: insideFunctionSpecifics.getCurrentRegionInFunction(),
        serialized: params.inputProps,
        propsType: 'input-props',
        providerSpecifics,
        forcePathStyle: params.forcePathStyle,
        requestHandler: null,
    });
    const logOptions = {
        indent: false,
        logLevel: params.logLevel,
    };
    const serializedInputPropsWithCustomSchema = await inputPropsPromise;
    renderer_1.RenderInternals.Log.info(logOptions, 'Waiting for browser to be ready:', serializedInputPropsWithCustomSchema);
    const { instance } = await browserInstance;
    renderer_1.RenderInternals.Log.info(logOptions, 'Validating composition, input props:', serializedInputPropsWithCustomSchema);
    const startTime = Date.now();
    const comp = await (0, validate_composition_1.validateComposition)({
        serveUrl: params.serveUrl,
        composition: params.composition,
        browserInstance: instance,
        serializedInputPropsWithCustomSchema,
        envVariables: (_a = params.envVariables) !== null && _a !== void 0 ? _a : {},
        timeoutInMilliseconds: params.timeoutInMilliseconds,
        chromiumOptions: params.chromiumOptions,
        port: null,
        forceHeight: params.forceHeight,
        forceWidth: params.forceWidth,
        logLevel: params.logLevel,
        server: undefined,
        offthreadVideoCacheSizeInBytes: params.offthreadVideoCacheSizeInBytes,
        onBrowserDownload: () => {
            throw new Error('Should not download a browser in a function');
        },
        onServeUrlVisited: () => {
            overallProgress.setServeUrlOpened(Date.now());
        },
        providerSpecifics,
        offthreadVideoThreads: params.offthreadVideoThreads,
        mediaCacheSizeInBytes: params.mediaCacheSizeInBytes,
    });
    overallProgress.setCompositionValidated(Date.now());
    renderer_1.RenderInternals.Log.info(logOptions, 'Composition validated, resolved props', comp.props);
    renderer_1.RenderInternals.validateBitrate(params.audioBitrate, 'audioBitrate');
    renderer_1.RenderInternals.validateBitrate(params.videoBitrate, 'videoBitrate');
    renderer_1.RenderInternals.validateConcurrency({
        value: params.concurrencyPerFunction,
        setting: 'concurrencyPerLambda',
        checkIfValidForCurrentMachine: ((_b = params.rendererFunctionName) !== null && _b !== void 0 ? _b : null) === null,
    });
    const realFrameRange = renderer_1.RenderInternals.getRealFrameRange(comp.durationInFrames, params.frameRange);
    const frameCount = renderer_1.RenderInternals.getFramesToRender(realFrameRange, params.everyNthFrame);
    const framesPerLambda = (0, serverless_client_2.validateFramesPerFunction)({
        framesPerFunction: params.framesPerFunction,
        durationInFrames: frameCount.length,
        concurrency: params.concurrency,
    });
    (0, serverless_client_2.validateOutname)({
        outName: params.outName,
        codec: params.codec,
        audioCodecSetting: params.audioCodec,
        separateAudioTo: null,
        bucketNamePrefix: providerSpecifics.getBucketPrefix(),
    });
    (0, serverless_client_1.validateCodec)(params.codec, 'renderMediaOnLambda', 'codec');
    (0, serverless_client_2.validatePrivacy)(params.privacy, true);
    renderer_1.RenderInternals.validatePuppeteerTimeout(params.timeoutInMilliseconds);
    const { chunks } = (0, plan_frame_ranges_1.planFrameRanges)({
        framesPerFunction: framesPerLambda,
        frameRange: realFrameRange,
        everyNthFrame: params.everyNthFrame,
    });
    if (chunks.length > serverless_client_2.MAX_FUNCTIONS_PER_RENDER) {
        throw new Error(`Too many functions: This render would cause ${chunks.length} functions to spawn. We limit this amount to ${serverless_client_2.MAX_FUNCTIONS_PER_RENDER} functions as more would result in diminishing returns. Values set: frameCount = ${frameCount.length}, framesPerLambda=${framesPerLambda}. See ${serverless_client_2.DOCS_URL}/docs/lambda/concurrency#too-many-functions for help.`);
    }
    overallProgress.setExpectedChunks(chunks.length);
    const sortedChunks = chunks.slice().sort((a, b) => a[0] - b[0]);
    const serializedResolved = (0, serverless_client_2.serializeOrThrow)(comp.props, 'resolved-props');
    const needsToUpload = (0, serverless_client_2.getNeedsToUpload)({
        type: 'video-or-audio',
        sizes: [
            serializedResolved.length,
            params.inputProps.type === 'bucket-url'
                ? params.inputProps.hash.length
                : params.inputProps.payload.length,
            JSON.stringify(params.envVariables).length,
        ],
        providerSpecifics,
    });
    const serializedResolvedProps = await (0, serverless_client_2.compressInputProps)({
        propsType: 'resolved-props',
        region: insideFunctionSpecifics.getCurrentRegionInFunction(),
        stringifiedInputProps: serializedResolved,
        userSpecifiedBucketName: params.bucketName,
        needsToUpload,
        providerSpecifics,
        forcePathStyle: params.forcePathStyle,
        skipPutAcl: false,
        requestHandler: null,
    });
    registerCleanupTask(() => {
        return (0, cleanup_props_1.cleanupProps)({
            serializedResolvedProps,
            inputProps: params.inputProps,
            providerSpecifics,
            forcePathStyle: params.forcePathStyle,
            insideFunctionSpecifics,
        });
    });
    const fps = comp.fps / params.everyNthFrame;
    // If for 150 functions, we stream every frame, we DDos ourselves.
    // Throttling a bit, allowing more progress if there is lower concurrency.
    const progressEveryNthFrame = Math.ceil(chunks.length / 15);
    const lambdaPayloads = chunks.map((chunkPayload) => {
        var _a;
        const payload = {
            type: serverless_client_2.ServerlessRoutines.renderer,
            frameRange: chunkPayload,
            serveUrl: params.serveUrl,
            chunk: sortedChunks.indexOf(chunkPayload),
            composition: params.composition,
            fps: comp.fps,
            height: comp.height,
            width: comp.width,
            durationInFrames: comp.durationInFrames,
            bucketName: params.bucketName,
            retriesLeft: params.maxRetries,
            inputProps: params.inputProps,
            renderId: params.renderId,
            imageFormat: params.imageFormat,
            codec: params.codec,
            crf: params.crf,
            envVariables: params.envVariables,
            pixelFormat: params.pixelFormat,
            proResProfile: params.proResProfile,
            x264Preset: params.x264Preset,
            jpegQuality: params.jpegQuality,
            privacy: params.privacy,
            logLevel: (_a = params.logLevel) !== null && _a !== void 0 ? _a : 'info',
            attempt: 1,
            timeoutInMilliseconds: params.timeoutInMilliseconds,
            chromiumOptions: params.chromiumOptions,
            scale: params.scale,
            everyNthFrame: params.everyNthFrame,
            concurrencyPerLambda: params.concurrencyPerFunction,
            muted: params.muted,
            audioBitrate: params.audioBitrate,
            videoBitrate: params.videoBitrate,
            encodingMaxRate: params.encodingMaxRate,
            encodingBufferSize: params.encodingBufferSize,
            launchFunctionConfig: {
                version: serverless_client_1.VERSION,
            },
            resolvedProps: serializedResolvedProps,
            offthreadVideoCacheSizeInBytes: params.offthreadVideoCacheSizeInBytes,
            deleteAfter: params.deleteAfter,
            colorSpace: params.colorSpace,
            preferLossless: params.preferLossless,
            compositionStart: realFrameRange[0],
            framesPerLambda,
            progressEveryNthFrame,
            forcePathStyle: params.forcePathStyle,
            metadata: params.metadata,
            offthreadVideoThreads: params.offthreadVideoThreads,
            mediaCacheSizeInBytes: params.mediaCacheSizeInBytes,
        };
        return payload;
    });
    renderer_1.RenderInternals.Log.info(logOptions, 'Render plan: ', chunks.map((c, i) => `Chunk ${i} (Frames ${c[0]} - ${c[1]})`).join(', '));
    const rendererFunctionName = (_c = params.rendererFunctionName) !== null && _c !== void 0 ? _c : insideFunctionSpecifics.getCurrentFunctionName();
    const renderMetadata = {
        startedDate,
        totalChunks: chunks.length,
        estimatedTotalLambdaInvokations: [
            // Direct invokations
            chunks.length,
            // This function
            1,
        ].reduce((a, b) => a + b, 0),
        estimatedRenderLambdaInvokations: chunks.length,
        compositionId: comp.id,
        siteId: params.serveUrl,
        codec: params.codec,
        type: 'video',
        imageFormat: params.imageFormat,
        inputProps: params.inputProps,
        lambdaVersion: serverless_client_1.VERSION,
        framesPerLambda,
        memorySizeInMb: insideFunctionSpecifics.getCurrentMemorySizeInMb(),
        region: insideFunctionSpecifics.getCurrentRegionInFunction(),
        renderId: params.renderId,
        outName: (0, remove_outname_credentials_1.removeOutnameCredentials)((_d = params.outName) !== null && _d !== void 0 ? _d : undefined),
        privacy: params.privacy,
        everyNthFrame: params.everyNthFrame,
        frameRange: realFrameRange,
        audioCodec: params.audioCodec,
        deleteAfter: params.deleteAfter,
        numberOfGifLoops: params.numberOfGifLoops,
        downloadBehavior: params.downloadBehavior,
        audioBitrate: params.audioBitrate,
        muted: params.muted,
        metadata: params.metadata,
        functionName: insideFunctionSpecifics.getCurrentFunctionName(),
        dimensions: {
            width: comp.width * ((_e = params.scale) !== null && _e !== void 0 ? _e : 1),
            height: comp.height * ((_f = params.scale) !== null && _f !== void 0 ? _f : 1),
        },
        rendererFunctionName: (_g = params.rendererFunctionName) !== null && _g !== void 0 ? _g : insideFunctionSpecifics.getCurrentFunctionName(),
        scale: params.scale,
    };
    const { key, renderBucketName, customCredentials } = (0, serverless_client_2.getExpectedOutName)({
        renderMetadata,
        bucketName: params.bucketName,
        customCredentials: typeof params.outName === 'string' ||
            typeof params.outName === 'undefined'
            ? null
            : ((_j = (_h = params.outName) === null || _h === void 0 ? void 0 : _h.s3OutputProvider) !== null && _j !== void 0 ? _j : null),
        bucketNamePrefix: providerSpecifics.getBucketPrefix(),
    });
    if (!params.overwrite) {
        const findOutputFile = insideFunctionSpecifics.timer('Checking if output file already exists', params.logLevel);
        const output = await (0, find_output_file_in_bucket_1.findOutputFileInBucket)({
            bucketName: params.bucketName,
            customCredentials,
            renderMetadata,
            region: insideFunctionSpecifics.getCurrentRegionInFunction(),
            currentRegion: insideFunctionSpecifics.getCurrentRegionInFunction(),
            providerSpecifics,
            forcePathStyle: params.forcePathStyle,
            requestHandler: null,
        });
        if (output) {
            throw new TypeError(`Output file "${key}" in bucket "${renderBucketName}" in region "${insideFunctionSpecifics.getCurrentRegionInFunction()}" already exists. Delete it before re-rendering, or set the 'overwrite' option in renderMediaOnLambda() to overwrite it."`);
        }
        findOutputFile.end();
    }
    overallProgress.setRenderMetadata(renderMetadata);
    const outdir = (0, path_1.join)(renderer_1.RenderInternals.tmpDir(serverless_client_2.CONCAT_FOLDER_TOKEN), 'bucket');
    if ((0, fs_1.existsSync)(outdir)) {
        (0, fs_1.rmSync)(outdir, {
            recursive: true,
        });
    }
    (0, fs_1.mkdirSync)(outdir);
    const files = [];
    const onArtifact = (artifact) => {
        var _a;
        if (overallProgress
            .getReceivedArtifacts()
            .find((a) => a.filename === artifact.filename)) {
            return { alreadyExisted: true };
        }
        const region = insideFunctionSpecifics.getCurrentRegionInFunction();
        const storageKey = (0, serverless_client_2.artifactName)(renderMetadata.renderId, artifact.filename);
        const start = Date.now();
        renderer_1.RenderInternals.Log.info({ indent: false, logLevel: params.logLevel }, 'Writing artifact ' + artifact.filename + ' to S3');
        providerSpecifics
            .writeFile({
            bucketName: renderBucketName,
            key: storageKey,
            body: artifact.content,
            region,
            privacy: params.privacy,
            expectedBucketOwner: options.expectedBucketOwner,
            downloadBehavior: (_a = artifact.downloadBehavior) !== null && _a !== void 0 ? _a : params.downloadBehavior,
            customCredentials,
            forcePathStyle: params.forcePathStyle,
            storageClass: params.storageClass,
            requestHandler: null,
        })
            .then(() => {
            renderer_1.RenderInternals.Log.info({ indent: false, logLevel: params.logLevel }, `Wrote artifact to S3 in ${Date.now() - start}ms`);
            overallProgress.addReceivedArtifact(insideFunctionSpecifics.makeArtifactWithDetails({
                region,
                renderBucketName,
                storageKey,
                artifact,
            }));
        })
            .catch((err) => {
            overallProgress.addErrorWithoutUpload({
                type: 'artifact',
                message: err.message,
                name: err.name,
                stack: err.stack,
                tmpDir: null,
                frame: artifact.frame,
                chunk: null,
                isFatal: false,
                attempt: 1,
                willRetry: false,
                totalAttempts: 1,
            });
            overallProgress.upload();
            renderer_1.RenderInternals.Log.error({ indent: false, logLevel: params.logLevel }, 'Failed to write artifact to S3', err);
        });
        return { alreadyExisted: false };
    };
    await Promise.all(lambdaPayloads.map(async (payload) => {
        await (0, stream_renderer_1.streamRendererFunctionWithRetry)({
            files,
            functionName: rendererFunctionName,
            outdir,
            overallProgress,
            payload,
            logLevel: params.logLevel,
            onArtifact,
            providerSpecifics,
            insideFunctionSpecifics,
            requestHandler: null,
        });
    }));
    const postRenderData = await (0, merge_chunks_1.mergeChunksAndFinishRender)({
        bucketName: params.bucketName,
        renderId: params.renderId,
        expectedBucketOwner: options.expectedBucketOwner,
        numberOfFrames: comp.durationInFrames,
        audioCodec: params.audioCodec,
        chunkCount: chunks.length,
        codec: params.codec,
        customCredentials,
        downloadBehavior: params.downloadBehavior,
        fps,
        key,
        numberOfGifLoops: params.numberOfGifLoops,
        privacy: params.privacy,
        renderBucketName,
        inputProps: params.inputProps,
        serializedResolvedProps,
        renderMetadata,
        audioBitrate: params.audioBitrate,
        logLevel: params.logLevel,
        framesPerLambda,
        binariesDirectory: null,
        preferLossless: params.preferLossless,
        compositionStart: realFrameRange[0],
        outdir,
        files: files.sort(),
        overallProgress,
        startTime,
        providerSpecifics,
        forcePathStyle: params.forcePathStyle,
        insideFunctionSpecifics,
        everyNthFrame: params.everyNthFrame,
        frameRange: params.frameRange,
        storageClass: params.storageClass,
        requestHandler: null,
    });
    return postRenderData;
};
const launchHandler = async ({ params, options, providerSpecifics, insideFunctionSpecifics, }) => {
    var _a, _b, _c;
    if (params.type !== serverless_client_2.ServerlessRoutines.launch) {
        throw new Error('Expected launch type');
    }
    const logOptions = {
        indent: false,
        logLevel: params.logLevel,
    };
    const cleanupTasks = [];
    let instance = null;
    const registerCleanupTask = (task) => {
        cleanupTasks.push(task);
    };
    const runCleanupTasks = () => {
        const prom = Promise.all(cleanupTasks)
            .then(() => {
            renderer_1.RenderInternals.Log.info({ indent: false, logLevel: params.logLevel }, 'Ran cleanup tasks');
        })
            .catch((err) => {
            renderer_1.RenderInternals.Log.error({ indent: false, logLevel: params.logLevel }, 'Failed to run cleanup tasks:', err);
        });
        cleanupTasks.length = 0;
        return prom;
    };
    const onTimeout = async () => {
        var _a;
        renderer_1.RenderInternals.Log.error({ indent: false, logLevel: params.logLevel }, 'Function is about to time out. Can not finish render.');
        // @ts-expect-error - We are adding a listener to a global variable
        if (globalThis._dumpUnreleasedBuffers) {
            // @ts-expect-error - We are adding a listener to a global variable
            globalThis._dumpUnreleasedBuffers.emit('dump-unreleased-buffers');
        }
        runCleanupTasks();
        if (!params.webhook) {
            renderer_1.RenderInternals.Log.verbose({
                indent: false,
                logLevel: params.logLevel,
            }, 'No webhook specified.');
            return;
        }
        if (webhookInvoked) {
            renderer_1.RenderInternals.Log.verbose({
                indent: false,
                logLevel: params.logLevel,
            }, 'Webhook already invoked. Not invoking again.');
            return;
        }
        try {
            await insideFunctionSpecifics.invokeWebhook({
                options: {
                    url: params.webhook.url,
                    secret: params.webhook.secret,
                    payload: {
                        type: 'timeout',
                        renderId: params.renderId,
                        expectedBucketOwner: options.expectedBucketOwner,
                        bucketName: params.bucketName,
                        customData: (_a = params.webhook.customData) !== null && _a !== void 0 ? _a : null,
                    },
                },
                logLevel: params.logLevel,
            });
            renderer_1.RenderInternals.Log.verbose({
                indent: false,
                logLevel: params.logLevel,
            }, 'Successfully invoked timeout webhook.', params.webhook.url);
            webhookInvoked = true;
        }
        catch (err) {
            if (process.env.NODE_ENV === 'test') {
                throw err;
            }
            renderer_1.RenderInternals.Log.error({ indent: false, logLevel: params.logLevel }, 'Failed to invoke webhook:');
            renderer_1.RenderInternals.Log.error({ indent: false, logLevel: params.logLevel }, err);
            overallProgress.addErrorWithoutUpload({
                type: 'webhook',
                message: err.message,
                name: err.name,
                stack: err.stack,
                tmpDir: null,
                frame: 0,
                chunk: 0,
                isFatal: false,
                attempt: 1,
                willRetry: false,
                totalAttempts: 1,
            });
            overallProgress.upload();
        }
    };
    let webhookInvoked = false;
    const webhookDueToTimeout = setTimeout(onTimeout, Math.max(options.getRemainingTimeInMillis() - 1000, 1000));
    renderer_1.RenderInternals.Log.info(logOptions, `Function has ${Math.max(options.getRemainingTimeInMillis() - 1000, 1000)} before it times out`);
    const overallProgress = (0, overall_render_progress_1.makeOverallRenderProgress)({
        renderId: params.renderId,
        bucketName: params.bucketName,
        expectedBucketOwner: options.expectedBucketOwner,
        region: insideFunctionSpecifics.getCurrentRegionInFunction(),
        timeoutTimestamp: options.getRemainingTimeInMillis() + Date.now(),
        logLevel: params.logLevel,
        providerSpecifics,
        forcePathStyle: params.forcePathStyle,
    });
    try {
        const postRenderData = await innerLaunchHandler({
            params,
            options,
            overallProgress,
            registerCleanupTask,
            providerSpecifics,
            insideFunctionSpecifics,
            onBrowser: (browser) => {
                instance = browser;
            },
        });
        clearTimeout(webhookDueToTimeout);
        (0, send_telemetry_event_1.sendTelemetryEvent)((_a = params.apiKey) !== null && _a !== void 0 ? _a : null, params.logLevel);
        if (!params.webhook || webhookInvoked) {
            return;
        }
        try {
            await insideFunctionSpecifics.invokeWebhook({
                options: {
                    url: params.webhook.url,
                    secret: params.webhook.secret,
                    payload: {
                        type: 'success',
                        renderId: params.renderId,
                        expectedBucketOwner: options.expectedBucketOwner,
                        bucketName: params.bucketName,
                        customData: (_b = params.webhook.customData) !== null && _b !== void 0 ? _b : null,
                        outputUrl: postRenderData.outputFile,
                        lambdaErrors: postRenderData.errors,
                        outputFile: postRenderData.outputFile,
                        timeToFinish: postRenderData.timeToFinish,
                        costs: postRenderData.cost,
                    },
                },
                logLevel: params.logLevel,
            });
            webhookInvoked = true;
        }
        catch (err) {
            if (process.env.NODE_ENV === 'test') {
                throw err;
            }
            overallProgress.addErrorWithoutUpload({
                type: 'webhook',
                message: err.message,
                name: err.name,
                stack: err.stack,
                tmpDir: null,
                frame: 0,
                chunk: 0,
                isFatal: false,
                attempt: 1,
                willRetry: false,
                totalAttempts: 1,
            });
            overallProgress.upload();
            renderer_1.RenderInternals.Log.error({ indent: false, logLevel: params.logLevel }, 'Failed to invoke webhook:');
            renderer_1.RenderInternals.Log.error({ indent: false, logLevel: params.logLevel }, err);
        }
        runCleanupTasks();
    }
    catch (err) {
        if (process.env.NODE_ENV === 'test') {
            throw err;
        }
        renderer_1.RenderInternals.Log.error({ indent: false, logLevel: params.logLevel }, 'Error occurred', err);
        overallProgress.addErrorWithoutUpload({
            chunk: null,
            frame: null,
            name: err.name,
            stack: err.stack,
            type: 'stitcher',
            isFatal: true,
            tmpDir: (0, get_tmp_dir_1.getTmpDirStateIfENoSp)(err.stack, insideFunctionSpecifics),
            attempt: 1,
            totalAttempts: 1,
            willRetry: false,
            message: err.message,
        });
        await overallProgress.upload();
        runCleanupTasks();
        renderer_1.RenderInternals.Log.error({ indent: false, logLevel: params.logLevel }, 'Wrote error to S3');
        clearTimeout(webhookDueToTimeout);
        if (params.webhook && !webhookInvoked) {
            try {
                await insideFunctionSpecifics.invokeWebhook({
                    options: {
                        url: params.webhook.url,
                        secret: params.webhook.secret,
                        payload: {
                            type: 'error',
                            renderId: params.renderId,
                            expectedBucketOwner: options.expectedBucketOwner,
                            bucketName: params.bucketName,
                            customData: (_c = params.webhook.customData) !== null && _c !== void 0 ? _c : null,
                            errors: [err].map((e) => ({
                                message: e.message,
                                name: e.name,
                                stack: e.stack,
                            })),
                        },
                    },
                    logLevel: params.logLevel,
                });
                webhookInvoked = true;
            }
            catch (error) {
                if (process.env.NODE_ENV === 'test') {
                    throw error;
                }
                overallProgress.addErrorWithoutUpload({
                    type: 'webhook',
                    message: err.message,
                    name: err.name,
                    stack: err.stack,
                    tmpDir: null,
                    frame: 0,
                    chunk: 0,
                    isFatal: false,
                    attempt: 1,
                    willRetry: false,
                    totalAttempts: 1,
                });
                overallProgress.upload();
                renderer_1.RenderInternals.Log.error({ indent: false, logLevel: params.logLevel }, 'Failed to invoke webhook:');
                renderer_1.RenderInternals.Log.error({ indent: false, logLevel: params.logLevel }, error);
            }
        }
    }
    finally {
        if (instance) {
            insideFunctionSpecifics.forgetBrowserEventLoop({
                logLevel: params.logLevel,
                launchedBrowser: instance,
            });
        }
    }
};
exports.launchHandler = launchHandler;
