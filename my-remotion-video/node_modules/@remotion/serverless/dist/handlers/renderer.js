"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rendererHandler = void 0;
const renderer_1 = require("@remotion/renderer");
const pure_1 = require("@remotion/renderer/pure");
const serverless_client_1 = require("@remotion/serverless-client");
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const get_tmp_dir_1 = require("../get-tmp-dir");
const leak_detection_1 = require("../leak-detection");
const on_downloads_helpers_1 = require("../on-downloads-helpers");
const why_is_node_running_1 = require("../why-is-node-running");
const renderHandler = async ({ params, options, logs, onStream, providerSpecifics, insideFunctionSpecifics, onBrowserInstance, }) => {
    if (params.type !== serverless_client_1.ServerlessRoutines.renderer) {
        throw new Error('Params must be renderer');
    }
    if (params.launchFunctionConfig.version !== serverless_client_1.VERSION) {
        throw new Error(`The version of the function that was specified as "rendererFunctionName" is ${serverless_client_1.VERSION} but the version of the function that invoked the render is ${params.launchFunctionConfig.version}. Please make sure that the version of the function that is specified as "rendererFunctionName" is the same as the version of the function that is invoked.`);
    }
    const inputPropsPromise = (0, serverless_client_1.decompressInputProps)({
        bucketName: params.bucketName,
        expectedBucketOwner: options.expectedBucketOwner,
        region: insideFunctionSpecifics.getCurrentRegionInFunction(),
        serialized: params.inputProps,
        propsType: 'input-props',
        providerSpecifics,
        forcePathStyle: params.forcePathStyle,
        requestHandler: null,
    });
    const resolvedPropsPromise = (0, serverless_client_1.decompressInputProps)({
        bucketName: params.bucketName,
        expectedBucketOwner: options.expectedBucketOwner,
        region: insideFunctionSpecifics.getCurrentRegionInFunction(),
        serialized: params.resolvedProps,
        propsType: 'resolved-props',
        providerSpecifics,
        forcePathStyle: params.forcePathStyle,
        requestHandler: null,
    });
    renderer_1.RenderInternals.Log.verbose({ indent: false, logLevel: params.logLevel }, `Waiting for browser instance`);
    const browserInstance = await insideFunctionSpecifics.getBrowserInstance({
        logLevel: params.logLevel,
        indent: false,
        chromiumOptions: params.chromiumOptions,
        providerSpecifics,
        insideFunctionSpecifics,
    });
    onBrowserInstance(browserInstance);
    const outputPath = renderer_1.RenderInternals.tmpDir('remotion-render-');
    if (typeof params.chunk !== 'number') {
        throw new Error('must pass chunk');
    }
    if (!params.frameRange) {
        throw new Error('must pass framerange');
    }
    renderer_1.RenderInternals.Log.verbose({ indent: false, logLevel: params.logLevel }, `Rendering frames ${params.frameRange[0]}-${params.frameRange[1]} (chunk ${params.chunk}) in this function`);
    const start = Date.now();
    const chunkTimingData = {
        timings: {},
        chunk: params.chunk,
        frameRange: params.frameRange,
        startDate: start,
    };
    const outdir = renderer_1.RenderInternals.tmpDir(serverless_client_1.RENDERER_PATH_TOKEN);
    const chunk = `localchunk-${String(params.chunk).padStart(8, '0')}`;
    const defaultAudioCodec = renderer_1.RenderInternals.getDefaultAudioCodec({
        codec: params.codec,
        preferLossless: params.preferLossless,
    });
    const seamlessAudio = renderer_1.RenderInternals.canConcatAudioSeamlessly(defaultAudioCodec, params.framesPerLambda);
    const seamlessVideo = renderer_1.RenderInternals.canConcatVideoSeamlessly(params.codec);
    renderer_1.RenderInternals.Log.verbose({ indent: false, logLevel: params.logLevel }, `Preparing for rendering a chunk. Audio = ${seamlessAudio ? 'seamless' : 'normal'}, Video = ${seamlessVideo ? 'seamless' : 'normal'}`, params.logLevel);
    const chunkCodec = seamlessVideo && params.codec === 'h264'
        ? 'h264-ts'
        : params.codec === 'gif'
            ? 'h264-ts'
            : params.codec;
    const audioCodec = defaultAudioCodec === null
        ? null
        : seamlessAudio
            ? defaultAudioCodec
            : 'pcm-16';
    const videoExtension = renderer_1.RenderInternals.getFileExtensionFromCodec(chunkCodec, audioCodec);
    const audioExtension = audioCodec
        ? renderer_1.RenderInternals.getExtensionFromAudioCodec(audioCodec)
        : null;
    const videoOutputLocation = node_path_1.default.join(outdir, `${chunk}.${videoExtension}`);
    const willRenderAudioEval = renderer_1.RenderInternals.getShouldRenderAudio({
        assetsInfo: null,
        codec: params.codec,
        enforceAudioTrack: true,
        muted: params.muted,
    });
    if (willRenderAudioEval === 'maybe') {
        throw new Error('Cannot determine whether to render audio or not');
    }
    const audioOutputLocation = willRenderAudioEval === 'no'
        ? null
        : pure_1.NoReactAPIs.isAudioCodec(params.codec)
            ? null
            : audioExtension
                ? node_path_1.default.join(outdir, `${chunk}.${audioExtension}`)
                : null;
    const resolvedProps = await resolvedPropsPromise;
    const serializedInputPropsWithCustomSchema = await inputPropsPromise;
    const allFrames = renderer_1.RenderInternals.getFramesToRender(params.frameRange, params.everyNthFrame);
    const onArtifact = (artifact) => {
        renderer_1.RenderInternals.Log.info({ indent: false, logLevel: params.logLevel }, `Received artifact on frame ${artifact.frame}:`, artifact.filename, artifact.content.length + 'bytes. Streaming to main function');
        const startTimestamp = Date.now();
        onStream({
            type: 'artifact-emitted',
            payload: {
                artifact: (0, serverless_client_1.serializeArtifact)(artifact),
            },
        })
            .then(() => {
            renderer_1.RenderInternals.Log.info({ indent: false, logLevel: params.logLevel }, `Streaming artifact ${artifact.filename} to main function took ${Date.now() - startTimestamp}ms`);
        })
            .catch((e) => {
            renderer_1.RenderInternals.Log.error({ indent: false, logLevel: params.logLevel }, `Error streaming artifact ${artifact.filename} to main function`, e);
        });
    };
    await new Promise((resolve, reject) => {
        var _a, _b, _c, _d, _e;
        renderer_1.RenderInternals.internalRenderMedia({
            repro: false,
            composition: {
                id: params.composition,
                durationInFrames: params.durationInFrames,
                fps: params.fps,
                height: params.height,
                width: params.width,
                defaultCodec: null,
                defaultOutName: null,
                defaultPixelFormat: null,
                defaultVideoImageFormat: null,
            },
            imageFormat: params.imageFormat,
            serializedInputPropsWithCustomSchema,
            frameRange: params.frameRange,
            onProgress: ({ renderedFrames, encodedFrames, stitchStage }) => {
                renderer_1.RenderInternals.Log.verbose({ indent: false, logLevel: params.logLevel }, `Rendered ${renderedFrames} frames, encoded ${encodedFrames} frames, stage = ${stitchStage}`);
                const allFramesRendered = allFrames.length === renderedFrames;
                const allFramesEncoded = allFrames.length === encodedFrames;
                const frameReportPoint = (renderedFrames % params.progressEveryNthFrame === 0 ||
                    allFramesRendered) &&
                    !allFramesEncoded;
                const encodedFramesReportPoint = (encodedFrames % params.progressEveryNthFrame === 0 ||
                    allFramesEncoded) &&
                    allFramesRendered;
                if (frameReportPoint || encodedFramesReportPoint) {
                    onStream({
                        type: 'frames-rendered',
                        payload: { rendered: renderedFrames, encoded: encodedFrames },
                    });
                }
                if (renderedFrames === allFrames.length) {
                    renderer_1.RenderInternals.Log.verbose({ indent: false, logLevel: params.logLevel }, 'Rendered all frames!');
                }
                chunkTimingData.timings[renderedFrames] = Date.now() - start;
            },
            concurrency: params.concurrencyPerLambda,
            onStart: () => {
                onStream({
                    type: 'lambda-invoked',
                    payload: {
                        attempt: params.attempt,
                    },
                });
            },
            puppeteerInstance: browserInstance.instance,
            serveUrl: params.serveUrl,
            jpegQuality: (_a = params.jpegQuality) !== null && _a !== void 0 ? _a : renderer_1.RenderInternals.DEFAULT_JPEG_QUALITY,
            envVariables: (_b = params.envVariables) !== null && _b !== void 0 ? _b : {},
            logLevel: params.logLevel,
            onBrowserLog: (log) => {
                logs.push(log);
            },
            outputLocation: videoOutputLocation,
            codec: chunkCodec,
            crf: (_c = params.crf) !== null && _c !== void 0 ? _c : null,
            pixelFormat: (_d = params.pixelFormat) !== null && _d !== void 0 ? _d : renderer_1.RenderInternals.DEFAULT_PIXEL_FORMAT,
            proResProfile: (_e = params.proResProfile) !== null && _e !== void 0 ? _e : undefined,
            x264Preset: params.x264Preset,
            onDownload: (0, on_downloads_helpers_1.onDownloadsHelper)(params.logLevel),
            overwrite: false,
            chromiumOptions: params.chromiumOptions,
            scale: params.scale,
            timeoutInMilliseconds: params.timeoutInMilliseconds,
            port: null,
            everyNthFrame: params.everyNthFrame,
            numberOfGifLoops: null,
            muted: params.muted,
            enforceAudioTrack: true,
            audioBitrate: params.audioBitrate,
            videoBitrate: params.videoBitrate,
            encodingBufferSize: params.encodingBufferSize,
            encodingMaxRate: params.encodingMaxRate,
            audioCodec,
            preferLossless: params.preferLossless,
            browserExecutable: providerSpecifics.getChromiumPath(),
            cancelSignal: undefined,
            disallowParallelEncoding: false,
            ffmpegOverride: ({ args }) => args,
            indent: false,
            onCtrlCExit: () => undefined,
            server: undefined,
            serializedResolvedPropsWithCustomSchema: resolvedProps,
            offthreadVideoCacheSizeInBytes: params.offthreadVideoCacheSizeInBytes,
            colorSpace: params.colorSpace,
            binariesDirectory: null,
            separateAudioTo: audioOutputLocation,
            forSeamlessAacConcatenation: seamlessAudio,
            compositionStart: params.compositionStart,
            onBrowserDownload: () => {
                throw new Error('Should not download a browser in Lambda');
            },
            onArtifact,
            metadata: params.metadata,
            hardwareAcceleration: 'disable',
            chromeMode: 'headless-shell',
            offthreadVideoThreads: params.offthreadVideoThreads,
            mediaCacheSizeInBytes: params.mediaCacheSizeInBytes,
            onLog: renderer_1.RenderInternals.defaultOnLog,
        })
            .then(({ slowestFrames }) => {
            renderer_1.RenderInternals.Log.verbose({ indent: false, logLevel: params.logLevel }, `Slowest frames:`);
            slowestFrames.forEach(({ frame, time }) => {
                renderer_1.RenderInternals.Log.verbose({ indent: false, logLevel: params.logLevel }, `  Frame ${frame} (${time.toFixed(3)}ms)`);
            });
            resolve();
        })
            .catch((err) => reject(err));
    });
    const streamTimer = insideFunctionSpecifics.timer('Streaming chunk to the main function', params.logLevel);
    if (audioOutputLocation) {
        const audioChunkTimer = insideFunctionSpecifics.timer('Sending audio chunk', params.logLevel);
        await onStream({
            type: 'audio-chunk-rendered',
            payload: new Uint8Array(node_fs_1.default.readFileSync(audioOutputLocation)),
        });
        audioChunkTimer.end();
    }
    if (videoOutputLocation) {
        const videoChunkTimer = insideFunctionSpecifics.timer('Sending main chunk', params.logLevel);
        await onStream({
            type: pure_1.NoReactAPIs.isAudioCodec(params.codec)
                ? 'audio-chunk-rendered'
                : 'video-chunk-rendered',
            payload: new Uint8Array(node_fs_1.default.readFileSync(videoOutputLocation)),
        });
        videoChunkTimer.end();
    }
    const endRendered = Date.now();
    await onStream({
        type: 'chunk-complete',
        payload: {
            rendered: endRendered,
            start,
        },
    });
    streamTimer.end();
    renderer_1.RenderInternals.Log.verbose({ indent: false, logLevel: params.logLevel }, 'Cleaning up and writing timings');
    await Promise.all([
        node_fs_1.default.promises.rm(videoOutputLocation, { recursive: true }),
        audioOutputLocation
            ? node_fs_1.default.promises.rm(audioOutputLocation, { recursive: true })
            : null,
        node_fs_1.default.promises.rm(outputPath, { recursive: true }),
    ].filter(serverless_client_1.truthy));
    renderer_1.RenderInternals.Log.verbose({ indent: false, logLevel: params.logLevel }, 'Done!');
    return {};
};
const ENABLE_SLOW_LEAK_DETECTION = false;
const rendererHandler = async ({ onStream, options, params, providerSpecifics, requestContext, insideFunctionSpecifics, }) => {
    if (params.type !== serverless_client_1.ServerlessRoutines.renderer) {
        throw new Error('Params must be renderer');
    }
    const logs = [];
    const leakDetection = (0, why_is_node_running_1.enableNodeIntrospection)(ENABLE_SLOW_LEAK_DETECTION);
    let shouldKeepBrowserOpen = true;
    let instance;
    try {
        await renderHandler({
            params,
            options,
            logs,
            onStream,
            providerSpecifics,
            insideFunctionSpecifics,
            onBrowserInstance: (browserInstance) => {
                instance = browserInstance;
            },
        });
    }
    catch (err) {
        if (process.env.NODE_ENV === 'test') {
            // eslint-disable-next-line no-console
            console.log({ err });
            throw err;
        }
        // If this error is encountered, we can just retry as it
        // is a very rare error to occur
        const isRetryableError = providerSpecifics.isFlakyError(err);
        if (isRetryableError) {
            shouldKeepBrowserOpen = false;
        }
        const shouldNotRetry = err.name === 'CancelledError';
        const shouldRetry = isRetryableError && params.retriesLeft > 0 && !shouldNotRetry;
        renderer_1.RenderInternals.Log.error({ indent: false, logLevel: params.logLevel }, `Error occurred (will retry = ${String(shouldRetry)})`);
        renderer_1.RenderInternals.Log.error({ indent: false, logLevel: params.logLevel }, err.stack);
        onStream({
            type: 'error-occurred',
            payload: {
                error: err.stack,
                shouldRetry,
                errorInfo: {
                    name: err.name,
                    message: err.message,
                    stack: err.stack,
                    chunk: params.chunk,
                    frame: null,
                    type: 'renderer',
                    isFatal: !shouldRetry,
                    tmpDir: (0, get_tmp_dir_1.getTmpDirStateIfENoSp)(err.stack, insideFunctionSpecifics),
                    attempt: params.attempt,
                    totalAttempts: params.retriesLeft + params.attempt,
                    willRetry: shouldRetry,
                },
            },
        });
    }
    finally {
        if (shouldKeepBrowserOpen && instance) {
            insideFunctionSpecifics.forgetBrowserEventLoop({
                logLevel: params.logLevel,
                launchedBrowser: instance,
            });
        }
        else {
            renderer_1.RenderInternals.Log.info({ indent: false, logLevel: params.logLevel }, 'Function did not succeed with flaky error, not keeping browser open.');
            renderer_1.RenderInternals.Log.info({ indent: false, logLevel: params.logLevel }, 'Waiting 2 seconds to allow for response to be sent');
            setTimeout(() => {
                renderer_1.RenderInternals.Log.info({ indent: false, logLevel: params.logLevel }, 'Quitting Function forcefully now to force not keeping the Function warm.');
                process.exit(0);
            }, 2000);
        }
        if (ENABLE_SLOW_LEAK_DETECTION) {
            (0, leak_detection_1.startLeakDetection)(leakDetection, requestContext.awsRequestId);
        }
    }
};
exports.rendererHandler = rendererHandler;
