"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stillHandler = void 0;
const renderer_1 = require("@remotion/renderer");
const serverless_client_1 = require("@remotion/serverless-client");
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const cleanup_serialized_input_props_1 = require("../cleanup-serialized-input-props");
const get_tmp_dir_1 = require("../get-tmp-dir");
const on_downloads_helpers_1 = require("../on-downloads-helpers");
const overall_render_progress_1 = require("../overall-render-progress");
const remove_outname_credentials_1 = require("../remove-outname-credentials");
const validate_composition_1 = require("../validate-composition");
const check_version_mismatch_1 = require("./check-version-mismatch");
const send_telemetry_event_1 = require("./send-telemetry-event");
const innerStillHandler = async ({ params, expectedBucketOwner, renderId, onStream, timeoutInMilliseconds, providerSpecifics, insideFunctionSpecifics, }, cleanup) => {
    var _a, _b, _c, _d, _e, _f;
    if (params.type !== serverless_client_1.ServerlessRoutines.still) {
        throw new TypeError('Expected still type');
    }
    (0, check_version_mismatch_1.checkVersionMismatch)({
        apiName: 'renderStillOnLambda()',
        insideFunctionSpecifics,
        params,
    });
    (0, serverless_client_1.validateDownloadBehavior)(params.downloadBehavior);
    (0, serverless_client_1.validatePrivacy)(params.privacy, true);
    (0, serverless_client_1.validateOutname)({
        outName: params.outName,
        codec: null,
        audioCodecSetting: null,
        separateAudioTo: null,
        bucketNamePrefix: providerSpecifics.getBucketPrefix(),
    });
    const start = Date.now();
    const browserInstancePromise = insideFunctionSpecifics.getBrowserInstance({
        logLevel: params.logLevel,
        indent: false,
        chromiumOptions: params.chromiumOptions,
        providerSpecifics,
        insideFunctionSpecifics,
    });
    browserInstancePromise.then((instance) => {
        cleanup.push(() => {
            insideFunctionSpecifics.forgetBrowserEventLoop({
                logLevel: params.type === serverless_client_1.ServerlessRoutines.still ? params.logLevel : 'error',
                launchedBrowser: instance,
            });
            return Promise.resolve();
        });
    });
    const bucketNamePromise = (_a = params.bucketName) !== null && _a !== void 0 ? _a : (0, serverless_client_1.internalGetOrCreateBucket)({
        region: insideFunctionSpecifics.getCurrentRegionInFunction(),
        enableFolderExpiry: null,
        customCredentials: null,
        providerSpecifics,
        forcePathStyle: params.forcePathStyle,
        skipPutAcl: false,
        requestHandler: null,
    }).then((b) => b.bucketName);
    const outputDir = renderer_1.RenderInternals.tmpDir('remotion-render-');
    const outputPath = node_path_1.default.join(outputDir, 'output');
    const region = insideFunctionSpecifics.getCurrentRegionInFunction();
    const bucketName = await bucketNamePromise;
    const serializedInputPropsWithCustomSchema = await (0, serverless_client_1.decompressInputProps)({
        bucketName,
        expectedBucketOwner,
        region,
        serialized: params.inputProps,
        propsType: 'input-props',
        providerSpecifics,
        forcePathStyle: params.forcePathStyle,
        requestHandler: null,
    });
    const serveUrl = providerSpecifics.convertToServeUrl({
        urlOrId: params.serveUrl,
        region,
        bucketName,
    });
    const { server, cleanupServer } = await renderer_1.RenderInternals.makeOrReuseServer(undefined, {
        offthreadVideoThreads: (_b = params.offthreadVideoThreads) !== null && _b !== void 0 ? _b : renderer_1.RenderInternals.DEFAULT_RENDER_FRAMES_OFFTHREAD_VIDEO_THREADS,
        indent: false,
        port: null,
        remotionRoot: process.cwd(),
        logLevel: params.logLevel,
        webpackConfigOrServeUrl: serveUrl,
        offthreadVideoCacheSizeInBytes: params.offthreadVideoCacheSizeInBytes,
        binariesDirectory: null,
        forceIPv4: false,
    }, {
        onDownload: () => undefined,
    });
    cleanup.push(() => cleanupServer(true));
    const browserInstance = await browserInstancePromise;
    const composition = await (0, validate_composition_1.validateComposition)({
        serveUrl,
        browserInstance: browserInstance.instance,
        composition: params.composition,
        serializedInputPropsWithCustomSchema,
        envVariables: (_c = params.envVariables) !== null && _c !== void 0 ? _c : {},
        chromiumOptions: params.chromiumOptions,
        timeoutInMilliseconds: params.timeoutInMilliseconds,
        port: null,
        forceHeight: params.forceHeight,
        forceWidth: params.forceWidth,
        logLevel: params.logLevel,
        server,
        offthreadVideoCacheSizeInBytes: params.offthreadVideoCacheSizeInBytes,
        onBrowserDownload: () => {
            throw new Error('Should not download a browser in Lambda');
        },
        onServeUrlVisited: () => undefined,
        providerSpecifics,
        offthreadVideoThreads: params.offthreadVideoThreads,
        mediaCacheSizeInBytes: params.mediaCacheSizeInBytes,
    });
    const renderMetadata = {
        startedDate: Date.now(),
        codec: null,
        compositionId: params.composition,
        estimatedTotalLambdaInvokations: 1,
        estimatedRenderLambdaInvokations: 1,
        siteId: serveUrl,
        totalChunks: 1,
        type: 'still',
        imageFormat: params.imageFormat,
        inputProps: params.inputProps,
        lambdaVersion: serverless_client_1.VERSION,
        framesPerLambda: 1,
        memorySizeInMb: insideFunctionSpecifics.getCurrentMemorySizeInMb(),
        region: insideFunctionSpecifics.getCurrentRegionInFunction(),
        renderId,
        outName: (0, remove_outname_credentials_1.removeOutnameCredentials)((_d = params.outName) !== null && _d !== void 0 ? _d : undefined),
        privacy: params.privacy,
        audioCodec: null,
        deleteAfter: params.deleteAfter,
        numberOfGifLoops: null,
        downloadBehavior: params.downloadBehavior,
        audioBitrate: null,
        metadata: null,
        functionName: insideFunctionSpecifics.getCurrentFunctionName(),
        rendererFunctionName: insideFunctionSpecifics.getCurrentFunctionName(),
        dimensions: {
            height: composition.height * params.scale,
            width: composition.width * params.scale,
        },
        scale: params.scale,
    };
    const still = (0, overall_render_progress_1.makeInitialOverallRenderProgress)(timeoutInMilliseconds);
    still.renderMetadata = renderMetadata;
    await providerSpecifics.writeFile({
        bucketName,
        key: (0, serverless_client_1.overallProgressKey)(renderId),
        body: JSON.stringify(still),
        region: insideFunctionSpecifics.getCurrentRegionInFunction(),
        privacy: 'private',
        expectedBucketOwner,
        downloadBehavior: null,
        customCredentials: null,
        forcePathStyle: params.forcePathStyle,
        storageClass: null,
        requestHandler: null,
    });
    const onBrowserDownload = () => {
        throw new Error('Should not download a browser in Lambda');
    };
    const receivedArtifact = [];
    const { key, renderBucketName, customCredentials } = (0, serverless_client_1.getExpectedOutName)({
        renderMetadata,
        bucketName,
        customCredentials: (0, serverless_client_1.getCredentialsFromOutName)(params.outName),
        bucketNamePrefix: providerSpecifics.getBucketPrefix(),
    });
    const onArtifact = (artifact) => {
        if (receivedArtifact.find((a) => a.filename === artifact.filename)) {
            return { alreadyExisted: true };
        }
        const storageKey = (0, serverless_client_1.artifactName)(renderMetadata.renderId, artifact.filename);
        receivedArtifact.push(insideFunctionSpecifics.makeArtifactWithDetails({
            storageKey,
            artifact,
            region,
            renderBucketName,
        }));
        const startTime = Date.now();
        renderer_1.RenderInternals.Log.info({ indent: false, logLevel: params.logLevel }, 'Writing artifact ' + artifact.filename + ' to S3');
        providerSpecifics
            .writeFile({
            bucketName: renderBucketName,
            key: storageKey,
            body: artifact.content,
            region,
            privacy: params.privacy,
            expectedBucketOwner,
            downloadBehavior: params.downloadBehavior,
            customCredentials,
            forcePathStyle: params.forcePathStyle,
            storageClass: params.storageClass,
            requestHandler: null,
        })
            .then(() => {
            renderer_1.RenderInternals.Log.info({ indent: false, logLevel: params.logLevel }, `Wrote artifact to S3 in ${Date.now() - startTime}ms`);
        })
            .catch((err) => {
            renderer_1.RenderInternals.Log.error({ indent: false, logLevel: params.logLevel }, 'Failed to write artifact to S3', err);
        });
        return { alreadyExisted: false };
    };
    await renderer_1.RenderInternals.internalRenderStill({
        composition,
        output: outputPath,
        serveUrl,
        envVariables: (_e = params.envVariables) !== null && _e !== void 0 ? _e : {},
        frame: renderer_1.RenderInternals.convertToPositiveFrameIndex({
            frame: params.frame,
            durationInFrames: composition.durationInFrames,
        }),
        imageFormat: params.imageFormat,
        serializedInputPropsWithCustomSchema,
        overwrite: false,
        puppeteerInstance: browserInstance.instance,
        jpegQuality: (_f = params.jpegQuality) !== null && _f !== void 0 ? _f : renderer_1.RenderInternals.DEFAULT_JPEG_QUALITY,
        chromiumOptions: params.chromiumOptions,
        scale: params.scale,
        timeoutInMilliseconds: params.timeoutInMilliseconds,
        browserExecutable: providerSpecifics.getChromiumPath(),
        cancelSignal: null,
        indent: false,
        onBrowserLog: null,
        onDownload: (0, on_downloads_helpers_1.onDownloadsHelper)(params.logLevel),
        port: null,
        server,
        logLevel: params.logLevel,
        serializedResolvedPropsWithCustomSchema: (0, serverless_client_1.serializeJSONWithSpecialTypes)({
            indent: undefined,
            staticBase: null,
            data: composition.props,
        }).serializedString,
        offthreadVideoCacheSizeInBytes: params.offthreadVideoCacheSizeInBytes,
        mediaCacheSizeInBytes: params.mediaCacheSizeInBytes,
        binariesDirectory: null,
        onBrowserDownload,
        onArtifact,
        chromeMode: 'headless-shell',
        offthreadVideoThreads: params.offthreadVideoThreads,
        onLog: renderer_1.RenderInternals.defaultOnLog,
    });
    const { size } = await node_fs_1.default.promises.stat(outputPath);
    await providerSpecifics.writeFile({
        bucketName: renderBucketName,
        key,
        privacy: params.privacy,
        body: node_fs_1.default.createReadStream(outputPath),
        expectedBucketOwner,
        region: insideFunctionSpecifics.getCurrentRegionInFunction(),
        downloadBehavior: params.downloadBehavior,
        customCredentials,
        forcePathStyle: params.forcePathStyle,
        storageClass: params.storageClass,
        requestHandler: null,
    });
    await Promise.all([
        node_fs_1.default.promises.rm(outputPath, { recursive: true }),
        (0, cleanup_serialized_input_props_1.cleanupSerializedInputProps)({
            region: insideFunctionSpecifics.getCurrentRegionInFunction(),
            serialized: params.inputProps,
            providerSpecifics,
            forcePathStyle: params.forcePathStyle,
        }),
        server.closeServer(true),
        (0, send_telemetry_event_1.sendTelemetryEvent)(params.apiKey, params.logLevel),
    ]);
    const estimatedPrice = providerSpecifics.estimatePrice({
        durationInMilliseconds: Date.now() - start + 100,
        memorySizeInMb: insideFunctionSpecifics.getCurrentMemorySizeInMb(),
        region: insideFunctionSpecifics.getCurrentRegionInFunction(),
        lambdasInvoked: 1,
        diskSizeInMb: providerSpecifics.getEphemeralStorageForPriceCalculation(),
    });
    const { key: outKey, url } = providerSpecifics.getOutputUrl({
        renderMetadata,
        bucketName,
        customCredentials,
        currentRegion: insideFunctionSpecifics.getCurrentRegionInFunction(),
    });
    const payload = {
        type: 'success',
        output: url,
        size,
        sizeInBytes: size,
        bucketName,
        estimatedPrice: (0, serverless_client_1.formatCostsInfo)(estimatedPrice),
        renderId,
        outKey,
        receivedArtifacts: receivedArtifact,
    };
    onStream({
        type: 'still-rendered',
        payload,
    });
    await server.closeServer(true);
};
const stillHandler = async (options) => {
    const { params } = options;
    const cleanUpFn = [];
    if (params.type !== serverless_client_1.ServerlessRoutines.still) {
        throw new Error('Params must be renderer');
    }
    try {
        await innerStillHandler(options, cleanUpFn);
        return { type: 'success' };
    }
    catch (err) {
        // If this error is encountered, we can just retry as it
        // is a very rare error to occur
        const isBrowserError = options.providerSpecifics.isFlakyError(err);
        const willRetry = isBrowserError || params.maxRetries > 0;
        renderer_1.RenderInternals.Log.error({
            indent: false,
            logLevel: params.logLevel,
        }, 'Got error:', err.stack, `Will retry = ${willRetry}`);
        if (params.streamed) {
            await options.onStream({
                type: 'error-occurred',
                payload: {
                    error: err.stack,
                    shouldRetry: willRetry,
                    errorInfo: {
                        name: err.name,
                        message: err.message,
                        stack: err.stack,
                        chunk: null,
                        frame: params.frame,
                        type: 'renderer',
                        isFatal: false,
                        tmpDir: (0, get_tmp_dir_1.getTmpDirStateIfENoSp)(err.stack, options.insideFunctionSpecifics),
                        attempt: params.attempt,
                        totalAttempts: 1 + params.maxRetries,
                        willRetry,
                    },
                },
            });
        }
        return {
            type: 'error',
            message: err.message,
            stack: err.stack,
        };
    }
    finally {
        cleanUpFn.forEach((c) => c());
    }
};
exports.stillHandler = stillHandler;
