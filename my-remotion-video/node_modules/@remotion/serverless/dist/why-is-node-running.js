"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.enableNodeIntrospection = void 0;
exports.whyIsNodeRunning = whyIsNodeRunning;
/* eslint-disable no-console */
const async_hooks_1 = __importDefault(require("async_hooks"));
const fs_1 = __importDefault(require("fs"));
const path_1 = require("path");
const stackback_1 = require("./stackback");
const enableNodeIntrospection = (enabled) => {
    const active = new Map();
    if (!enabled) {
        return {
            active,
            hook: null,
        };
    }
    const hook = async_hooks_1.default.createHook({
        init(asyncId, type, _triggerAsyncId, resource) {
            if (type === 'TIMERWRAP' || type === 'PROMISE')
                return;
            if (type === 'PerformanceObserver' || type === 'RANDOMBYTESREQUEST')
                return;
            const err = new Error('whatevs');
            const stacks = (0, stackback_1.stackback)(err);
            active.set(asyncId, { type, stacks, resource });
        },
        destroy(asyncId) {
            active.delete(asyncId);
        },
    });
    hook.enable();
    return { hook, active };
};
exports.enableNodeIntrospection = enableNodeIntrospection;
function whyIsNodeRunning({ active, hook }) {
    if (!hook) {
        return;
    }
    hook.disable();
    const activeResources = [...active.values()].filter((r) => {
        if (typeof r.resource.hasRef === 'function' && !r.resource.hasRef())
            return false;
        return true;
    });
    console.error('There are %d handle(s) keeping the process running', activeResources.length);
    function printStacks(o) {
        const stacks = o.stacks.slice(1).filter((s) => {
            const filename = s.getFileName();
            return (filename &&
                filename.indexOf(path_1.sep) > -1 &&
                filename.indexOf('internal' + path_1.sep) !== 0);
        });
        console.error('');
        console.error('# %s', o.type);
        if (stacks[0]) {
            let padding = '';
            stacks.forEach((s) => {
                const pad = (s.getFileName() + ':' + s.getLineNumber()).replace(/./g, ' ');
                if (pad.length > padding.length)
                    padding = pad;
            });
            stacks.forEach((s) => {
                const prefix = s.getFileName() + ':' + s.getLineNumber();
                try {
                    const src = fs_1.default
                        .readFileSync(s.getFileName(), 'utf-8')
                        .split(/\n|\r\n/);
                    console.error(prefix +
                        padding.slice(prefix.length) +
                        ' - ' +
                        src[s.getLineNumber() - 1].trim());
                }
                catch (_a) {
                    console.error(prefix + padding.slice(prefix.length));
                }
            });
        }
        else {
            console.error('(unknown stack trace)');
        }
    }
    for (const o of activeResources) {
        printStacks(o);
    }
}
