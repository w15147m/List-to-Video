"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startLeakDetection = exports.setCurrentRequestId = exports.stopLeakDetection = void 0;
const why_is_node_running_1 = require("./why-is-node-running");
let currentRequestId = null;
let leakDetectionTimeout = null;
const stopLeakDetection = () => {
    if (leakDetectionTimeout !== null) {
        clearTimeout(leakDetectionTimeout.timeout);
        leakDetectionTimeout = null;
    }
};
exports.stopLeakDetection = stopLeakDetection;
const setCurrentRequestId = (awsRequestId) => {
    currentRequestId = awsRequestId;
};
exports.setCurrentRequestId = setCurrentRequestId;
const startLeakDetection = (leakDetection, awsRequestId) => {
    currentRequestId = awsRequestId;
    leakDetectionTimeout = {
        awsRequestId,
        timeout: setTimeout(() => {
            // First allow request ID to be set
            setTimeout(() => {
                if (currentRequestId !== awsRequestId) {
                    // New function, all good
                    return;
                }
                console.log('Leak detected: Lambda function is still running 10s after the render has finished.');
                console.log('You may report this to the Remotion team.');
                console.log('Include the logs below:');
                (0, why_is_node_running_1.whyIsNodeRunning)(leakDetection);
                console.log('Force-quitting the Lambda function now.');
                process.exit(0);
            }, 100);
        }, 10000),
    };
    leakDetectionTimeout.timeout.unref();
};
exports.startLeakDetection = startLeakDetection;
