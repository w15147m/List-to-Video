"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeOverallRenderProgress = exports.makeInitialOverallRenderProgress = void 0;
const renderer_1 = require("@remotion/renderer");
const serverless_client_1 = require("@remotion/serverless-client");
const makeInitialOverallRenderProgress = (timeoutTimestamp) => {
    return {
        chunks: [],
        framesRendered: 0,
        framesEncoded: 0,
        combinedFrames: 0,
        timeToCombine: null,
        timeToEncode: null,
        lambdasInvoked: 0,
        retries: [],
        postRenderData: null,
        timings: [],
        renderMetadata: null,
        errors: [],
        timeToRenderFrames: null,
        timeoutTimestamp,
        functionLaunched: Date.now(),
        serveUrlOpened: null,
        compositionValidated: null,
        receivedArtifact: [],
    };
};
exports.makeInitialOverallRenderProgress = makeInitialOverallRenderProgress;
const makeOverallRenderProgress = ({ renderId, bucketName, expectedBucketOwner, region, timeoutTimestamp, logLevel, providerSpecifics, forcePathStyle, }) => {
    let framesRendered = [];
    let framesEncoded = [];
    let lambdasInvoked = [];
    const renderProgress = (0, exports.makeInitialOverallRenderProgress)(timeoutTimestamp);
    let currentUploadPromise = null;
    const getCurrentProgress = () => renderProgress;
    let latestUploadRequest = 0;
    const getLatestRequestId = () => latestUploadRequest;
    let encodeStartTime = null;
    let renderFramesStartTime = null;
    const upload = async () => {
        const uploadRequestId = ++latestUploadRequest;
        if (currentUploadPromise) {
            await currentUploadPromise;
        }
        // If request has been replaced by a new one
        if (getLatestRequestId() !== uploadRequestId) {
            return;
        }
        const toWrite = JSON.stringify(getCurrentProgress());
        const start = Date.now();
        currentUploadPromise = providerSpecifics
            .writeFile({
            body: toWrite,
            bucketName,
            customCredentials: null,
            downloadBehavior: null,
            expectedBucketOwner,
            key: (0, serverless_client_1.overallProgressKey)(renderId),
            privacy: 'private',
            region,
            forcePathStyle,
            storageClass: null,
            requestHandler: null,
        })
            .then(() => {
            // By default, upload is way too fast (~20 requests per second)
            // Space out the requests a bit
            return new Promise((resolve) => {
                setTimeout(resolve, 250 - (Date.now() - start));
            });
        })
            .catch((err) => {
            // If an error occurs in uploading the state that contains the errors,
            // that is unfortunate. We just log it.
            renderer_1.RenderInternals.Log.error({ indent: false, logLevel }, 'Error uploading progress', err);
        });
        await currentUploadPromise;
        currentUploadPromise = null;
    };
    return {
        upload,
        setFrames: ({ encoded, rendered, index, }) => {
            if (framesRendered.length === 0) {
                throw new Error('Expected chunks to be set before frames are set');
            }
            if (framesEncoded.length === 0) {
                throw new Error('Expected chunks to be set before frames are set');
            }
            framesRendered[index] = rendered;
            framesEncoded[index] = encoded;
            const totalFramesEncoded = framesEncoded.reduce((a, b) => a + b, 0);
            const totalFramesRendered = framesRendered.reduce((a, b) => a + b, 0);
            if (renderProgress.framesEncoded === 0 && totalFramesEncoded > 0) {
                encodeStartTime = Date.now();
            }
            if (renderProgress.framesRendered === 0 && totalFramesRendered > 0) {
                renderFramesStartTime = Date.now();
            }
            if (renderProgress.timeToRenderFrames === null) {
                const frameCount = renderProgress.renderMetadata &&
                    renderProgress.renderMetadata.type === 'video'
                    ? renderer_1.RenderInternals.getFramesToRender(renderProgress.renderMetadata.frameRange, renderProgress.renderMetadata.everyNthFrame).length
                    : null;
                if (frameCount === totalFramesRendered) {
                    const timeToRenderFrames = Date.now() - (renderFramesStartTime !== null && renderFramesStartTime !== void 0 ? renderFramesStartTime : Date.now());
                    renderProgress.timeToRenderFrames = timeToRenderFrames;
                }
            }
            renderProgress.framesRendered = totalFramesRendered;
            renderProgress.framesEncoded = totalFramesEncoded;
            upload();
        },
        addChunkCompleted: (chunkIndex, start, rendered) => {
            var _a;
            renderProgress.chunks.push(chunkIndex);
            if (renderProgress.chunks.length ===
                ((_a = renderProgress.renderMetadata) === null || _a === void 0 ? void 0 : _a.totalChunks)) {
                const timeToEncode = Date.now() - (encodeStartTime !== null && encodeStartTime !== void 0 ? encodeStartTime : Date.now());
                renderProgress.timeToEncode = timeToEncode;
            }
            renderProgress.timings.push({
                chunk: chunkIndex,
                start,
                rendered,
            });
            upload();
        },
        setCombinedFrames: (frames) => {
            renderProgress.combinedFrames = frames;
            upload();
        },
        setTimeToCombine: (timeToCombine) => {
            renderProgress.timeToCombine = timeToCombine;
            upload();
        },
        setLambdaInvoked(chunk) {
            if (lambdasInvoked.length === 0) {
                throw new Error('Expected chunks to be set before lambdas are set');
            }
            lambdasInvoked[chunk] = true;
            renderProgress.lambdasInvoked = lambdasInvoked.reduce((a, b) => a + Number(b), 0);
            upload();
        },
        setPostRenderData(postRenderData) {
            renderProgress.postRenderData = postRenderData;
            upload();
        },
        setRenderMetadata: (renderMetadata) => {
            renderProgress.renderMetadata = renderMetadata;
            upload();
        },
        addErrorWithoutUpload: (errorInfo) => {
            renderProgress.errors.push(errorInfo);
        },
        setExpectedChunks: (expectedChunks) => {
            framesRendered = new Array(expectedChunks).fill(0);
            framesEncoded = new Array(expectedChunks).fill(0);
            lambdasInvoked = new Array(expectedChunks).fill(false);
        },
        setCompositionValidated(timestamp) {
            renderProgress.compositionValidated = timestamp;
            upload();
        },
        setServeUrlOpened(timestamp) {
            renderProgress.serveUrlOpened = timestamp;
            upload();
        },
        addRetry(retry) {
            renderProgress.retries.push(retry);
            upload();
        },
        addReceivedArtifact(asset) {
            renderProgress.receivedArtifact.push(asset);
            upload();
        },
        getReceivedArtifacts() {
            return renderProgress.receivedArtifact;
        },
        get: () => renderProgress,
    };
};
exports.makeOverallRenderProgress = makeOverallRenderProgress;
