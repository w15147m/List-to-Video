"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBrowserInstanceImplementation = exports.forgetBrowserEventLoopImplementation = void 0;
const renderer_1 = require("@remotion/renderer");
const serverless_client_1 = require("@remotion/serverless-client");
const makeConfigurationString = (options, logLevel) => {
    var _a, _b, _c;
    return [
        `web-security-${Boolean(options.disableWebSecurity)}`,
        `multi-process-${Boolean(options.enableMultiProcessOnLinux)}`,
        `ignore-certificate-errors-${Boolean(options.ignoreCertificateErrors)}`,
        `log-level-${logLevel}`,
        `gl-${(_a = options.gl) !== null && _a !== void 0 ? _a : null}`,
        `userAgent-${(_b = options.userAgent) !== null && _b !== void 0 ? _b : null}`,
        `headless-${(_c = options.headless) !== null && _c !== void 0 ? _c : false}`,
    ].join('/');
};
let _browserInstance;
let launching = false;
const waitForLaunched = () => {
    return new Promise((resolve, reject) => {
        const check = () => setTimeout(() => {
            if (launching) {
                check();
            }
            else {
                resolve();
            }
        }, 16);
        setTimeout(() => reject(new Error('Timeout launching browser')), 5000);
        check();
    });
};
const forgetBrowserEventLoopImplementation = ({ logLevel, launchedBrowser, }) => {
    renderer_1.RenderInternals.Log.info({ indent: false, logLevel }, 'Keeping browser open for next invocation');
    launchedBrowser.instance.runner.forgetEventLoop();
    launchedBrowser.instance.runner.deleteBrowserCaches();
};
exports.forgetBrowserEventLoopImplementation = forgetBrowserEventLoopImplementation;
const getBrowserInstanceImplementation = async ({ logLevel, indent, chromiumOptions, providerSpecifics, insideFunctionSpecifics, }) => {
    var _a;
    const actualChromiumOptions = {
        ...chromiumOptions,
        // Override the `null` value, which might come from CLI with swANGLE
        gl: (_a = chromiumOptions.gl) !== null && _a !== void 0 ? _a : 'swangle',
        enableMultiProcessOnLinux: false,
    };
    const configurationString = makeConfigurationString(actualChromiumOptions, logLevel);
    renderer_1.RenderInternals.Log.info({ indent: false, logLevel }, `Rendering with Remotion v${serverless_client_1.VERSION}.`);
    if (launching) {
        renderer_1.RenderInternals.Log.info({ indent: false, logLevel }, 'Already waiting for browser launch...');
        await waitForLaunched();
        if (!_browserInstance) {
            throw new Error('expected to launch');
        }
    }
    if (!_browserInstance) {
        renderer_1.RenderInternals.Log.info({ indent: false, logLevel }, 'Cold function, launching new browser instance');
        launching = true;
        const execPath = providerSpecifics.getChromiumPath();
        const instance = await renderer_1.RenderInternals.internalOpenBrowser({
            browser: 'chrome',
            browserExecutable: execPath,
            chromiumOptions: actualChromiumOptions,
            forceDeviceScaleFactor: undefined,
            indent: false,
            viewport: null,
            logLevel,
            onBrowserDownload: () => {
                throw new Error('Should not download a browser in serverless');
            },
            chromeMode: 'headless-shell',
        });
        instance.on('disconnected', () => {
            var _a;
            renderer_1.RenderInternals.Log.info({ indent: false, logLevel }, 'Browser disconnected or crashed.');
            insideFunctionSpecifics.forgetBrowserEventLoop({
                logLevel,
                launchedBrowser: _browserInstance,
            });
            (_a = _browserInstance === null || _browserInstance === void 0 ? void 0 : _browserInstance.instance) === null || _a === void 0 ? void 0 : _a.close({ silent: true }).catch((err) => {
                renderer_1.RenderInternals.Log.info({ indent: false, logLevel }, 'Could not close browser instance', err);
            });
            _browserInstance = null;
        });
        _browserInstance = {
            instance,
            configurationString,
        };
        launching = false;
        return _browserInstance;
    }
    if (_browserInstance.configurationString !== configurationString) {
        renderer_1.RenderInternals.Log.info({ indent: false, logLevel }, 'Warm function, but Browser configuration changed. Killing old browser instance.');
        _browserInstance.instance.runner.rememberEventLoop();
        await _browserInstance.instance.close({ silent: true });
        _browserInstance = null;
        return insideFunctionSpecifics.getBrowserInstance({
            logLevel,
            indent,
            chromiumOptions,
            providerSpecifics,
            insideFunctionSpecifics,
        });
    }
    renderer_1.RenderInternals.Log.info({ indent: false, logLevel }, 'Warm function, reusing browser instance');
    _browserInstance.instance.runner.rememberEventLoop();
    return _browserInstance;
};
exports.getBrowserInstanceImplementation = getBrowserInstanceImplementation;
