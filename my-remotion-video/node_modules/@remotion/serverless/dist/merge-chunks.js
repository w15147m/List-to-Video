"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeChunksAndFinishRender = void 0;
const serverless_client_1 = require("@remotion/serverless-client");
const fs_1 = __importDefault(require("fs"));
const cleanup_props_1 = require("./cleanup-props");
const concat_videos_1 = require("./concat-videos");
const create_post_render_data_1 = require("./create-post-render-data");
const mergeChunksAndFinishRender = async (options) => {
    const onProgress = ({ frames: framesEncoded }) => {
        options.overallProgress.setCombinedFrames(framesEncoded);
    };
    const encodingStart = Date.now();
    if (options.renderMetadata.type === 'still') {
        throw new Error('Cannot merge stills');
    }
    if (options.files.length === 0) {
        throw new Error('No files to merge');
    }
    const { outfile, cleanupChunksProm } = await (0, concat_videos_1.concatVideos)({
        onProgress,
        codec: options.codec,
        fps: options.fps,
        numberOfGifLoops: options.numberOfGifLoops,
        files: options.files,
        outdir: options.outdir,
        audioCodec: options.audioCodec,
        audioBitrate: options.audioBitrate,
        logLevel: options.logLevel,
        framesPerLambda: options.framesPerLambda,
        binariesDirectory: options.binariesDirectory,
        cancelSignal: undefined,
        preferLossless: options.preferLossless,
        metadata: options.renderMetadata.metadata,
        insideFunctionSpecifics: options.insideFunctionSpecifics,
        compositionDurationInFrames: options.numberOfFrames,
        everyNthFrame: options.everyNthFrame,
        frameRange: options.frameRange,
    });
    const encodingStop = Date.now();
    options.overallProgress.setTimeToCombine(encodingStop - encodingStart);
    const outputSize = fs_1.default.statSync(outfile).size;
    const writeToBucket = options.insideFunctionSpecifics.timer(`Writing to bucket (${outputSize} bytes)`, options.logLevel);
    await options.providerSpecifics.writeFile({
        bucketName: options.renderBucketName,
        key: options.key,
        body: fs_1.default.createReadStream(outfile),
        region: options.insideFunctionSpecifics.getCurrentRegionInFunction(),
        privacy: options.privacy,
        expectedBucketOwner: options.expectedBucketOwner,
        downloadBehavior: options.downloadBehavior,
        customCredentials: options.customCredentials,
        forcePathStyle: options.forcePathStyle,
        storageClass: options.storageClass,
        requestHandler: options.requestHandler,
    });
    writeToBucket.end();
    const errorExplanations = (0, serverless_client_1.inspectErrors)({
        errors: options.overallProgress.get().errors,
    });
    const cleanupProm = (0, cleanup_props_1.cleanupProps)({
        inputProps: options.inputProps,
        serializedResolvedProps: options.serializedResolvedProps,
        providerSpecifics: options.providerSpecifics,
        forcePathStyle: options.forcePathStyle,
        insideFunctionSpecifics: options.insideFunctionSpecifics,
    });
    const { url: outputUrl } = options.providerSpecifics.getOutputUrl({
        bucketName: options.renderBucketName,
        currentRegion: options.insideFunctionSpecifics.getCurrentRegionInFunction(),
        customCredentials: options.customCredentials,
        renderMetadata: options.renderMetadata,
    });
    const postRenderData = (0, create_post_render_data_1.createPostRenderData)({
        region: options.insideFunctionSpecifics.getCurrentRegionInFunction(),
        memorySizeInMb: options.insideFunctionSpecifics.getCurrentMemorySizeInMb(),
        renderMetadata: options.renderMetadata,
        errorExplanations,
        timeToDelete: (await cleanupProm).reduce((a, b) => Math.max(a, b), 0),
        outputFile: {
            url: outputUrl,
        },
        outputSize,
        timeToCombine: encodingStop - encodingStart,
        overallProgress: options.overallProgress.get(),
        timeToFinish: Date.now() - options.startTime,
        providerSpecifics: options.providerSpecifics,
    });
    options.overallProgress.setPostRenderData(postRenderData);
    fs_1.default.unlinkSync(outfile);
    await cleanupChunksProm;
    return postRenderData;
};
exports.mergeChunksAndFinishRender = mergeChunksAndFinishRender;
