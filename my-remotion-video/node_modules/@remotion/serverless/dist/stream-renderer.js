"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.streamRendererFunctionWithRetry = void 0;
const renderer_1 = require("@remotion/renderer");
const serverless_client_1 = require("@remotion/serverless-client");
const fs_1 = require("fs");
const path_1 = require("path");
const streamRenderer = ({ payload, functionName, outdir, overallProgress, files, logLevel, onArtifact, providerSpecifics, insideFunctionSpecifics, requestHandler, }) => {
    if (payload.type !== serverless_client_1.ServerlessRoutines.renderer) {
        throw new Error('Expected renderer type');
    }
    return new Promise((resolve) => {
        const receivedStreamingPayload = ({ message }) => {
            if (message.type === 'lambda-invoked') {
                overallProgress.setLambdaInvoked(payload.chunk);
                return;
            }
            if (message.type === 'frames-rendered') {
                overallProgress.setFrames({
                    index: payload.chunk,
                    encoded: message.payload.encoded,
                    rendered: message.payload.rendered,
                });
                return;
            }
            if (message.type === 'video-chunk-rendered') {
                const filename = (0, path_1.join)(outdir, `chunk:${String(payload.chunk).padStart(8, '0')}:video`);
                (0, fs_1.writeFileSync)(filename, new Uint8Array(message.payload));
                files.push(filename);
                renderer_1.RenderInternals.Log.verbose({ indent: false, logLevel }, `Received video chunk for chunk ${payload.chunk}`);
                return;
            }
            if (message.type === 'audio-chunk-rendered') {
                const filename = (0, path_1.join)(outdir, `chunk:${String(payload.chunk).padStart(8, '0')}:audio`);
                (0, fs_1.writeFileSync)(filename, new Uint8Array(message.payload));
                renderer_1.RenderInternals.Log.verbose({ indent: false, logLevel }, `Received audio chunk for chunk ${payload.chunk}`);
                files.push(filename);
                return;
            }
            if (message.type === 'chunk-complete') {
                renderer_1.RenderInternals.Log.verbose({ indent: false, logLevel }, `Finished chunk ${payload.chunk}`);
                overallProgress.addChunkCompleted(payload.chunk, message.payload.start, message.payload.rendered);
                return;
            }
            if (message.type === 'artifact-emitted') {
                const artifact = (0, serverless_client_1.deserializeArtifact)(message.payload.artifact);
                renderer_1.RenderInternals.Log.info({ indent: false, logLevel }, `Received artifact on frame ${message.payload.artifact.frame}:`, artifact.filename, artifact.content.length + 'bytes.');
                const { alreadyExisted } = onArtifact(artifact);
                if (alreadyExisted) {
                    return resolve({
                        type: 'error',
                        error: `Chunk ${payload.chunk} emitted an asset filename ${message.payload.artifact.filename} at frame ${message.payload.artifact.frame} but there is already another artifact with the same name. https://remotion.dev/docs/artifacts`,
                        shouldRetry: false,
                    });
                }
                return;
            }
            if (message.type === 'error-occurred') {
                overallProgress.addErrorWithoutUpload(message.payload.errorInfo);
                overallProgress.setFrames({
                    encoded: 0,
                    index: payload.chunk,
                    rendered: 0,
                });
                renderer_1.RenderInternals.Log.error({
                    indent: false,
                    logLevel,
                }, `Renderer function of chunk ${payload.chunk} failed with error: ${message.payload.error}`);
                renderer_1.RenderInternals.Log.error({
                    indent: false,
                    logLevel,
                }, `Will retry chunk = ${message.payload.shouldRetry}`);
                resolve({
                    type: 'error',
                    error: message.payload.error,
                    shouldRetry: message.payload.shouldRetry,
                });
                return;
            }
            throw new Error(`Unknown message type ${message.type}`);
        };
        providerSpecifics
            .callFunctionStreaming({
            functionName,
            payload,
            retriesRemaining: 1,
            region: insideFunctionSpecifics.getCurrentRegionInFunction(),
            timeoutInTest: 12000,
            type: serverless_client_1.ServerlessRoutines.renderer,
            receivedStreamingPayload,
            requestHandler,
        })
            .then(() => {
            resolve({
                type: 'success',
            });
        })
            .catch((err) => {
            var _a, _b;
            const shouldRetry = ((_a = err.stack) === null || _a === void 0 ? void 0 : _a.includes('Error: aborted')) ||
                ((_b = err.stack) === null || _b === void 0 ? void 0 : _b.includes('ETIMEDOUT')) ||
                false;
            resolve({
                type: 'error',
                error: err.stack,
                shouldRetry,
            });
        });
    });
};
const streamRendererFunctionWithRetry = async ({ payload, files, functionName, outdir, overallProgress, logLevel, onArtifact, providerSpecifics, insideFunctionSpecifics, requestHandler, }) => {
    if (payload.type !== serverless_client_1.ServerlessRoutines.renderer) {
        throw new Error('Expected renderer type');
    }
    const result = await streamRenderer({
        files,
        functionName,
        outdir,
        overallProgress,
        payload,
        logLevel,
        onArtifact,
        providerSpecifics,
        insideFunctionSpecifics,
        requestHandler,
    });
    if (result.type === 'error') {
        if (!result.shouldRetry) {
            throw new Error(result.error);
        }
        overallProgress.addRetry({
            attempt: payload.attempt + 1,
            time: Date.now(),
            chunk: payload.chunk,
        });
        return (0, exports.streamRendererFunctionWithRetry)({
            files,
            functionName,
            outdir,
            overallProgress,
            payload: {
                ...payload,
                attempt: payload.attempt + 1,
                retriesLeft: payload.retriesLeft - 1,
            },
            logLevel,
            onArtifact,
            providerSpecifics,
            insideFunctionSpecifics,
            requestHandler,
        });
    }
};
exports.streamRendererFunctionWithRetry = streamRendererFunctionWithRetry;
