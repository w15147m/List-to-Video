// src/render-still-on-web.tsx
import ReactDOM from "react-dom/client";
import { Internals } from "remotion";

// src/compose.ts
var compose = ({
  composables,
  width,
  height
}) => {
  const canvas = new OffscreenCanvas(width, height);
  const context = canvas.getContext("2d");
  if (!context) {
    throw new Error("Could not get context");
  }
  for (const composable of composables) {
    context.drawImage(composable, 0, 0);
  }
  return canvas;
};

// src/find-canvas-elements.ts
var findCanvasElements = (element) => {
  const canvasElements = element.querySelectorAll("canvas");
  const composables = [];
  Array.from(canvasElements).forEach((canvasElement) => {
    const canvas = canvasElement;
    composables.push(canvas);
  });
  return composables;
};

// src/wait-for-ready.ts
var waitForReady = (timeoutInMilliseconds) => {
  const { promise, resolve, reject } = Promise.withResolvers();
  const start = Date.now();
  const interval = setInterval(() => {
    if (window.remotion_renderReady === true) {
      resolve(true);
      clearInterval(interval);
      return;
    }
    if (window.remotion_cancelledError !== undefined) {
      reject(window.remotion_cancelledError);
      clearInterval(interval);
      return;
    }
    if (Date.now() - start > timeoutInMilliseconds + 3000) {
      reject(new Error(Object.values(window.remotion_delayRenderTimeouts).map((d) => d.label).join(", ")));
      clearInterval(interval);
    }
  }, 50);
  return promise;
};

// src/render-still-on-web.tsx
import { jsx } from "react/jsx-runtime";
var renderStillOnWeb = async ({
  Component,
  width,
  height,
  fps,
  durationInFrames,
  frame
}) => {
  const div = document.createElement("div");
  div.style.display = "flex";
  div.style.backgroundColor = "transparent";
  div.style.position = "absolute";
  div.style.width = `${width}px`;
  div.style.height = `${height}px`;
  document.body.appendChild(div);
  const delayRenderTimeoutInMilliseconds = 1e4;
  if (!ReactDOM.createRoot) {
    throw new Error("@remotion/web-renderer requires React 18 or higher");
  }
  const compositionManagerContext = {
    currentCompositionMetadata: {
      durationInFrames,
      fps,
      height,
      width,
      props: {},
      defaultCodec: null,
      defaultOutName: null,
      defaultVideoImageFormat: null,
      defaultPixelFormat: null
    },
    folders: [],
    compositions: [
      {
        id: "markup",
        component: Component,
        nonce: 0,
        defaultProps: undefined,
        folderName: null,
        parentFolderName: null,
        schema: null,
        calculateMetadata: null,
        durationInFrames,
        fps,
        height,
        width
      }
    ],
    canvasContent: {
      type: "composition",
      compositionId: "markup"
    }
  };
  const root = ReactDOM.createRoot(div);
  root.render(/* @__PURE__ */ jsx(Internals.RemotionEnvironmentContext, {
    value: {
      isStudio: false,
      isRendering: true,
      isPlayer: false,
      isReadOnlyStudio: false,
      isClientSideRendering: true
    },
    children: /* @__PURE__ */ jsx(Internals.RemotionRoot, {
      audioEnabled: true,
      videoEnabled: true,
      logLevel: "info",
      numberOfAudioTags: 0,
      onlyRenderComposition: null,
      currentCompositionMetadata: {
        props: {},
        durationInFrames,
        fps,
        height,
        width,
        defaultCodec: null,
        defaultOutName: null,
        defaultVideoImageFormat: null,
        defaultPixelFormat: null
      },
      audioLatencyHint: "interactive",
      children: /* @__PURE__ */ jsx(Internals.CanUseRemotionHooks, {
        value: true,
        children: /* @__PURE__ */ jsx(Internals.CompositionManager.Provider, {
          value: compositionManagerContext,
          children: /* @__PURE__ */ jsx(Component, {})
        })
      })
    })
  }));
  window.remotion_setFrame(frame, "markup", frame);
  await waitForReady(delayRenderTimeoutInMilliseconds);
  const canvasElements = findCanvasElements(div);
  const composed = compose({
    composables: canvasElements,
    width,
    height
  });
  const imageData = await composed.convertToBlob({
    type: "image/png"
  });
  const blob = new Blob([imageData], { type: "image/png" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "composed.png";
  a.click();
  URL.revokeObjectURL(url);
  root.unmount();
  div.remove();
};
export {
  renderStillOnWeb
};
