"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setLiveEventsListener = exports.waitForLiveEventsListener = exports.makeLiveEventsRouter = void 0;
const server_ready_1 = require("../server-ready");
const file_existence_watchers_1 = require("./file-existence-watchers");
const serializeMessage = (message) => {
    return `data: ${JSON.stringify(message)}\n\n`;
};
let printPortMessageTimeout = null;
const makeLiveEventsRouter = (logLevel) => {
    let clients = [];
    const router = (request, response) => {
        const headers = {
            'content-type': 'text/event-stream;charset=utf-8',
            connection: 'keep-alive',
            'cache-control': 'no-cache',
        };
        response.writeHead(200, headers);
        response.write('\n');
        if (request.method === 'OPTIONS') {
            response.end();
            return Promise.resolve();
        }
        const clientId = String(Math.random());
        response.write(serializeMessage({ type: 'init', clientId }));
        const newClient = {
            id: clientId,
            response,
        };
        clients.push(newClient);
        if (printPortMessageTimeout) {
            clearTimeout(printPortMessageTimeout);
        }
        request.on('close', () => {
            (0, file_existence_watchers_1.unsubscribeClientFileExistenceWatchers)(clientId);
            clients = clients.filter((client) => client.id !== clientId);
            // If all clients disconnected, print a comment so user can easily restart it.
            if (clients.length === 0) {
                if (printPortMessageTimeout) {
                    clearTimeout(printPortMessageTimeout);
                }
                printPortMessageTimeout = setTimeout(() => {
                    (0, server_ready_1.printServerReadyComment)('To restart', logLevel);
                }, 2500);
            }
        });
        return Promise.resolve();
    };
    const sendEventToClient = (event) => {
        clients.forEach((client) => {
            client.response.write(serializeMessage(event));
        });
    };
    return {
        sendEventToClient,
        router,
        closeConnections: () => {
            return Promise.all(clients.map((client) => {
                return new Promise((resolve) => {
                    client.response.end(() => {
                        resolve();
                    });
                });
            })).then(() => undefined);
        },
    };
};
exports.makeLiveEventsRouter = makeLiveEventsRouter;
let liveEventsListener = null;
const waiters = [];
const waitForLiveEventsListener = () => {
    if (liveEventsListener) {
        return Promise.resolve(liveEventsListener);
    }
    return new Promise((resolve) => {
        waiters.push((list) => {
            resolve(list);
        });
    });
};
exports.waitForLiveEventsListener = waitForLiveEventsListener;
const setLiveEventsListener = (listener) => {
    liveEventsListener = listener;
    waiters.forEach((w) => w(listener));
    return () => {
        liveEventsListener = null;
    };
};
exports.setLiveEventsListener = setLiveEventsListener;
