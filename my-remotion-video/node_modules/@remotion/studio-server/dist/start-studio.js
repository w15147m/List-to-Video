"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startStudio = void 0;
const renderer_1 = require("@remotion/renderer");
const node_crypto_1 = __importDefault(require("node:crypto"));
const node_fs_1 = require("node:fs");
const node_path_1 = __importDefault(require("node:path"));
const better_opn_1 = require("./better-opn");
const get_network_address_1 = require("./get-network-address");
const close_and_restart_1 = require("./preview-server/close-and-restart");
const get_absolute_public_dir_1 = require("./preview-server/get-absolute-public-dir");
const live_events_1 = require("./preview-server/live-events");
const public_folder_1 = require("./preview-server/public-folder");
const start_server_1 = require("./preview-server/start-server");
const server_ready_1 = require("./server-ready");
const watch_root_file_1 = require("./watch-root-file");
const getShouldOpenBrowser = ({ configValueShouldOpenBrowser, parsedCliOpen, }) => {
    var _a;
    if (parsedCliOpen === false) {
        return {
            shouldOpenBrowser: false,
            reasonForBrowserDecision: '--no-open specified',
        };
    }
    if (((_a = process.env.BROWSER) !== null && _a !== void 0 ? _a : '').toLowerCase() === 'none') {
        return {
            shouldOpenBrowser: false,
            reasonForBrowserDecision: 'env BROWSER=none was set',
        };
    }
    if (configValueShouldOpenBrowser === false) {
        return { shouldOpenBrowser: false, reasonForBrowserDecision: 'Config file' };
    }
    return { shouldOpenBrowser: true, reasonForBrowserDecision: 'default' };
};
const startStudio = async ({ browserArgs, browserFlag, configValueShouldOpenBrowser, fullEntryPath, logLevel, getCurrentInputProps, getEnvVariables, desiredPort, maxTimelineTracks, remotionRoot, keyboardShortcutsEnabled, relativePublicDir, webpackOverride, poll, getRenderDefaults, getRenderQueue, numberOfAudioTags, queueMethods, parsedCliOpen, previewEntry, gitSource, bufferStateDelayInMilliseconds, binariesDirectory, forceIPv4, audioLatencyHint, enableCrossSiteIsolation, }) => {
    try {
        if (typeof Bun === 'undefined') {
            process.title = 'node (npx remotion studio)';
        }
        else if (typeof Deno === 'undefined') {
            process.title = 'deno (npx remotiond studio)';
        }
        else {
            process.title = `bun (bunx remotionb studio)`;
        }
    }
    catch (_a) { }
    (0, watch_root_file_1.watchRootFile)(remotionRoot, previewEntry);
    const publicDir = (0, get_absolute_public_dir_1.getAbsolutePublicDir)({
        relativePublicDir,
        remotionRoot,
    });
    const hash = node_crypto_1.default.randomBytes(6).toString('hex');
    const outputHashPrefix = '/outputs-';
    const outputHash = `${outputHashPrefix}${hash}`;
    const staticHashPrefix = '/static-';
    const staticHash = `${staticHashPrefix}${hash}`;
    (0, public_folder_1.initPublicFolderWatch)({
        publicDir,
        remotionRoot,
        onUpdate: () => {
            (0, live_events_1.waitForLiveEventsListener)().then((listener) => {
                const files = (0, public_folder_1.getFiles)();
                listener.sendEventToClient({
                    type: 'new-public-folder',
                    files,
                    folderExists: files.length > 0
                        ? publicDir
                        : (0, node_fs_1.existsSync)(publicDir)
                            ? publicDir
                            : null,
                });
            });
        },
        staticHash,
    });
    const { port, liveEventsServer, close } = await (0, start_server_1.startServer)({
        entry: node_path_1.default.resolve(previewEntry),
        userDefinedComponent: fullEntryPath,
        getCurrentInputProps,
        getEnvVariables,
        port: desiredPort,
        maxTimelineTracks,
        remotionRoot,
        keyboardShortcutsEnabled,
        publicDir,
        webpackOverride,
        poll,
        staticHash,
        staticHashPrefix,
        outputHash,
        outputHashPrefix,
        logLevel,
        getRenderDefaults,
        getRenderQueue,
        numberOfAudioTags,
        queueMethods,
        gitSource,
        bufferStateDelayInMilliseconds,
        binariesDirectory,
        forceIPv4,
        audioLatencyHint,
        enableCrossSiteIsolation,
    });
    const cleanupLiveEventsListener = (0, live_events_1.setLiveEventsListener)(liveEventsServer);
    const networkAddress = (0, get_network_address_1.getNetworkAddress)();
    if (networkAddress) {
        (0, server_ready_1.setServerReadyComment)(`Local: ${renderer_1.RenderInternals.chalk.underline(`http://localhost:${port}`)}, Network: ${renderer_1.RenderInternals.chalk.underline(`http://${networkAddress}:${port}`)}`);
    }
    else {
        (0, server_ready_1.setServerReadyComment)(`http://localhost:${port}`);
    }
    (0, server_ready_1.printServerReadyComment)('Server ready', logLevel);
    const { reasonForBrowserDecision, shouldOpenBrowser } = getShouldOpenBrowser({
        configValueShouldOpenBrowser,
        parsedCliOpen,
    });
    if (shouldOpenBrowser) {
        await (0, better_opn_1.openBrowser)({
            url: `http://localhost:${port}`,
            browserArgs,
            browserFlag,
        });
    }
    else {
        renderer_1.RenderInternals.Log.verbose({ indent: false, logLevel }, `Not opening browser, reason: ${reasonForBrowserDecision}`);
    }
    await (0, close_and_restart_1.noOpUntilRestart)();
    renderer_1.RenderInternals.Log.info({ indent: false, logLevel }, 'Closing server to restart...');
    await liveEventsServer.closeConnections();
    cleanupLiveEventsListener();
    await close();
    renderer_1.RenderInternals.Log.info({ indent: false, logLevel }, renderer_1.RenderInternals.chalk.blue('Restarting server...'));
};
exports.startStudio = startStudio;
