"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bundleCommand = void 0;
const bundler_1 = require("@remotion/bundler");
const client_1 = require("@remotion/renderer/client");
const studio_server_1 = require("@remotion/studio-server");
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const chalk_1 = require("./chalk");
const entry_point_1 = require("./entry-point");
const get_github_repository_1 = require("./get-github-repository");
const log_1 = require("./log");
const parsed_cli_1 = require("./parsed-cli");
const setup_cache_1 = require("./setup-cache");
const should_use_non_overlaying_logger_1 = require("./should-use-non-overlaying-logger");
const yes_or_no_1 = require("./yes-or-no");
const { publicPathOption, publicDirOption, disableGitSourceOption, audioLatencyHintOption, } = client_1.BrowserSafeApis.options;
const bundleCommand = async (remotionRoot, args, logLevel) => {
    const { file, reason } = (0, entry_point_1.findEntryPoint)({
        args,
        remotionRoot,
        logLevel,
        allowDirectory: false,
    });
    const explicitlyPassed = args[0];
    if (explicitlyPassed &&
        reason !== 'argument passed' &&
        reason !== 'argument passed - found in cwd' &&
        reason !== 'argument passed - found in root') {
        log_1.Log.error({ indent: false, logLevel }, `Entry point was specified as ${chalk_1.chalk.bold(explicitlyPassed)}, but it was not found.`);
        process.exit(1);
    }
    const updatesDontOverwrite = (0, should_use_non_overlaying_logger_1.shouldUseNonOverlayingLogger)({ logLevel });
    if (!file) {
        log_1.Log.error({ indent: false, logLevel }, 'No entry point found.');
        log_1.Log.error({ indent: false, logLevel }, 'Pass another argument to the command specifying the entry point.');
        log_1.Log.error({ indent: false, logLevel }, 'See: https://www.remotion.dev/docs/terminology/entry-point');
        process.exit(1);
    }
    const publicPath = publicPathOption.getValue({ commandLine: parsed_cli_1.parsedCli }).value;
    const publicDir = publicDirOption.getValue({ commandLine: parsed_cli_1.parsedCli }).value;
    const disableGitSource = disableGitSourceOption.getValue({
        commandLine: parsed_cli_1.parsedCli,
    }).value;
    const audioLatencyHint = audioLatencyHintOption.getValue({
        commandLine: parsed_cli_1.parsedCli,
    }).value;
    const outputPath = parsed_cli_1.parsedCli['out-dir']
        ? path_1.default.resolve(process.cwd(), parsed_cli_1.parsedCli['out-dir'])
        : path_1.default.join(remotionRoot, 'build');
    const gitignoreFolder = bundler_1.BundlerInternals.findClosestFolderWithItem(outputPath, '.gitignore');
    const existed = (0, fs_1.existsSync)(outputPath);
    if (existed) {
        const existsIndexHtml = (0, fs_1.existsSync)(path_1.default.join(outputPath, 'index.html'));
        const isEmpty = (0, fs_1.readdirSync)(outputPath).length === 0;
        if (!existsIndexHtml && !isEmpty) {
            log_1.Log.error({ indent: false, logLevel }, `The folder at ${outputPath} already exists, and needs to be deleted before a new bundle can be created.`);
            log_1.Log.error({ indent: false, logLevel }, 'However, it does not look like the folder was created by `npx remotion bundle` (no index.html).');
            log_1.Log.error({ indent: false, logLevel }, 'Aborting to prevent accidental data loss.');
            process.exit(1);
        }
        (0, fs_1.rmSync)(outputPath, { recursive: true });
    }
    const gitSource = (0, get_github_repository_1.getGitSource)({ remotionRoot, disableGitSource, logLevel });
    const output = await (0, setup_cache_1.bundleOnCli)({
        fullPath: file,
        logLevel,
        onDirectoryCreated: () => { },
        indent: false,
        quietProgress: updatesDontOverwrite,
        publicDir,
        remotionRoot,
        onProgressCallback: ({ bundling, copying }) => {
            // Handle floating point inaccuracies
            if (bundling.progress < 0.99999) {
                if (updatesDontOverwrite) {
                    log_1.Log.info({ indent: false, logLevel }, `Bundling ${Math.round(bundling.progress * 100)}%`);
                }
            }
            if (copying.doneIn === null) {
                if (updatesDontOverwrite) {
                    return `Copying public dir ${studio_server_1.StudioServerInternals.formatBytes(copying.bytes)}`;
                }
            }
        },
        quietFlag: (0, parsed_cli_1.quietFlagProvided)(),
        outDir: outputPath,
        gitSource,
        bufferStateDelayInMilliseconds: null,
        maxTimelineTracks: null,
        publicPath,
        audioLatencyHint,
    });
    log_1.Log.info({ indent: false, logLevel }, chalk_1.chalk.blue(`${existed ? 'â—‹' : '+'} ${output}`));
    if (!gitignoreFolder) {
        return;
    }
    // Non-interactive terminal
    if (!process.stdout.isTTY) {
        return;
    }
    const gitignorePath = path_1.default.join(gitignoreFolder, '.gitignore');
    const gitIgnoreContents = (0, fs_1.readFileSync)(gitignorePath, 'utf-8');
    const relativePathToGitIgnore = path_1.default.relative(gitignoreFolder, outputPath);
    const isInGitIgnore = gitIgnoreContents
        .split('\n')
        .includes(relativePathToGitIgnore);
    if (isInGitIgnore) {
        return;
    }
    const answer = await (0, yes_or_no_1.yesOrNo)({
        defaultValue: true,
        question: `Recommended: Add ${chalk_1.chalk.bold(relativePathToGitIgnore)} to your ${chalk_1.chalk.bold('.gitignore')} file? (Y/n)`,
    });
    if (!answer) {
        return;
    }
    const newGitIgnoreContents = gitIgnoreContents + '\n' + relativePathToGitIgnore;
    (0, fs_1.writeFileSync)(gitignorePath, newGitIgnoreContents);
    log_1.Log.info({ indent: false, logLevel }, chalk_1.chalk.blue(`Added to .gitignore!`));
};
exports.bundleCommand = bundleCommand;
