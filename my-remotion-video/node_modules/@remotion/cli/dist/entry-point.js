"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findEntryPoint = void 0;
const renderer_1 = require("@remotion/renderer");
const node_fs_1 = require("node:fs");
const node_path_1 = __importDefault(require("node:path"));
const config_1 = require("./config");
const log_1 = require("./log");
const candidates = [
    node_path_1.default.join('src', 'index.ts'),
    node_path_1.default.join('src', 'index.tsx'),
    node_path_1.default.join('src', 'index.js'),
    node_path_1.default.join('src', 'index.mjs'),
    node_path_1.default.join('remotion', 'index.tsx'),
    node_path_1.default.join('remotion', 'index.ts'),
    node_path_1.default.join('remotion', 'index.js'),
    node_path_1.default.join('remotion', 'index.mjs'),
    node_path_1.default.join('src', 'remotion', 'index.tsx'),
    node_path_1.default.join('src', 'remotion', 'index.ts'),
    node_path_1.default.join('src', 'remotion', 'index.js'),
    node_path_1.default.join('src', 'remotion', 'index.mjs'),
];
const findCommonPath = (remotionRoot) => {
    return candidates.find((candidate) => (0, node_fs_1.existsSync)(node_path_1.default.resolve(remotionRoot, candidate)));
};
const findEntryPoint = ({ args, logLevel, remotionRoot, allowDirectory, }) => {
    const result = findEntryPointInner(args, remotionRoot, logLevel);
    if (result.file === null) {
        return result;
    }
    if (renderer_1.RenderInternals.isServeUrl(result.file)) {
        return result;
    }
    if (!(0, node_fs_1.existsSync)(result.file)) {
        throw new Error(`${result.file} was chosen as the entry point (reason = ${result.reason}) but it does not exist.`);
    }
    if (result.isDirectory && !allowDirectory) {
        throw new Error(`${result.file} was chosen as the entry point (reason = ${result.reason}) but it is a directory - it needs to be a file.`);
    }
    return result;
};
exports.findEntryPoint = findEntryPoint;
const isBundledCode = (p) => {
    return (0, node_fs_1.existsSync)(p) && (0, node_fs_1.existsSync)(node_path_1.default.join(p, 'index.html'));
};
const findEntryPointInner = (args, remotionRoot, logLevel) => {
    // 1st priority: Explicitly passed entry point
    let file = args[0] ? args[0].toString() : null;
    if (file) {
        log_1.Log.verbose({ indent: false, logLevel }, 'Checking if', file, 'is the entry file');
        const cwdResolution = node_path_1.default.resolve(process.cwd(), file);
        const remotionRootResolution = node_path_1.default.resolve(remotionRoot, file);
        // Checking if file was found in CWD
        if ((0, node_fs_1.existsSync)(cwdResolution)) {
            return {
                file: cwdResolution,
                remainingArgs: args.slice(1),
                reason: 'argument passed - found in cwd',
                isDirectory: isBundledCode(cwdResolution),
            };
        }
        // Checking if file was found in remotion root
        if ((0, node_fs_1.existsSync)(remotionRootResolution)) {
            return {
                file: remotionRootResolution,
                remainingArgs: args.slice(1),
                reason: 'argument passed - found in root',
                isDirectory: isBundledCode(remotionRootResolution),
            };
        }
        if (renderer_1.RenderInternals.isServeUrl(file)) {
            return {
                file,
                remainingArgs: args.slice(1),
                reason: 'argument passed',
                isDirectory: false,
            };
        }
    }
    // 2nd priority: Config file
    file = config_1.ConfigInternals.getEntryPoint();
    if (file) {
        log_1.Log.verbose({ indent: false, logLevel }, 'Entry point from config file is', file);
        return {
            file: node_path_1.default.resolve(remotionRoot, file),
            remainingArgs: args,
            reason: 'config file',
            isDirectory: isBundledCode(node_path_1.default.resolve(remotionRoot, file)),
        };
    }
    // 3rd priority: Common paths
    const found = findCommonPath(remotionRoot);
    if (found) {
        const absolutePath = node_path_1.default.resolve(remotionRoot, found);
        log_1.Log.verbose({ indent: false, logLevel }, 'Selected', absolutePath, 'as the entry point because file exists and is a common entry point and no entry point was explicitly selected');
        return {
            file: absolutePath,
            remainingArgs: args,
            reason: 'common paths',
            isDirectory: false,
        };
    }
    return {
        file: null,
        remainingArgs: args,
        reason: 'none found',
        isDirectory: false,
    };
};
