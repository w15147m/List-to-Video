"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bundleOnCli = exports.bundleOnCliOrTakeServeUrl = void 0;
const bundler_1 = require("@remotion/bundler");
const renderer_1 = require("@remotion/renderer");
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const config_1 = require("./config");
const log_1 = require("./log");
const progress_bar_1 = require("./progress-bar");
const should_use_non_overlaying_logger_1 = require("./should-use-non-overlaying-logger");
const bundleOnCliOrTakeServeUrl = async ({ fullPath, remotionRoot, publicDir, onProgress, indentOutput, logLevel, onDirectoryCreated, quietProgress, quietFlag, outDir, gitSource, bufferStateDelayInMilliseconds, maxTimelineTracks, publicPath, audioLatencyHint, }) => {
    const isServeUrl = renderer_1.RenderInternals.isServeUrl(fullPath);
    const isBundle = (0, fs_1.existsSync)(fullPath) && (0, fs_1.existsSync)(path_1.default.join(fullPath, 'index.html'));
    if (isServeUrl || isBundle) {
        onProgress({
            bundling: {
                doneIn: 0,
                progress: 1,
            },
            copying: {
                bytes: 0,
                doneIn: 0,
            },
        });
        return {
            urlOrBundle: fullPath,
            cleanup: () => Promise.resolve(undefined),
        };
    }
    const bundled = await (0, exports.bundleOnCli)({
        fullPath,
        remotionRoot,
        publicDir,
        onProgressCallback: onProgress,
        indent: indentOutput,
        logLevel,
        onDirectoryCreated,
        quietProgress,
        quietFlag,
        outDir,
        gitSource,
        bufferStateDelayInMilliseconds,
        maxTimelineTracks,
        publicPath,
        audioLatencyHint,
    });
    return {
        urlOrBundle: bundled,
        cleanup: () => renderer_1.RenderInternals.deleteDirectory(bundled),
    };
};
exports.bundleOnCliOrTakeServeUrl = bundleOnCliOrTakeServeUrl;
const bundleOnCli = async ({ fullPath, remotionRoot, publicDir, onProgressCallback, indent, logLevel, onDirectoryCreated, quietProgress, quietFlag, outDir, gitSource, maxTimelineTracks, bufferStateDelayInMilliseconds, publicPath, audioLatencyHint, }) => {
    var _a;
    const shouldCache = config_1.ConfigInternals.getWebpackCaching();
    const symlinkState = {
        symlinks: [],
    };
    const onProgress = (progress) => {
        bundlingState = {
            progress: progress / 100,
            doneIn: null,
        };
        updateProgress(false);
    };
    let copyingState = {
        bytes: 0,
        doneIn: null,
    };
    let copyStart = null;
    const updateProgress = (newline) => {
        bundlingProgress.update((0, progress_bar_1.makeBundlingAndCopyProgress)({
            bundling: bundlingState,
            copying: copyingState,
            symLinks: symlinkState,
        }), newline);
        onProgressCallback({
            bundling: bundlingState,
            copying: copyingState,
        });
    };
    const onPublicDirCopyProgress = (bytes) => {
        if (copyStart === null) {
            copyStart = Date.now();
        }
        copyingState = {
            bytes,
            doneIn: null,
        };
        updateProgress(false);
    };
    const onSymlinkDetected = (absPath) => {
        symlinkState.symlinks.push(absPath);
        updateProgress(false);
    };
    const options = {
        enableCaching: shouldCache,
        webpackOverride: (_a = config_1.ConfigInternals.getWebpackOverrideFn()) !== null && _a !== void 0 ? _a : ((f) => f),
        rootDir: remotionRoot,
        publicDir,
        onPublicDirCopyProgress,
        onSymlinkDetected,
        outDir: outDir !== null && outDir !== void 0 ? outDir : null,
        publicPath,
    };
    const [hash] = await bundler_1.BundlerInternals.getConfig({
        outDir: '',
        entryPoint: fullPath,
        onProgress,
        options,
        resolvedRemotionRoot: remotionRoot,
        bufferStateDelayInMilliseconds,
        maxTimelineTracks,
    });
    const cacheExistedBefore = bundler_1.BundlerInternals.cacheExists(remotionRoot, 'production', hash);
    if (cacheExistedBefore !== 'does-not-exist' && !shouldCache) {
        log_1.Log.info({ indent, logLevel }, 'üßπ Cache disabled but found. Deleting... ');
        await bundler_1.BundlerInternals.clearCache(remotionRoot, 'production');
    }
    if (cacheExistedBefore === 'other-exists' && shouldCache) {
        log_1.Log.info({ indent, logLevel }, 'üßπ Webpack config change detected. Clearing cache... ');
        await bundler_1.BundlerInternals.clearCache(remotionRoot, 'production');
    }
    const bundleStartTime = Date.now();
    const bundlingProgress = (0, progress_bar_1.createOverwriteableCliOutput)({
        quiet: quietProgress || quietFlag,
        cancelSignal: null,
        updatesDontOverwrite: (0, should_use_non_overlaying_logger_1.shouldUseNonOverlayingLogger)({ logLevel }),
        indent,
    });
    let bundlingState = {
        progress: 0,
        doneIn: null,
    };
    const bundled = await bundler_1.BundlerInternals.internalBundle({
        entryPoint: fullPath,
        onProgress: (progress) => {
            bundlingState = {
                progress: progress / 100,
                doneIn: null,
            };
            updateProgress(false);
        },
        onDirectoryCreated,
        gitSource,
        ...options,
        ignoreRegisterRootWarning: false,
        maxTimelineTracks,
        bufferStateDelayInMilliseconds,
        audioLatencyHint,
    });
    bundlingState = {
        progress: 1,
        doneIn: Date.now() - bundleStartTime,
    };
    log_1.Log.verbose({ logLevel, indent }, `Bundling done in ${bundlingState.doneIn}ms`);
    copyingState = {
        ...copyingState,
        doneIn: copyStart ? Date.now() - copyStart : 0,
    };
    log_1.Log.verbose({ logLevel, indent }, `Copying done in ${copyingState.doneIn}ms`);
    updateProgress(true);
    log_1.Log.verbose({ indent, logLevel }, 'Bundled under', bundled);
    const cacheExistedAfter = bundler_1.BundlerInternals.cacheExists(remotionRoot, 'production', hash) === 'exists';
    if (cacheExistedAfter) {
        if (cacheExistedBefore === 'does-not-exist' ||
            cacheExistedBefore === 'other-exists') {
            log_1.Log.info({ indent, logLevel }, '‚ö°Ô∏è Cached bundle. Subsequent renders will be faster.');
        }
    }
    return bundled;
};
exports.bundleOnCli = bundleOnCli;
