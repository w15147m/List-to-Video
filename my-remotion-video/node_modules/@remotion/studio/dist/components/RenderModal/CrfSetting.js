"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CrfSetting = exports.useCrfState = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const client_1 = require("@remotion/renderer/client");
const react_1 = require("react");
const NumberSetting_1 = require("./NumberSetting");
const getDefaultCrfState = () => {
    return client_1.BrowserSafeApis.validCodecs
        .map((c) => {
        return [c, client_1.BrowserSafeApis.getDefaultCrfForCodec(c)];
    })
        .reduce((acc, [codec, crf]) => {
        return {
            ...acc,
            [codec]: crf,
        };
    }, {});
};
const useCrfState = (codec) => {
    const [state, setState] = (0, react_1.useState)(() => getDefaultCrfState());
    const range = client_1.BrowserSafeApis.getValidCrfRanges(codec);
    const setCrf = (updater) => {
        setState((q) => {
            const val = q[codec];
            if (val === null) {
                throw new TypeError(`Got unexpected codec "${codec}"`);
            }
            return {
                ...q,
                [codec]: typeof updater === 'number' ? updater : updater(val),
            };
        });
    };
    return {
        crf: state[codec],
        setCrf,
        minCrf: range[0],
        maxCrf: range[1],
    };
};
exports.useCrfState = useCrfState;
const CrfSetting = ({ crf, setCrf, min, max, option }) => {
    return ((0, jsx_runtime_1.jsx)(NumberSetting_1.NumberSetting, { min: min, max: max, name: "CRF", onValueChanged: setCrf, value: crf, step: 1, hint: option }));
};
exports.CrfSetting = CrfSetting;
