"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProgress = void 0;
const pure_1 = require("@remotion/renderer/pure");
const calculate_chunk_times_1 = require("./calculate-chunk-times");
const estimate_price_from_bucket_1 = require("./estimate-price-from-bucket");
const expected_out_name_1 = require("./expected-out-name");
const format_costs_info_1 = require("./format-costs-info");
const get_overall_progress_1 = require("./get-overall-progress");
const get_overall_progress_from_storage_1 = require("./get-overall-progress-from-storage");
const inspect_error_1 = require("./inspect-error");
const make_timeout_error_1 = require("./make-timeout-error");
const render_has_audio_video_1 = require("./render-has-audio-video");
const truthy_1 = require("./truthy");
const getProgress = async ({ bucketName, renderId, expectedBucketOwner, region, memorySizeInMb, timeoutInMilliseconds, customCredentials, providerSpecifics, forcePathStyle, functionName, requestHandler, }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
    const overallProgress = await (0, get_overall_progress_from_storage_1.getOverallProgressFromStorage)({
        renderId,
        bucketName,
        expectedBucketOwner,
        region,
        providerSpecifics,
        forcePathStyle,
        requestHandler,
    });
    if (overallProgress.postRenderData) {
        if (!overallProgress.renderMetadata) {
            throw new Error('No render metadata found even though render is finished');
        }
        if (overallProgress.renderMetadata.type === 'still') {
            throw new Error("You don't need to call getRenderProgress() on a still render. Once you have obtained the `renderId`, the render is already done! ðŸ˜‰");
        }
        const outData = (0, expected_out_name_1.getExpectedOutName)({
            renderMetadata: overallProgress.renderMetadata,
            bucketName,
            customCredentials,
            bucketNamePrefix: providerSpecifics.getBucketPrefix(),
        });
        const totalFrameCount = pure_1.NoReactAPIs.getFramesToRender(overallProgress.renderMetadata.frameRange, overallProgress.renderMetadata.everyNthFrame).length;
        return {
            framesRendered: totalFrameCount,
            bucket: bucketName,
            renderSize: overallProgress.postRenderData.renderSize,
            chunks: overallProgress.renderMetadata.totalChunks,
            cleanup: {
                doneIn: overallProgress.postRenderData.timeToCleanUp,
                filesDeleted: overallProgress.postRenderData.filesCleanedUp,
                minFilesToDelete: overallProgress.postRenderData.filesCleanedUp,
            },
            costs: {
                accruedSoFar: overallProgress.postRenderData.cost.estimatedCost,
                displayCost: overallProgress.postRenderData.cost.estimatedDisplayCost,
                currency: overallProgress.postRenderData.cost.currency,
                disclaimer: overallProgress.postRenderData.cost.disclaimer,
            },
            currentTime: Date.now(),
            done: true,
            encodingStatus: {
                framesEncoded: totalFrameCount,
                combinedFrames: totalFrameCount,
                timeToCombine: overallProgress.postRenderData.timeToCombine,
            },
            errors: overallProgress.postRenderData.errors,
            fatalErrorEncountered: false,
            lambdasInvoked: overallProgress.renderMetadata.totalChunks,
            outputFile: overallProgress.postRenderData.outputFile,
            renderId,
            timeToFinish: overallProgress.postRenderData.timeToFinish,
            timeToFinishChunks: overallProgress.postRenderData.timeToRenderChunks,
            timeToRenderFrames: overallProgress.postRenderData.timeToRenderFrames,
            overallProgress: 1,
            retriesInfo: overallProgress.postRenderData.retriesInfo,
            outKey: outData.key,
            outBucket: outData.renderBucketName,
            mostExpensiveFrameRanges: (_a = overallProgress.postRenderData.mostExpensiveFrameRanges) !== null && _a !== void 0 ? _a : null,
            timeToEncode: overallProgress.postRenderData.timeToEncode,
            outputSizeInBytes: overallProgress.postRenderData.outputSize,
            type: 'success',
            estimatedBillingDurationInMilliseconds: overallProgress.postRenderData.estimatedBillingDurationInMilliseconds,
            timeToCombine: overallProgress.postRenderData.timeToCombine,
            combinedFrames: totalFrameCount,
            renderMetadata: overallProgress.renderMetadata,
            timeoutTimestamp: overallProgress.timeoutTimestamp,
            compositionValidated: overallProgress.compositionValidated,
            functionLaunched: overallProgress.functionLaunched,
            serveUrlOpened: overallProgress.serveUrlOpened,
            artifacts: overallProgress.receivedArtifact,
        };
    }
    const { renderMetadata } = overallProgress;
    const errorExplanations = (0, inspect_error_1.inspectErrors)({
        errors: overallProgress.errors,
    });
    const { hasAudio, hasVideo } = renderMetadata
        ? (0, render_has_audio_video_1.lambdaRenderHasAudioVideo)(renderMetadata)
        : { hasAudio: false, hasVideo: false };
    const chunkCount = (_b = overallProgress.chunks.length) !== null && _b !== void 0 ? _b : 0;
    const cleanup = {
        doneIn: null,
        minFilesToDelete: 0,
        filesDeleted: 0,
    };
    if (renderMetadata === null) {
        return {
            framesRendered: (_c = overallProgress.framesRendered) !== null && _c !== void 0 ? _c : 0,
            chunks: chunkCount,
            done: false,
            encodingStatus: {
                framesEncoded: overallProgress.framesEncoded,
                combinedFrames: overallProgress.combinedFrames,
                timeToCombine: overallProgress.timeToCombine,
            },
            timeToRenderFrames: overallProgress.timeToRenderFrames,
            costs: (0, format_costs_info_1.formatCostsInfo)(0),
            renderId,
            renderMetadata,
            bucket: bucketName,
            outputFile: null,
            timeToFinish: null,
            errors: errorExplanations,
            fatalErrorEncountered: errorExplanations.some((f) => f.isFatal && !f.willRetry),
            currentTime: Date.now(),
            renderSize: 0,
            lambdasInvoked: (_d = overallProgress.lambdasInvoked) !== null && _d !== void 0 ? _d : 0,
            cleanup,
            timeToFinishChunks: null,
            overallProgress: (0, get_overall_progress_1.getOverallProgress)({
                encoding: 0,
                invoking: 0,
                frames: 0,
                gotComposition: overallProgress.compositionValidated,
                visitedServeUrl: overallProgress.serveUrlOpened,
                invokedLambda: overallProgress.lambdasInvoked,
                combining: 0,
            }),
            retriesInfo: (_e = overallProgress.retries) !== null && _e !== void 0 ? _e : [],
            outKey: null,
            outBucket: null,
            mostExpensiveFrameRanges: null,
            timeToEncode: overallProgress.timeToEncode,
            outputSizeInBytes: null,
            estimatedBillingDurationInMilliseconds: null,
            combinedFrames: (_f = overallProgress.combinedFrames) !== null && _f !== void 0 ? _f : 0,
            timeToCombine: (_g = overallProgress.timeToCombine) !== null && _g !== void 0 ? _g : null,
            timeoutTimestamp: overallProgress.timeoutTimestamp,
            type: 'success',
            compositionValidated: overallProgress.compositionValidated,
            functionLaunched: overallProgress.functionLaunched,
            serveUrlOpened: overallProgress.serveUrlOpened,
            artifacts: overallProgress.receivedArtifact,
        };
    }
    const priceFromBucket = (0, estimate_price_from_bucket_1.estimatePriceFromMetadata)({
        renderMetadata,
        memorySizeInMb: (_j = (_h = providerSpecifics.parseFunctionName(renderMetadata.rendererFunctionName)) === null || _h === void 0 ? void 0 : _h.memorySizeInMb) !== null && _j !== void 0 ? _j : memorySizeInMb,
        functionsInvoked: (_k = renderMetadata.estimatedRenderLambdaInvokations) !== null && _k !== void 0 ? _k : 0,
        diskSizeInMb: providerSpecifics.getEphemeralStorageForPriceCalculation(),
        timings: (_l = overallProgress.timings) !== null && _l !== void 0 ? _l : [],
        region,
        providerSpecifics,
    });
    const chunkMultiplier = [hasAudio, hasVideo].filter(truthy_1.truthy).length;
    if (renderMetadata.type === 'still') {
        throw new Error("You don't need to call getRenderProgress() on a still render. Once you have obtained the `renderId`, the render is already done! ðŸ˜‰");
    }
    const allChunks = ((_m = overallProgress.chunks) !== null && _m !== void 0 ? _m : []).length / chunkMultiplier ===
        ((_o = renderMetadata.totalChunks) !== null && _o !== void 0 ? _o : Infinity);
    const frameCount = pure_1.NoReactAPIs.getFramesToRender(renderMetadata.frameRange, renderMetadata.everyNthFrame).length;
    const missingChunks = new Array(renderMetadata.totalChunks)
        .fill(true)
        .map((_, i) => i)
        .filter((index) => {
        var _a;
        return (typeof ((_a = overallProgress.chunks) !== null && _a !== void 0 ? _a : []).find((c) => c === index) ===
            'undefined');
    });
    // We add a 20 second buffer for it, since AWS timeshifts can be quite a lot. Once it's 20sec over the limit, we consider it timed out
    // 1. If we have missing chunks, we consider it timed out
    const isBeyondTimeoutAndMissingChunks = Date.now() > renderMetadata.startedDate + timeoutInMilliseconds + 20000 &&
        missingChunks &&
        missingChunks.length > 0;
    // 2. If we have no missing chunks, but the encoding is not done, even after the additional `merge` function has been spawned, we consider it timed out
    const isBeyondTimeoutAndHasStitchTimeout = Date.now() > renderMetadata.startedDate + timeoutInMilliseconds * 2 + 20000;
    const allErrors = [
        isBeyondTimeoutAndMissingChunks || isBeyondTimeoutAndHasStitchTimeout
            ? (0, make_timeout_error_1.makeTimeoutError)({
                timeoutInMilliseconds,
                renderMetadata,
                renderId,
                missingChunks: missingChunks !== null && missingChunks !== void 0 ? missingChunks : [],
                region,
                functionName,
                providerSpecifics,
            })
            : null,
        ...errorExplanations,
    ].filter(truthy_1.truthy);
    return {
        framesRendered: (_p = overallProgress.framesRendered) !== null && _p !== void 0 ? _p : 0,
        chunks: chunkCount,
        done: false,
        encodingStatus: {
            framesEncoded: overallProgress.framesEncoded,
            combinedFrames: overallProgress.combinedFrames,
            timeToCombine: overallProgress.timeToCombine,
        },
        timeToRenderFrames: overallProgress.timeToRenderFrames,
        costs: priceFromBucket
            ? (0, format_costs_info_1.formatCostsInfo)(priceFromBucket.accruedSoFar)
            : (0, format_costs_info_1.formatCostsInfo)(0),
        renderId,
        renderMetadata,
        bucket: bucketName,
        outputFile: null,
        timeToFinish: null,
        errors: allErrors,
        fatalErrorEncountered: allErrors.some((f) => f.isFatal && !f.willRetry),
        currentTime: Date.now(),
        renderSize: 0,
        lambdasInvoked: (_q = overallProgress.lambdasInvoked) !== null && _q !== void 0 ? _q : 0,
        cleanup,
        timeToFinishChunks: allChunks && overallProgress
            ? (0, calculate_chunk_times_1.calculateChunkTimes)({
                type: 'absolute-time',
                timings: overallProgress.timings,
            })
            : null,
        overallProgress: (0, get_overall_progress_1.getOverallProgress)({
            encoding: frameCount
                ? ((_r = overallProgress.framesEncoded) !== null && _r !== void 0 ? _r : 0) / frameCount
                : 0,
            invoking: ((_s = overallProgress.lambdasInvoked) !== null && _s !== void 0 ? _s : 0) /
                renderMetadata.estimatedRenderLambdaInvokations,
            frames: ((_t = overallProgress.framesRendered) !== null && _t !== void 0 ? _t : 0) / (frameCount !== null && frameCount !== void 0 ? frameCount : 1),
            gotComposition: overallProgress.compositionValidated,
            visitedServeUrl: overallProgress.serveUrlOpened,
            invokedLambda: overallProgress.lambdasInvoked,
            combining: overallProgress.combinedFrames / (frameCount !== null && frameCount !== void 0 ? frameCount : 1),
        }),
        retriesInfo: (_u = overallProgress.retries) !== null && _u !== void 0 ? _u : [],
        outKey: null,
        outBucket: null,
        mostExpensiveFrameRanges: null,
        timeToEncode: overallProgress.timeToEncode,
        outputSizeInBytes: null,
        estimatedBillingDurationInMilliseconds: priceFromBucket
            ? priceFromBucket.estimatedBillingDurationInMilliseconds
            : null,
        combinedFrames: (_v = overallProgress.combinedFrames) !== null && _v !== void 0 ? _v : 0,
        timeToCombine: (_w = overallProgress.timeToCombine) !== null && _w !== void 0 ? _w : null,
        timeoutTimestamp: overallProgress.timeoutTimestamp,
        type: 'success',
        compositionValidated: overallProgress.compositionValidated,
        functionLaunched: overallProgress.functionLaunched,
        serveUrlOpened: overallProgress.serveUrlOpened,
        artifacts: overallProgress.receivedArtifact,
    };
};
exports.getProgress = getProgress;
