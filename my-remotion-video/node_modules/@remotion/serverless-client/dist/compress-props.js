"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decompressInputProps = exports.compressInputProps = exports.getNeedsToUpload = exports.serializeOrThrow = void 0;
const no_react_1 = require("remotion/no-react");
const get_or_create_bucket_1 = require("./get-or-create-bucket");
const input_props_keys_1 = require("./input-props-keys");
const stream_to_string_1 = require("./stream-to-string");
const validate_webhook_1 = require("./validate-webhook");
const makeKey = (type, hash) => {
    if (type === 'input-props') {
        return (0, input_props_keys_1.inputPropsKey)(hash);
    }
    return (0, input_props_keys_1.resolvedPropsKey)(hash);
};
const serializeOrThrow = (inputProps, propsType) => {
    try {
        const payload = no_react_1.NoReactInternals.serializeJSONWithSpecialTypes({
            indent: undefined,
            staticBase: null,
            data: inputProps,
        });
        return payload.serializedString;
    }
    catch (_a) {
        throw new Error(`Error serializing ${propsType}. Check it has no circular references or reduce the size if the object is big.`);
    }
};
exports.serializeOrThrow = serializeOrThrow;
const getNeedsToUpload = ({ type, sizes, providerSpecifics, }) => {
    const MARGIN = 5000 + validate_webhook_1.MAX_WEBHOOK_CUSTOM_DATA_SIZE;
    const MAX_INLINE_PAYLOAD_SIZE = (type === 'still'
        ? providerSpecifics.getMaxStillInlinePayloadSize()
        : providerSpecifics.getMaxNonInlinePayloadSizePerFunction()) - MARGIN;
    const sizesAlreadyUsed = sizes.reduce((a, b) => a + b);
    if (sizesAlreadyUsed > MAX_INLINE_PAYLOAD_SIZE) {
        // eslint-disable-next-line no-console
        console.warn(`Warning: The props are over ${Math.round(MAX_INLINE_PAYLOAD_SIZE / 1000)}KB (${Math.ceil(sizesAlreadyUsed / 1024)}KB) in size. Uploading them to ${providerSpecifics.serverStorageProductName()} to circumvent AWS Lambda payload size, which may lead to slowdown.`);
        return true;
    }
    return false;
};
exports.getNeedsToUpload = getNeedsToUpload;
const compressInputProps = async ({ stringifiedInputProps, region, userSpecifiedBucketName, propsType, needsToUpload, providerSpecifics, forcePathStyle, skipPutAcl, requestHandler, }) => {
    const hash = providerSpecifics.randomHash();
    if (needsToUpload) {
        const bucketName = userSpecifiedBucketName !== null && userSpecifiedBucketName !== void 0 ? userSpecifiedBucketName : (await (0, get_or_create_bucket_1.internalGetOrCreateBucket)({
            region,
            enableFolderExpiry: null,
            customCredentials: null,
            providerSpecifics,
            forcePathStyle,
            skipPutAcl,
            requestHandler,
        })).bucketName;
        await providerSpecifics.writeFile({
            body: stringifiedInputProps,
            bucketName,
            region,
            customCredentials: null,
            downloadBehavior: null,
            expectedBucketOwner: null,
            key: makeKey(propsType, hash),
            privacy: 'private',
            forcePathStyle,
            storageClass: null,
            requestHandler,
        });
        return {
            type: 'bucket-url',
            hash,
            bucketName,
        };
    }
    return {
        type: 'payload',
        payload: stringifiedInputProps,
    };
};
exports.compressInputProps = compressInputProps;
const decompressInputProps = async ({ serialized, region, bucketName, expectedBucketOwner, propsType, providerSpecifics, forcePathStyle, requestHandler, }) => {
    if (serialized.type === 'payload') {
        return serialized.payload;
    }
    try {
        const response = await providerSpecifics.readFile({
            bucketName,
            expectedBucketOwner,
            key: makeKey(propsType, serialized.hash),
            region,
            forcePathStyle,
            requestHandler,
        });
        const body = await (0, stream_to_string_1.streamToString)(response);
        const payload = body;
        return payload;
    }
    catch (err) {
        throw new Error(`Failed to parse input props that were serialized: ${err.stack}`);
    }
};
exports.decompressInputProps = decompressInputProps;
