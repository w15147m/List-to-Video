// ../core/dist/esm/no-react.mjs
function interpolateFunction(input, inputRange, outputRange, options) {
  const { extrapolateLeft, extrapolateRight, easing } = options;
  let result = input;
  const [inputMin, inputMax] = inputRange;
  const [outputMin, outputMax] = outputRange;
  if (result < inputMin) {
    if (extrapolateLeft === "identity") {
      return result;
    }
    if (extrapolateLeft === "clamp") {
      result = inputMin;
    } else if (extrapolateLeft === "wrap") {
      const range = inputMax - inputMin;
      result = ((result - inputMin) % range + range) % range + inputMin;
    } else if (extrapolateLeft === "extend") {}
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity") {
      return result;
    }
    if (extrapolateRight === "clamp") {
      result = inputMax;
    } else if (extrapolateRight === "wrap") {
      const range = inputMax - inputMin;
      result = ((result - inputMin) % range + range) % range + inputMin;
    } else if (extrapolateRight === "extend") {}
  }
  if (outputMin === outputMax) {
    return outputMin;
  }
  result = (result - inputMin) / (inputMax - inputMin);
  result = easing(result);
  result = result * (outputMax - outputMin) + outputMin;
  return result;
}
function findRange(input, inputRange) {
  let i;
  for (i = 1;i < inputRange.length - 1; ++i) {
    if (inputRange[i] >= input) {
      break;
    }
  }
  return i - 1;
}
function checkValidInputRange(arr) {
  for (let i = 1;i < arr.length; ++i) {
    if (!(arr[i] > arr[i - 1])) {
      throw new Error(`inputRange must be strictly monotonically increasing but got [${arr.join(",")}]`);
    }
  }
}
function checkInfiniteRange(name, arr) {
  if (arr.length < 2) {
    throw new Error(name + " must have at least 2 elements");
  }
  for (const element of arr) {
    if (typeof element !== "number") {
      throw new Error(`${name} must contain only numbers`);
    }
    if (!Number.isFinite(element)) {
      throw new Error(`${name} must contain only finite numbers, but got [${arr.join(",")}]`);
    }
  }
}
function interpolate(input, inputRange, outputRange, options) {
  if (typeof input === "undefined") {
    throw new Error("input can not be undefined");
  }
  if (typeof inputRange === "undefined") {
    throw new Error("inputRange can not be undefined");
  }
  if (typeof outputRange === "undefined") {
    throw new Error("outputRange can not be undefined");
  }
  if (inputRange.length !== outputRange.length) {
    throw new Error("inputRange (" + inputRange.length + ") and outputRange (" + outputRange.length + ") must have the same length");
  }
  checkInfiniteRange("inputRange", inputRange);
  checkInfiniteRange("outputRange", outputRange);
  checkValidInputRange(inputRange);
  const easing = options?.easing ?? ((num) => num);
  let extrapolateLeft = "extend";
  if (options?.extrapolateLeft !== undefined) {
    extrapolateLeft = options.extrapolateLeft;
  }
  let extrapolateRight = "extend";
  if (options?.extrapolateRight !== undefined) {
    extrapolateRight = options.extrapolateRight;
  }
  if (typeof input !== "number") {
    throw new TypeError("Cannot interpolate an input which is not a number");
  }
  const range = findRange(input, inputRange);
  return interpolateFunction(input, [inputRange[range], inputRange[range + 1]], [outputRange[range], outputRange[range + 1]], {
    easing,
    extrapolateLeft,
    extrapolateRight
  });
}
function mulberry32(a) {
  let t = a + 1831565813;
  t = Math.imul(t ^ t >>> 15, t | 1);
  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
  return ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function hashCode(str) {
  let i = 0;
  let chr = 0;
  let hash = 0;
  for (i = 0;i < str.length; i++) {
    chr = str.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash |= 0;
  }
  return hash;
}
var random = (seed, dummy) => {
  if (dummy !== undefined) {
    throw new TypeError("random() takes only one argument");
  }
  if (seed === null) {
    return Math.random();
  }
  if (typeof seed === "string") {
    return mulberry32(hashCode(seed));
  }
  if (typeof seed === "number") {
    return mulberry32(seed * 10000000000);
  }
  throw new Error("random() argument must be a number or a string");
};
function truthy(value) {
  return Boolean(value);
}
if (typeof window !== "undefined") {
  window.remotion_renderReady = false;
  if (!window.remotion_delayRenderTimeouts) {
    window.remotion_delayRenderTimeouts = {};
  }
}
var DELAY_RENDER_CALLSTACK_TOKEN = "The delayRender was called:";
var DELAY_RENDER_RETRIES_LEFT = "Retries left: ";
var DELAY_RENDER_RETRY_TOKEN = "- Rendering the frame will be retried.";
var DELAY_RENDER_CLEAR_TOKEN = "handle was cleared after";
var DATE_TOKEN = "remotion-date:";
var FILE_TOKEN = "remotion-file:";
var serializeJSONWithSpecialTypes = ({
  data,
  indent,
  staticBase
}) => {
  let customDateUsed = false;
  let customFileUsed = false;
  let mapUsed = false;
  let setUsed = false;
  try {
    const serializedString = JSON.stringify(data, function(key, value) {
      const item = this[key];
      if (item instanceof Date) {
        customDateUsed = true;
        return `${DATE_TOKEN}${item.toISOString()}`;
      }
      if (item instanceof Map) {
        mapUsed = true;
        return value;
      }
      if (item instanceof Set) {
        setUsed = true;
        return value;
      }
      if (typeof item === "string" && staticBase !== null && item.startsWith(staticBase)) {
        customFileUsed = true;
        return `${FILE_TOKEN}${item.replace(staticBase + "/", "")}`;
      }
      return value;
    }, indent);
    return { serializedString, customDateUsed, customFileUsed, mapUsed, setUsed };
  } catch (err) {
    throw new Error("Could not serialize the passed input props to JSON: " + err.message);
  }
};
var deserializeJSONWithSpecialTypes = (data) => {
  return JSON.parse(data, (_, value) => {
    if (typeof value === "string" && value.startsWith(DATE_TOKEN)) {
      return new Date(value.replace(DATE_TOKEN, ""));
    }
    if (typeof value === "string" && value.startsWith(FILE_TOKEN)) {
      return `${window.remotion_staticBase}/${value.replace(FILE_TOKEN, "")}`;
    }
    return value;
  });
};
var NUMBER = "[-+]?\\d*\\.?\\d+";
var PERCENTAGE = NUMBER + "%";
function call(...args) {
  return "\\(\\s*(" + args.join(")\\s*,\\s*(") + ")\\s*\\)";
}
function getMatchers() {
  const cachedMatchers = {
    rgb: undefined,
    rgba: undefined,
    hsl: undefined,
    hsla: undefined,
    hex3: undefined,
    hex4: undefined,
    hex5: undefined,
    hex6: undefined,
    hex8: undefined
  };
  if (cachedMatchers.rgb === undefined) {
    cachedMatchers.rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
    cachedMatchers.rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
    cachedMatchers.hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
    cachedMatchers.hsla = new RegExp("hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
    cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
    cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
    cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;
    cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;
  }
  return cachedMatchers;
}
function hue2rgb(p, q, t) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * 6 * t;
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
}
function hslToRgb(h, s, l) {
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p = 2 * l - q;
  const r = hue2rgb(p, q, h + 1 / 3);
  const g = hue2rgb(p, q, h);
  const b = hue2rgb(p, q, h - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
}
function parse255(str) {
  const int = Number.parseInt(str, 10);
  if (int < 0) {
    return 0;
  }
  if (int > 255) {
    return 255;
  }
  return int;
}
function parse360(str) {
  const int = Number.parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  const num = Number.parseFloat(str);
  if (num < 0) {
    return 0;
  }
  if (num > 1) {
    return 255;
  }
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int = Number.parseFloat(str);
  if (int < 0) {
    return 0;
  }
  if (int > 100) {
    return 1;
  }
  return int / 100;
}
var colorNames = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};
function normalizeColor(color) {
  const matchers = getMatchers();
  let match;
  if (matchers.hex6) {
    if (match = matchers.hex6.exec(color)) {
      return Number.parseInt(match[1] + "ff", 16) >>> 0;
    }
  }
  if (colorNames[color] !== undefined) {
    return colorNames[color];
  }
  if (matchers.rgb) {
    if (match = matchers.rgb.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;
    }
  }
  if (matchers.rgba) {
    if (match = matchers.rgba.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;
    }
  }
  if (matchers.hex3) {
    if (match = matchers.hex3.exec(color)) {
      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + "ff", 16) >>> 0;
    }
  }
  if (matchers.hex8) {
    if (match = matchers.hex8.exec(color)) {
      return Number.parseInt(match[1], 16) >>> 0;
    }
  }
  if (matchers.hex4) {
    if (match = matchers.hex4.exec(color)) {
      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;
    }
  }
  if (matchers.hsl) {
    if (match = matchers.hsl.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;
    }
  }
  if (matchers.hsla) {
    if (match = matchers.hsla.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;
    }
  }
  throw new Error(`invalid color string ${color} provided`);
}
function processColor(color) {
  const normalizedColor = normalizeColor(color);
  return (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;
}
var ENABLE_V5_BREAKING_CHANGES = false;
var validateFrame = ({
  allowFloats,
  durationInFrames,
  frame
}) => {
  if (typeof frame === "undefined") {
    throw new TypeError(`Argument missing for parameter "frame"`);
  }
  if (typeof frame !== "number") {
    throw new TypeError(`Argument passed for "frame" is not a number: ${frame}`);
  }
  if (!Number.isFinite(frame)) {
    throw new RangeError(`Frame ${frame} is not finite`);
  }
  if (frame % 1 !== 0 && !allowFloats) {
    throw new RangeError(`Argument for frame must be an integer, but got ${frame}`);
  }
  if (frame < 0 && frame < -durationInFrames) {
    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the lowest frame that can be rendered is ${-durationInFrames}`);
  }
  if (frame > durationInFrames - 1) {
    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the highest frame that can be rendered is ${durationInFrames - 1}`);
  }
};
var validCodecs = [
  "h264",
  "h265",
  "vp8",
  "vp9",
  "mp3",
  "aac",
  "wav",
  "prores",
  "h264-mkv",
  "h264-ts",
  "gif"
];
function validateCodec(defaultCodec, location, name) {
  if (typeof defaultCodec === "undefined") {
    return;
  }
  if (typeof defaultCodec !== "string") {
    throw new TypeError(`The "${name}" prop ${location} must be a string, but you passed a value of type ${typeof defaultCodec}.`);
  }
  if (!validCodecs.includes(defaultCodec)) {
    throw new Error(`The "${name}" prop ${location} must be one of ${validCodecs.join(", ")}, but you passed ${defaultCodec}.`);
  }
}
var validateDefaultAndInputProps = (defaultProps, name, compositionId) => {
  if (!defaultProps) {
    return;
  }
  if (typeof defaultProps !== "object") {
    throw new Error(`"${name}" must be an object, but you passed a value of type ${typeof defaultProps}`);
  }
  if (Array.isArray(defaultProps)) {
    throw new Error(`"${name}" must be an object, an array was passed ${compositionId ? `for composition "${compositionId}"` : ""}`);
  }
};
function validateDimension(amount, nameOfProp, location) {
  if (typeof amount !== "number") {
    throw new Error(`The "${nameOfProp}" prop ${location} must be a number, but you passed a value of type ${typeof amount}`);
  }
  if (isNaN(amount)) {
    throw new TypeError(`The "${nameOfProp}" prop ${location} must not be NaN, but is NaN.`);
  }
  if (!Number.isFinite(amount)) {
    throw new TypeError(`The "${nameOfProp}" prop ${location} must be finite, but is ${amount}.`);
  }
  if (amount % 1 !== 0) {
    throw new TypeError(`The "${nameOfProp}" prop ${location} must be an integer, but is ${amount}.`);
  }
  if (amount <= 0) {
    throw new TypeError(`The "${nameOfProp}" prop ${location} must be positive, but got ${amount}.`);
  }
}
function validateDurationInFrames(durationInFrames, options) {
  const { allowFloats, component } = options;
  if (typeof durationInFrames === "undefined") {
    throw new Error(`The "durationInFrames" prop ${component} is missing.`);
  }
  if (typeof durationInFrames !== "number") {
    throw new Error(`The "durationInFrames" prop ${component} must be a number, but you passed a value of type ${typeof durationInFrames}`);
  }
  if (durationInFrames <= 0) {
    throw new TypeError(`The "durationInFrames" prop ${component} must be positive, but got ${durationInFrames}.`);
  }
  if (!allowFloats && durationInFrames % 1 !== 0) {
    throw new TypeError(`The "durationInFrames" prop ${component} must be an integer, but got ${durationInFrames}.`);
  }
  if (!Number.isFinite(durationInFrames)) {
    throw new TypeError(`The "durationInFrames" prop ${component} must be finite, but got ${durationInFrames}.`);
  }
}
function validateFps(fps, location, isGif) {
  if (typeof fps !== "number") {
    throw new Error(`"fps" must be a number, but you passed a value of type ${typeof fps} ${location}`);
  }
  if (!Number.isFinite(fps)) {
    throw new Error(`"fps" must be a finite, but you passed ${fps} ${location}`);
  }
  if (isNaN(fps)) {
    throw new Error(`"fps" must not be NaN, but got ${fps} ${location}`);
  }
  if (fps <= 0) {
    throw new TypeError(`"fps" must be positive, but got ${fps} ${location}`);
  }
  if (isGif && fps > 50) {
    throw new TypeError(`The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif`);
  }
}
var getExpectedMediaFrameUncorrected = ({
  frame,
  playbackRate,
  startFrom
}) => {
  return interpolate(frame, [-1, startFrom, startFrom + 1], [-1, startFrom, startFrom + playbackRate]);
};
var getAbsoluteSrc = (relativeSrc) => {
  if (typeof window === "undefined") {
    return relativeSrc;
  }
  if (relativeSrc.startsWith("http://") || relativeSrc.startsWith("https://") || relativeSrc.startsWith("file://") || relativeSrc.startsWith("blob:") || relativeSrc.startsWith("data:")) {
    return relativeSrc;
  }
  return new URL(relativeSrc, window.origin).href;
};
var getOffthreadVideoSource = ({
  src,
  transparent,
  currentTime,
  toneMapped
}) => {
  return `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(getAbsoluteSrc(src))}&time=${encodeURIComponent(Math.max(0, currentTime))}&transparent=${String(transparent)}&toneMapped=${String(toneMapped)}`;
};
var NoReactInternals = {
  processColor,
  truthy,
  validateFps,
  validateDimension,
  validateDurationInFrames,
  validateDefaultAndInputProps,
  validateFrame,
  serializeJSONWithSpecialTypes,
  bundleName: "bundle.js",
  bundleMapName: "bundle.js.map",
  deserializeJSONWithSpecialTypes,
  DELAY_RENDER_CALLSTACK_TOKEN,
  DELAY_RENDER_RETRY_TOKEN,
  DELAY_RENDER_CLEAR_TOKEN,
  DELAY_RENDER_ATTEMPT_TOKEN: DELAY_RENDER_RETRIES_LEFT,
  getOffthreadVideoSource,
  getExpectedMediaFrameUncorrected,
  ENABLE_V5_BREAKING_CHANGES,
  MIN_NODE_VERSION: ENABLE_V5_BREAKING_CHANGES ? 18 : 16,
  MIN_BUN_VERSION: ENABLE_V5_BREAKING_CHANGES ? "1.1.3" : "1.0.3",
  colorNames,
  DATE_TOKEN,
  FILE_TOKEN,
  validateCodec
};

// src/constants.ts
var COMMAND_NOT_FOUND = "Command not found";
var expiryDays = {
  "1-day": 1,
  "3-days": 3,
  "7-days": 7,
  "30-days": 30
};
var ServerlessRoutines;
((ServerlessRoutines2) => {
  ServerlessRoutines2["info"] = "info";
  ServerlessRoutines2["start"] = "start";
  ServerlessRoutines2["launch"] = "launch";
  ServerlessRoutines2["status"] = "status";
  ServerlessRoutines2["renderer"] = "renderer";
  ServerlessRoutines2["still"] = "still";
  ServerlessRoutines2["compositions"] = "compositions";
})(ServerlessRoutines ||= {});
var serverlessCodecs = [
  "h264",
  "h265",
  "vp8",
  "vp9",
  "mp3",
  "aac",
  "wav",
  "gif",
  "prores"
];
var rendersPrefix = (renderId) => `renders/${renderId}`;
var outStillName = (renderId, imageFormat) => `${rendersPrefix(renderId)}/out.${imageFormat}`;
var outName = (renderId, extension) => `${rendersPrefix(renderId)}/out.${extension}`;
var customOutName = (renderId, bucketName, name) => {
  if (typeof name === "string") {
    return {
      renderBucketName: bucketName,
      key: `${rendersPrefix(renderId)}/${name}`,
      customCredentials: null
    };
  }
  return {
    key: name.key,
    renderBucketName: name.bucketName,
    customCredentials: name.s3OutputProvider ?? null
  };
};
var overallProgressKey = (renderId) => `${rendersPrefix(renderId)}/progress.json`;
var artifactName = (renderId, name) => `${rendersPrefix(renderId)}/artifacts/${name}`;
var CONCAT_FOLDER_TOKEN = "remotion-concat";
var MAX_FUNCTIONS_PER_RENDER = 200;
var MINIMUM_FRAMES_PER_FUNCTION = 5;
var REMOTION_CONCATENATED_TOKEN = "remotion-concatenated-token";
var RENDERER_PATH_TOKEN = "remotion-bucket";
// src/serialize-artifact.ts
var deserializeArtifact = (serializedArtifact) => {
  if (serializedArtifact.binary) {
    const binaryString = atob(serializedArtifact.stringContent);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0;i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return {
      filename: serializedArtifact.filename,
      content: bytes,
      frame: serializedArtifact.frame,
      downloadBehavior: serializedArtifact.downloadBehavior
    };
  }
  return {
    filename: serializedArtifact.filename,
    content: serializedArtifact.stringContent,
    frame: serializedArtifact.frame,
    downloadBehavior: serializedArtifact.downloadBehavior
  };
};
var serializeArtifact = (artifact) => {
  if (artifact.content instanceof Uint8Array) {
    let binary = "";
    const bytes = new Uint8Array(artifact.content);
    const len = bytes.byteLength;
    for (let i = 0;i < len; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    const b64encoded = btoa(binary);
    return {
      filename: artifact.filename,
      stringContent: b64encoded,
      frame: artifact.frame,
      binary: true,
      downloadBehavior: artifact.downloadBehavior
    };
  }
  return {
    filename: artifact.filename,
    stringContent: artifact.content,
    frame: artifact.frame,
    binary: false,
    downloadBehavior: artifact.downloadBehavior
  };
};
// src/validate-download-behavior.ts
var validateDownloadBehavior = (downloadBehavior) => {
  if (downloadBehavior === null || downloadBehavior === undefined) {
    return null;
  }
  if (typeof downloadBehavior !== "object") {
    throw new Error("downloadBehavior must be null or an object");
  }
  const behavior = downloadBehavior;
  if (behavior.type !== "download" && behavior.type !== "play-in-browser") {
    throw new Error('Download behavior must be either "download" or "play-in-browser"');
  }
  if (behavior.type === "download") {
    if (typeof behavior.fileName !== "string" && behavior.fileName !== null) {
      throw new Error('If "downloadBehavior.type" is "download", then fileName must be "null" or a string');
    }
  }
};
// src/best-frames-per-function-param.ts
var bestFramesPerFunctionParam = (frameCount) => {
  const concurrency = interpolate(frameCount, [0, 18000], [75, 150], {
    extrapolateRight: "clamp"
  });
  const framesPerFunction = Math.max(frameCount / concurrency, 20);
  const functionsNeeded = Math.ceil(frameCount / framesPerFunction);
  return Math.ceil(frameCount / functionsNeeded);
};

// src/validate-frames-per-function.ts
var validateFramesPerFunction = ({
  framesPerFunction,
  durationInFrames,
  concurrency
}) => {
  if (concurrency !== null && framesPerFunction !== null) {
    throw new TypeError(`Both 'framesPerLambda' and 'concurrency' were set. Please use only one of them.`);
  }
  const effectiveMinimum = Math.min(MINIMUM_FRAMES_PER_FUNCTION, durationInFrames);
  if (concurrency !== null) {
    if (typeof concurrency !== "number") {
      throw new TypeError(`'concurrency' needs to be a number, passed ${JSON.stringify(concurrency)}`);
    }
    if (!Number.isFinite(concurrency)) {
      throw new TypeError(`'concurrency' needs to be finite, passed ${concurrency}`);
    }
    if (Number.isNaN(concurrency)) {
      throw new TypeError(`'concurrency' needs to be a valid number, passed ${concurrency}`);
    }
    if (concurrency % 1 !== 0) {
      throw new TypeError(`'concurrency' needs to be an integer, passed ${concurrency}`);
    }
    if (concurrency <= 0) {
      throw new TypeError(`'concurrency' needs to be positive, passed ${concurrency}`);
    }
    if (concurrency > MAX_FUNCTIONS_PER_RENDER) {
      throw new TypeError(`'concurrency' cannot exceed ${MAX_FUNCTIONS_PER_RENDER}, passed ${concurrency}`);
    }
    return Math.max(Math.ceil(durationInFrames / concurrency), effectiveMinimum);
  }
  if (framesPerFunction === null) {
    return Math.max(bestFramesPerFunctionParam(durationInFrames), effectiveMinimum);
  }
  if (framesPerFunction === undefined) {
    return Math.max(bestFramesPerFunctionParam(durationInFrames), effectiveMinimum);
  }
  if (typeof framesPerFunction !== "number") {
    throw new TypeError(`'framesPerLambda' needs to be a number, passed ${JSON.stringify(framesPerFunction)}`);
  }
  if (!Number.isFinite(framesPerFunction)) {
    throw new TypeError(`'framesPerLambda' needs to be finite, passed ${framesPerFunction}`);
  }
  if (Number.isNaN(framesPerFunction)) {
    throw new TypeError(`'framesPerLambda' needs to be NaN, passed ${framesPerFunction}`);
  }
  if (framesPerFunction % 1 !== 0) {
    throw new TypeError(`'framesPerLambda' needs to be an integer, passed ${framesPerFunction}`);
  }
  if (framesPerFunction < effectiveMinimum) {
    throw new TypeError(`The framesPerLambda needs to be at least ${effectiveMinimum}, but is ${framesPerFunction}`);
  }
  return framesPerFunction;
};
// ../renderer/dist/esm/error-handling.mjs
import * as tty from "tty";

// ../core/dist/esm/version.mjs
var VERSION = "4.0.366";

// ../renderer/dist/esm/error-handling.mjs
var isColorSupported = () => {
  const env = process.env || {};
  const isForceDisabled = "NO_COLOR" in env;
  if (isForceDisabled) {
    return false;
  }
  const isForced = "FORCE_COLOR" in env;
  if (isForced) {
    return true;
  }
  const isWindows = process.platform === "win32";
  const isCompatibleTerminal = tty?.isatty?.(1) && env.TERM && env.TERM !== "dumb";
  const isCI = "CI" in env && (("GITHUB_ACTIONS" in env) || ("GITLAB_CI" in env) || ("CIRCLECI" in env));
  return isWindows || isCompatibleTerminal || isCI;
};
var chalk = (() => {
  const colors = {
    enabled: () => isColorSupported(),
    visible: true,
    styles: {},
    keys: {}
  };
  const ansi = (st) => {
    const open = `\x1B[${st.codes[0]}m`;
    const close = `\x1B[${st.codes[1]}m`;
    const regex = new RegExp(`\\u001b\\[${st.codes[1]}m`, "g");
    st.wrap = (input, newline) => {
      if (input.includes(close))
        input = input.replace(regex, close + open);
      const output = open + input + close;
      return newline ? output.replace(/\r*\n/g, `${close}$&${open}`) : output;
    };
    return st;
  };
  const wrap = (sty, input, newline) => {
    return sty.wrap?.(input, newline);
  };
  const style = (input, stack) => {
    if (input === "" || input === null || input === undefined)
      return "";
    if (colors.enabled() === false)
      return input;
    if (colors.visible === false)
      return "";
    let str = String(input);
    const nl = str.includes(`
`);
    let n = stack.length;
    while (n-- > 0)
      str = wrap(colors.styles[stack[n]], str, nl);
    return str;
  };
  const define = (name, codes, type) => {
    colors.styles[name] = ansi({ name, codes });
    const keys = colors.keys[type] || (colors.keys[type] = []);
    keys.push(name);
    Reflect.defineProperty(colors, name, {
      configurable: true,
      enumerable: true,
      set(value) {
        colors.alias?.(name, value);
      },
      get() {
        const color = (input) => style(input, color.stack);
        Reflect.setPrototypeOf(color, colors);
        color.stack = this.stack ? this.stack.concat(name) : [name];
        return color;
      }
    });
  };
  define("reset", [0, 0], "modifier");
  define("bold", [1, 22], "modifier");
  define("dim", [2, 22], "modifier");
  define("italic", [3, 23], "modifier");
  define("underline", [4, 24], "modifier");
  define("inverse", [7, 27], "modifier");
  define("hidden", [8, 28], "modifier");
  define("strikethrough", [9, 29], "modifier");
  define("black", [30, 39], "color");
  define("red", [31, 39], "color");
  define("green", [32, 39], "color");
  define("yellow", [33, 39], "color");
  define("blue", [34, 39], "color");
  define("magenta", [35, 39], "color");
  define("cyan", [36, 39], "color");
  define("white", [37, 39], "color");
  define("gray", [90, 39], "color");
  define("grey", [90, 39], "color");
  define("bgBlack", [40, 49], "bg");
  define("bgRed", [41, 49], "bg");
  define("bgGreen", [42, 49], "bg");
  define("bgYellow", [43, 49], "bg");
  define("bgBlue", [44, 49], "bg");
  define("bgMagenta", [45, 49], "bg");
  define("bgWhite", [47, 49], "bg");
  define("blackBright", [90, 39], "bright");
  define("redBright", [91, 39], "bright");
  define("greenBright", [92, 39], "bright");
  define("yellowBright", [93, 39], "bright");
  define("blueBright", [94, 39], "bright");
  define("magentaBright", [95, 39], "bright");
  define("whiteBright", [97, 39], "bright");
  define("bgBlackBright", [100, 49], "bgBright");
  define("bgRedBright", [101, 49], "bgBright");
  define("bgGreenBright", [102, 49], "bgBright");
  define("bgYellowBright", [103, 49], "bgBright");
  define("bgBlueBright", [104, 49], "bgBright");
  define("bgMagentaBright", [105, 49], "bgBright");
  define("bgWhiteBright", [107, 49], "bgBright");
  colors.alias = (name, color) => {
    const fn = colors[color];
    if (typeof fn !== "function") {
      throw new TypeError("Expected alias to be the name of an existing color (string) or a function");
    }
    if (!fn.stack) {
      Reflect.defineProperty(fn, "name", { value: name });
      colors.styles[name] = fn;
      fn.stack = [name];
    }
    Reflect.defineProperty(colors, name, {
      configurable: true,
      enumerable: true,
      set(value) {
        colors.alias?.(name, value);
      },
      get() {
        const col = (input) => style(input, col.stack);
        Reflect.setPrototypeOf(col, colors);
        col.stack = this.stack ? this.stack.concat(fn.stack) : fn.stack;
        return col;
      }
    });
  };
  return colors;
})();
var logLevels = ["trace", "verbose", "info", "warn", "error"];
var getNumberForLogLevel = (level) => {
  return logLevels.indexOf(level);
};
var isEqualOrBelowLogLevel = (currentLevel, level) => {
  return getNumberForLogLevel(currentLevel) <= getNumberForLogLevel(level);
};
var reproWriteInstance = null;
var getReproWriter = () => {
  if (!reproWriteInstance) {
    throw new Error("reproWriteInstance is not initialized");
  }
  return reproWriteInstance;
};
var writeInRepro = (level, ...args) => {
  if (isReproEnabled()) {
    getReproWriter().writeLine(level, ...args);
  }
};
var shouldRepro = false;
var isReproEnabled = () => shouldRepro;
function truthy2(value) {
  return Boolean(value);
}
var INDENT_TOKEN = chalk.gray("│");
var verboseTag = (str) => {
  return isColorSupported() ? chalk.bgBlack(` ${str} `) : `[${str}]`;
};
var Log = {
  formatLogs: (logLevel, options, args) => {
    return [
      options.indent ? INDENT_TOKEN : null,
      options.tag ? verboseTag(options.tag) : null
    ].filter(truthy2).concat(args.map((a) => {
      if (logLevel === "warn") {
        return chalk.yellow(a);
      }
      if (logLevel === "error") {
        return chalk.red(a);
      }
      if (logLevel === "verbose" || logLevel === "trace") {
        return chalk.gray(a);
      }
      return a;
    }));
  },
  trace: (options, ...args) => {
    writeInRepro("trace", ...args);
    if (isEqualOrBelowLogLevel(options.logLevel, "trace")) {
      if (args.length === 0) {
        return process.stdout.write(`
`);
      }
      return console.log(...Log.formatLogs("trace", options, args));
    }
  },
  verbose: (options, ...args) => {
    writeInRepro("verbose", ...args);
    if (isEqualOrBelowLogLevel(options.logLevel, "verbose")) {
      if (args.length === 0) {
        return process.stdout.write(`
`);
      }
      return console.log(...Log.formatLogs("verbose", options, args));
    }
  },
  info: (options, ...args) => {
    writeInRepro("info", ...args);
    if (isEqualOrBelowLogLevel(options.logLevel, "info")) {
      if (args.length === 0) {
        return process.stdout.write(`
`);
      }
      return console.log(...Log.formatLogs("info", options, args));
    }
  },
  warn: (options, ...args) => {
    writeInRepro("warn", ...args);
    if (isEqualOrBelowLogLevel(options.logLevel, "warn")) {
      if (args.length === 0) {
        return process.stdout.write(`
`);
      }
      return console.warn(...Log.formatLogs("warn", options, args));
    }
  },
  error: (options, ...args) => {
    writeInRepro("error", ...args);
    if (isEqualOrBelowLogLevel(options.logLevel, "error")) {
      if (args.length === 0) {
        return process.stdout.write(`
`);
      }
      return console.error(...Log.formatLogs("error", options, args));
    }
  }
};
var alreadyPrintedCache = [];
var printUsefulErrorMessage = (err, logLevel, indent) => {
  const errorStack = err.stack;
  if (errorStack && alreadyPrintedCache.includes(errorStack)) {
    return;
  }
  if (errorStack) {
    alreadyPrintedCache.push(errorStack);
    alreadyPrintedCache = alreadyPrintedCache.slice(-10);
  }
  if (err.message.includes("Could not play video with")) {
    Log.info({ indent, logLevel });
    Log.info({ indent, logLevel }, "\uD83D\uDCA1 Get help for this issue at https://remotion.dev/docs/media-playback-error");
  }
  if (err.message.includes("A delayRender()") && err.message.includes("was called but not cleared after")) {
    Log.info({ indent, logLevel });
    if (err.message.includes("/proxy")) {
      Log.info({ indent, logLevel }, "\uD83D\uDCA1 Get help for this issue at https://remotion.dev/docs/troubleshooting/delay-render-proxy");
    }
    Log.info({ indent, logLevel }, "\uD83D\uDCA1 Get help for this issue at https://remotion.dev/docs/timeout");
  }
  if (err.message.includes("Target closed")) {
    Log.info({ indent, logLevel });
    Log.info({ indent, logLevel }, "\uD83D\uDCA1 Get help for this issue at https://remotion.dev/docs/target-closed");
  }
  if (err.message.includes("Timed out evaluating")) {
    Log.info({ indent, logLevel });
    Log.info({ indent, logLevel }, "\uD83D\uDCA1 Get help for this issue at https://remotion.dev/docs/troubleshooting/timed-out-page-function");
  }
  if (err.message.includes("ENAMETOOLONG")) {
    Log.info({ indent, logLevel });
    Log.info({ indent, logLevel }, "\uD83D\uDCA1 Get help for this issue at https://remotion.dev/docs/enametoolong");
  }
  if (err.message.includes("Member must have value less than or equal to 3008")) {
    Log.warn({ indent, logLevel });
    Log.warn({ indent, logLevel }, "\uD83D\uDCA1 This error indicates that you have a AWS account on the free or basic tier or have been limited by your organization.");
    Log.warn({ indent, logLevel }, "Often times this can be solved by adding a credit card, or if already done, by contacting AWS support.");
    Log.warn({
      indent,
      logLevel
    }, "Alternatively, you can decrease the memory size of your Lambda function to a value below 3008 MB. See: https://www.remotion.dev/docs/lambda/runtime#core-count--vcpus");
    Log.warn({ indent, logLevel }, "See also: https://repost.aws/questions/QUKruWYNDYTSmP17jCnIz6IQ/questions/QUKruWYNDYTSmP17jCnIz6IQ/unable-to-set-lambda-memory-over-3008mb");
  }
  if (err.stack?.includes("TooManyRequestsException: Rate Exceeded.") || err.message?.includes("ConcurrentInvocationLimitExceeded")) {
    Log.info({ indent, logLevel });
    Log.info({ indent, logLevel }, "\uD83D\uDCA1 This error indicates that your Lambda concurrency limit is too low. See: https://www.remotion.dev/docs/lambda/troubleshooting/rate-limit");
  }
  if (err.message.includes("Error creating WebGL context")) {
    Log.info({ indent, logLevel });
    Log.warn({
      indent,
      logLevel
    }, '\uD83D\uDCA1 You might need to set the OpenGL renderer to "angle-egl", "angle" (or "swangle" if rendering on lambda). Learn why at https://www.remotion.dev/docs/three');
    Log.warn({
      indent,
      logLevel
    }, "\uD83D\uDCA1 Check how it's done at https://www.remotion.dev/docs/chromium-flags#--gl");
  }
  if (err.message.includes("The bucket does not allow ACLs")) {
    Log.info({ indent, logLevel });
    Log.info({ indent, logLevel }, "\uD83D\uDCA1 Fix for this issue: https://remotion.dev/docs/lambda/troubleshooting/bucket-disallows-acl");
  }
  if (err.message.includes("Minified React error #306")) {
    const componentName = err.message.match(/<\w+>/)?.[0];
    Log.info({ indent, logLevel }, [
      "\uD83D\uDCA1 This error indicates that the component",
      componentName ? `(${componentName})` : null,
      "you are trying to render is not imported correctly."
    ].filter(truthy2).join(" "));
    Log.info({ indent, logLevel });
    Log.info({ indent, logLevel }, "   Check the root file and ensure that the component is not undefined.");
    Log.info({ indent, logLevel }, "   Oftentimes, this happens if the component is missing the `export` keyword");
    Log.info({ indent, logLevel }, "   or if the component was renamed and the import statement not properly adjusted.");
  }
  if (err.message.includes("GLIBC_")) {
    Log.info({ indent, logLevel }, "\uD83D\uDCA1 Remotion requires at least Libc 2.35.");
    Log.info({ indent, logLevel }, "\uD83D\uDCA1 Get help for this issue: https://github.com/remotion-dev/remotion/issues/2439");
  }
  if (err.message.includes("EBADF")) {
    Log.info({ indent, logLevel }, "\uD83D\uDCA1 This error might be fixed by changing your Node version:");
    Log.info({ indent, logLevel }, "   https://github.com/remotion-dev/remotion/issues/2452");
  }
  if (err.message.includes("routines::unsupported")) {
    Log.info({ indent, logLevel }, "\uD83D\uDCA1 This error might happen if using Cloud Run with credentials that have a newline at the end or are otherwise badly encoded.");
    Log.info({ indent, logLevel }, "   https://github.com/remotion-dev/remotion/issues/3864");
  }
  if (err.message.includes("Failed to fetch")) {
    Log.info({ indent, logLevel }, "\uD83D\uDCA1 On Lambda, one reason this could happen is that Chrome is rejecting an asset to be loaded when it is running low on disk space.");
    Log.info({ indent, logLevel }, "Try increasing the disk size of your Lambda function.");
  }
  if (err.message.includes("Invalid value specified for cpu")) {
    Log.info({ indent, logLevel });
    Log.info({ indent, logLevel }, "\uD83D\uDCA1 This error indicates that your GCP account does have a limit. Try setting `--maxInstances=5` / `maxInstances: 5` when deploying this service.");
    Log.info({
      indent,
      logLevel
    });
  }
};
var wrapWithErrorHandling = (fn) => {
  return async (...args) => {
    try {
      return await fn(...args);
    } catch (err) {
      const { indent } = args[0];
      const { logLevel } = args[0];
      printUsefulErrorMessage(err, logLevel, indent);
      throw err;
    }
  };
};
// ../streaming/dist/esm/index.mjs
var magicWordStr = "remotion_buffer:";
var makeStreamPayloadMessage = ({
  status,
  body,
  nonce
}) => {
  const nonceArr = new TextEncoder().encode(nonce);
  const magicWordArr = new TextEncoder().encode(magicWordStr);
  const separatorArr = new TextEncoder().encode(":");
  const bodyLengthArr = new TextEncoder().encode(body.length.toString());
  const statusArr = new TextEncoder().encode(String(status));
  const totalLength = nonceArr.length + magicWordArr.length + separatorArr.length * 3 + bodyLengthArr.length + statusArr.length + body.length;
  const concat = new Uint8Array(totalLength);
  let offset = 0;
  const appendToConcat = (data) => {
    concat.set(data, offset);
    offset += data.length;
  };
  appendToConcat(magicWordArr);
  appendToConcat(nonceArr);
  appendToConcat(separatorArr);
  appendToConcat(bodyLengthArr);
  appendToConcat(separatorArr);
  appendToConcat(statusArr);
  appendToConcat(separatorArr);
  appendToConcat(body);
  return concat;
};
var streamingKey = "remotion_buffer:";
var makeStreamer = (onMessage) => {
  const separator = new Uint8Array(streamingKey.length);
  for (let i = 0;i < streamingKey.length; i++) {
    separator[i] = streamingKey.charCodeAt(i);
  }
  let unprocessedBuffers = [];
  let outputBuffer = new Uint8Array(0);
  let missingData = null;
  const findSeparatorIndex = () => {
    let searchIndex = 0;
    while (true) {
      const separatorIndex = outputBuffer.indexOf(separator[0], searchIndex);
      if (separatorIndex === -1) {
        return -1;
      }
      if (outputBuffer.subarray(separatorIndex, separatorIndex + separator.length).toString() !== separator.toString()) {
        searchIndex = separatorIndex + 1;
        continue;
      }
      return separatorIndex;
    }
  };
  const processInput = () => {
    let separatorIndex = findSeparatorIndex();
    if (separatorIndex === -1) {
      return;
    }
    separatorIndex += separator.length;
    let nonceString = "";
    let lengthString = "";
    let statusString = "";
    while (true) {
      if (separatorIndex > outputBuffer.length - 1) {
        return;
      }
      const nextDigit = outputBuffer[separatorIndex];
      separatorIndex++;
      if (nextDigit === 58) {
        break;
      }
      nonceString += String.fromCharCode(nextDigit);
    }
    while (true) {
      if (separatorIndex > outputBuffer.length - 1) {
        return;
      }
      const nextDigit = outputBuffer[separatorIndex];
      separatorIndex++;
      if (nextDigit === 58) {
        break;
      }
      lengthString += String.fromCharCode(nextDigit);
    }
    while (true) {
      if (separatorIndex > outputBuffer.length - 1) {
        return;
      }
      const nextDigit = outputBuffer[separatorIndex];
      if (nextDigit === 58) {
        break;
      }
      separatorIndex++;
      statusString += String.fromCharCode(nextDigit);
    }
    const length = Number(lengthString);
    const status = Number(statusString);
    const dataLength = outputBuffer.length - separatorIndex - 1;
    if (dataLength < length) {
      missingData = {
        dataMissing: length - dataLength
      };
      return;
    }
    const data = outputBuffer.subarray(separatorIndex + 1, separatorIndex + 1 + Number(lengthString));
    onMessage(status === 1 ? "error" : "success", nonceString, data);
    missingData = null;
    outputBuffer = outputBuffer.subarray(separatorIndex + Number(lengthString) + 1);
    processInput();
  };
  const onData = (data) => {
    unprocessedBuffers.push(data);
    if (missingData) {
      missingData.dataMissing -= data.length;
    }
    if (missingData && missingData.dataMissing > 0) {
      return;
    }
    const newBuffer = new Uint8Array(outputBuffer.length + unprocessedBuffers.reduce((acc, val) => acc + val.length, 0));
    newBuffer.set(outputBuffer, 0);
    let offset = outputBuffer.length;
    for (const buf of unprocessedBuffers) {
      newBuffer.set(buf, offset);
      offset += buf.length;
    }
    outputBuffer = newBuffer;
    unprocessedBuffers = [];
    processInput();
  };
  return {
    onData,
    getOutputBuffer: () => outputBuffer,
    clear: () => {
      unprocessedBuffers = [];
      outputBuffer = new Uint8Array(0);
    }
  };
};
// src/min-max.ts
var min = (arr) => {
  if (arr.length === 0) {
    throw new Error("Array of 0 length");
  }
  let smallest = arr[0];
  for (let i = 0;i < arr.length; i++) {
    const elem = arr[i];
    if (elem < smallest) {
      smallest = elem;
    }
  }
  return smallest;
};
var max = (arr) => {
  if (arr.length === 0) {
    throw new Error("Array of 0 length");
  }
  let biggest = arr[0];
  for (let i = 0;i < arr.length; i++) {
    const elem = arr[i];
    if (elem > biggest) {
      biggest = elem;
    }
  }
  return biggest;
};

// src/calculate-chunk-times.ts
var getAbsoluteTime = (parsedTimings) => {
  if (parsedTimings.length === 0) {
    return 0;
  }
  const allEnds = parsedTimings.map((p) => p.rendered);
  const allStarts = parsedTimings.map((p) => p.start);
  const biggestEnd = max(allEnds);
  const smallestStart = min(allStarts);
  return Math.max(0, biggestEnd - smallestStart);
};
var calculateChunkTimes = ({
  type,
  timings
}) => {
  const parsedTimings = timings;
  const absoluteTime = getAbsoluteTime(parsedTimings);
  if (type === "combined-time-for-cost-calculation") {
    const totalEncodingTimings = parsedTimings.map((p) => Math.max(0, p.rendered - p.start)).reduce((a, b) => a + b, 0);
    return totalEncodingTimings + absoluteTime;
  }
  if (type === "absolute-time") {
    return absoluteTime;
  }
  throw new Error("invalid time for calculate chunk times");
};
// src/make-bucket-name.ts
var makeBucketName = (region, providerSpecifics) => {
  return `${providerSpecifics.getBucketPrefix()}${region.replace(/-/g, "")}-${providerSpecifics.randomHash()}`;
};

// src/get-or-create-bucket.ts
var internalGetOrCreateBucket = async (params) => {
  const remotionBuckets = await params.providerSpecifics.getBuckets({
    region: params.region,
    forceBucketName: null,
    forcePathStyle: params.forcePathStyle,
    requestHandler: params.requestHandler
  });
  if (remotionBuckets.length > 1) {
    throw new Error(`You have multiple buckets (${remotionBuckets.map((b) => b.name)}) in your S3 region (${params.region}) starting with "${params.providerSpecifics.getBucketPrefix()}". Please see https://remotion.dev/docs/lambda/multiple-buckets.`);
  }
  const { enableFolderExpiry, region } = params;
  if (remotionBuckets.length === 1) {
    const existingBucketName = remotionBuckets[0].name;
    await params.providerSpecifics.applyLifeCycle({
      enableFolderExpiry: enableFolderExpiry ?? null,
      bucketName: existingBucketName,
      region,
      customCredentials: params.customCredentials,
      forcePathStyle: params.forcePathStyle,
      requestHandler: params.requestHandler
    });
    return { bucketName: remotionBuckets[0].name, alreadyExisted: true };
  }
  const bucketName = makeBucketName(params.region, params.providerSpecifics);
  await params.providerSpecifics.createBucket({
    bucketName,
    region: params.region,
    forcePathStyle: params.forcePathStyle,
    skipPutAcl: params.skipPutAcl,
    requestHandler: params.requestHandler
  });
  await params.providerSpecifics.applyLifeCycle({
    enableFolderExpiry: enableFolderExpiry ?? null,
    bucketName,
    region,
    customCredentials: params.customCredentials,
    forcePathStyle: params.forcePathStyle,
    requestHandler: params.requestHandler
  });
  return { bucketName, alreadyExisted: false };
};

// src/input-props-keys.ts
var inputPropsKey = (hash) => {
  return `input-props/${hash}.json`;
};
var resolvedPropsKey = (hash) => {
  return `resolved-props/${hash}.json`;
};

// src/stream-to-string.ts
function streamToString(stream) {
  if (Buffer.isBuffer(stream)) {
    return stream.toString("utf-8");
  }
  const chunks = [];
  return new Promise((resolve, reject) => {
    stream.on("data", (chunk) => chunks.push(new Uint8Array(chunk)));
    stream.on("error", (err) => reject(err));
    stream.on("end", () => resolve(Buffer.concat(chunks).toString("utf8")));
  });
}

// src/validate-webhook.ts
var MAX_WEBHOOK_CUSTOM_DATA_SIZE = 1024;
var validateWebhook = (webhook) => {
  if (typeof webhook === "undefined" || webhook === null) {
    return;
  }
  if (webhook.customData) {
    const size = JSON.stringify(webhook.customData).length;
    if (size > MAX_WEBHOOK_CUSTOM_DATA_SIZE) {
      throw new Error(`Webhook "customData" must be less than ${MAX_WEBHOOK_CUSTOM_DATA_SIZE} bytes. Current size: ${size} bytes.`);
    }
  }
};

// src/compress-props.ts
var makeKey = (type, hash) => {
  if (type === "input-props") {
    return inputPropsKey(hash);
  }
  return resolvedPropsKey(hash);
};
var serializeOrThrow = (inputProps, propsType) => {
  try {
    const payload = NoReactInternals.serializeJSONWithSpecialTypes({
      indent: undefined,
      staticBase: null,
      data: inputProps
    });
    return payload.serializedString;
  } catch {
    throw new Error(`Error serializing ${propsType}. Check it has no circular references or reduce the size if the object is big.`);
  }
};
var getNeedsToUpload = ({
  type,
  sizes,
  providerSpecifics
}) => {
  const MARGIN = 5000 + MAX_WEBHOOK_CUSTOM_DATA_SIZE;
  const MAX_INLINE_PAYLOAD_SIZE = (type === "still" ? providerSpecifics.getMaxStillInlinePayloadSize() : providerSpecifics.getMaxNonInlinePayloadSizePerFunction()) - MARGIN;
  const sizesAlreadyUsed = sizes.reduce((a, b) => a + b);
  if (sizesAlreadyUsed > MAX_INLINE_PAYLOAD_SIZE) {
    console.warn(`Warning: The props are over ${Math.round(MAX_INLINE_PAYLOAD_SIZE / 1000)}KB (${Math.ceil(sizesAlreadyUsed / 1024)}KB) in size. Uploading them to ${providerSpecifics.serverStorageProductName()} to circumvent AWS Lambda payload size, which may lead to slowdown.`);
    return true;
  }
  return false;
};
var compressInputProps = async ({
  stringifiedInputProps,
  region,
  userSpecifiedBucketName,
  propsType,
  needsToUpload,
  providerSpecifics,
  forcePathStyle,
  skipPutAcl,
  requestHandler
}) => {
  const hash = providerSpecifics.randomHash();
  if (needsToUpload) {
    const bucketName = userSpecifiedBucketName ?? (await internalGetOrCreateBucket({
      region,
      enableFolderExpiry: null,
      customCredentials: null,
      providerSpecifics,
      forcePathStyle,
      skipPutAcl,
      requestHandler
    })).bucketName;
    await providerSpecifics.writeFile({
      body: stringifiedInputProps,
      bucketName,
      region,
      customCredentials: null,
      downloadBehavior: null,
      expectedBucketOwner: null,
      key: makeKey(propsType, hash),
      privacy: "private",
      forcePathStyle,
      storageClass: null,
      requestHandler
    });
    return {
      type: "bucket-url",
      hash,
      bucketName
    };
  }
  return {
    type: "payload",
    payload: stringifiedInputProps
  };
};
var decompressInputProps = async ({
  serialized,
  region,
  bucketName,
  expectedBucketOwner,
  propsType,
  providerSpecifics,
  forcePathStyle,
  requestHandler
}) => {
  if (serialized.type === "payload") {
    return serialized.payload;
  }
  try {
    const response = await providerSpecifics.readFile({
      bucketName,
      expectedBucketOwner,
      key: makeKey(propsType, serialized.hash),
      region,
      forcePathStyle,
      requestHandler
    });
    const body = await streamToString(response);
    const payload = body;
    return payload;
  } catch (err) {
    throw new Error(`Failed to parse input props that were serialized: ${err.stack}`);
  }
};
// src/docs-url.ts
var DOCS_URL = "https://remotion.dev";
// src/error-category.ts
var errorIsOutOfSpaceError = (err) => {
  return err.includes("ENOSPC") || err.toLowerCase().includes("no space left on device");
};
var isErrInsufficientResourcesErr = (err) => {
  return err.includes("net::ERR_INSUFFICIENT_RESOURCES");
};
var isBrowserCrashedError = (err) => {
  return err.includes("Target closed.") || err.includes("Session closed");
};
// src/estimate-price-from-bucket.ts
var estimatePriceFromMetadata = ({
  renderMetadata,
  memorySizeInMb,
  diskSizeInMb,
  functionsInvoked,
  timings,
  region,
  providerSpecifics
}) => {
  if (!renderMetadata) {
    return null;
  }
  const elapsedTime = Math.max(0, Date.now() - (renderMetadata?.startedDate ?? 0));
  const unfinished = Math.max(0, (renderMetadata?.totalChunks ?? 0) - timings.length);
  const timeElapsedOfUnfinished = new Array(unfinished).fill(true).map(() => elapsedTime).reduce((a, b) => a + b, 0);
  const estimatedBillingDurationInMilliseconds = calculateChunkTimes({
    type: "combined-time-for-cost-calculation",
    timings
  }) + timeElapsedOfUnfinished;
  const accruedSoFar = Number(providerSpecifics.estimatePrice({
    region,
    durationInMilliseconds: estimatedBillingDurationInMilliseconds,
    memorySizeInMb,
    diskSizeInMb,
    lambdasInvoked: functionsInvoked
  }).toPrecision(5));
  return { accruedSoFar, estimatedBillingDurationInMilliseconds };
};
// ../renderer/dist/esm/pure.mjs
var isAudioCodec = (codec) => {
  return codec === "mp3" || codec === "aac" || codec === "wav";
};
var support = {
  "h264-mkv": {
    audio: true,
    video: true
  },
  aac: {
    audio: true,
    video: false
  },
  gif: {
    video: true,
    audio: false
  },
  h264: {
    video: true,
    audio: true
  },
  "h264-ts": {
    video: true,
    audio: true
  },
  h265: {
    video: true,
    audio: true
  },
  mp3: {
    audio: true,
    video: false
  },
  prores: {
    audio: true,
    video: true
  },
  vp8: {
    audio: true,
    video: true
  },
  vp9: {
    audio: true,
    video: true
  },
  wav: {
    audio: true,
    video: false
  }
};
var codecSupportsMedia = (codec) => {
  return support[codec];
};
var getFramesToRender = (frameRange, everyNthFrame) => {
  if (everyNthFrame === 0) {
    throw new Error("everyNthFrame cannot be 0");
  }
  return new Array(frameRange[1] - frameRange[0] + 1).fill(true).map((_, index) => {
    return index + frameRange[0];
  }).filter((index) => {
    return index % everyNthFrame === 0;
  });
};
var validCodecs2 = [
  "h264",
  "h265",
  "vp8",
  "vp9",
  "mp3",
  "aac",
  "wav",
  "prores",
  "h264-mkv",
  "h264-ts",
  "gif"
];
var defaultFileExtensionMap = {
  "h264-mkv": {
    default: "mkv",
    forAudioCodec: {
      "pcm-16": { possible: ["mkv"], default: "mkv" },
      mp3: { possible: ["mkv"], default: "mkv" }
    }
  },
  "h264-ts": {
    default: "ts",
    forAudioCodec: {
      "pcm-16": { possible: ["ts"], default: "ts" },
      aac: { possible: ["ts"], default: "ts" }
    }
  },
  aac: {
    default: "aac",
    forAudioCodec: {
      aac: {
        possible: ["aac", "3gp", "m4a", "m4b", "mpg", "mpeg"],
        default: "aac"
      },
      "pcm-16": {
        possible: ["wav"],
        default: "wav"
      }
    }
  },
  gif: {
    default: "gif",
    forAudioCodec: {}
  },
  h264: {
    default: "mp4",
    forAudioCodec: {
      "pcm-16": { possible: ["mkv", "mov"], default: "mkv" },
      aac: { possible: ["mp4", "mkv", "mov"], default: "mp4" },
      mp3: { possible: ["mp4", "mkv", "mov"], default: "mp4" }
    }
  },
  h265: {
    default: "mp4",
    forAudioCodec: {
      aac: { possible: ["mp4", "mkv", "hevc"], default: "mp4" },
      "pcm-16": { possible: ["mkv"], default: "mkv" }
    }
  },
  mp3: {
    default: "mp3",
    forAudioCodec: {
      mp3: { possible: ["mp3"], default: "mp3" },
      "pcm-16": { possible: ["wav"], default: "wav" }
    }
  },
  prores: {
    default: "mov",
    forAudioCodec: {
      aac: { possible: ["mov", "mkv", "mxf"], default: "mov" },
      "pcm-16": { possible: ["mov", "mkv", "mxf"], default: "mov" }
    }
  },
  vp8: {
    default: "webm",
    forAudioCodec: {
      "pcm-16": { possible: ["mkv"], default: "mkv" },
      opus: { possible: ["webm"], default: "webm" }
    }
  },
  vp9: {
    default: "webm",
    forAudioCodec: {
      "pcm-16": { possible: ["mkv"], default: "mkv" },
      opus: { possible: ["webm"], default: "webm" }
    }
  },
  wav: {
    default: "wav",
    forAudioCodec: {
      "pcm-16": { possible: ["wav"], default: "wav" }
    }
  }
};
var getFileExtensionFromCodec = (codec, audioCodec) => {
  if (!validCodecs2.includes(codec)) {
    throw new Error(`Codec must be one of the following: ${validCodecs2.join(", ")}, but got ${codec}`);
  }
  const map = defaultFileExtensionMap[codec];
  if (audioCodec === null) {
    return map.default;
  }
  const typedAudioCodec = audioCodec;
  if (!(typedAudioCodec in map.forAudioCodec)) {
    throw new Error(`Audio codec ${typedAudioCodec} is not supported for codec ${codec}`);
  }
  return map.forAudioCodec[audioCodec].default;
};
var SLASH = 47;
var DOT = 46;
var assertPath = (path) => {
  const t = typeof path;
  if (t !== "string") {
    throw new TypeError(`Expected a string, got a ${t}`);
  }
};
var posixNormalize = (path, allowAboveRoot) => {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code;
  for (let i = 0;i <= path.length; ++i) {
    if (i < path.length) {
      code = path.charCodeAt(i);
    } else if (code === SLASH) {
      break;
    } else {
      code = SLASH;
    }
    if (code === SLASH) {
      if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== DOT || res.charCodeAt(res.length - 2) !== DOT) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += "/" + path.slice(lastSlash + 1, i);
        } else {
          res = path.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
};
var decode = (s) => {
  try {
    return decodeURIComponent(s);
  } catch {
    return s;
  }
};
var pathNormalize = (p) => {
  assertPath(p);
  let path = p;
  if (path.length === 0) {
    return ".";
  }
  const isAbsolute = path.charCodeAt(0) === SLASH;
  const trailingSeparator = path.charCodeAt(path.length - 1) === SLASH;
  path = decode(path);
  path = posixNormalize(path, !isAbsolute);
  if (path.length === 0 && !isAbsolute) {
    path = ".";
  }
  if (path.length > 0 && trailingSeparator) {
    path += "/";
  }
  if (isAbsolute) {
    return "/" + path;
  }
  return path;
};
var getExtensionOfFilename = (filename) => {
  if (filename === null) {
    return null;
  }
  const filenameArr = pathNormalize(filename).split(".");
  const hasExtension = filenameArr.length >= 2;
  const filenameArrLength = filenameArr.length;
  const extension = hasExtension ? filenameArr[filenameArrLength - 1] : null;
  return extension;
};
var DEFAULT = null;
var cliFlag = "separate-audio-to";
var separateAudioOption = {
  cliFlag,
  description: () => `If set, the audio will not be included in the main output but rendered as a separate file at the location you pass. It is recommended to use an absolute path. If a relative path is passed, it is relative to the Remotion Root.`,
  docLink: "https://remotion.dev/docs/renderer/render-media",
  getValue: ({ commandLine }) => {
    if (commandLine[cliFlag]) {
      return {
        source: "cli",
        value: commandLine[cliFlag]
      };
    }
    return {
      source: "default",
      value: DEFAULT
    };
  },
  name: "Separate audio to",
  setConfig: () => {
    throw new Error("Not implemented");
  },
  ssrName: "separateAudioTo",
  type: "string"
};
var validAudioCodecs = ["pcm-16", "aac", "mp3", "opus"];
var supportedAudioCodecs = {
  h264: ["aac", "pcm-16", "mp3"],
  "h264-mkv": ["pcm-16", "mp3"],
  "h264-ts": ["pcm-16", "aac"],
  aac: ["aac", "pcm-16"],
  avi: [],
  gif: [],
  h265: ["aac", "pcm-16"],
  mp3: ["mp3", "pcm-16"],
  prores: ["aac", "pcm-16"],
  vp8: ["opus", "pcm-16"],
  vp9: ["opus", "pcm-16"],
  wav: ["pcm-16"]
};
var _satisfies = supportedAudioCodecs;
if (_satisfies) {}
var cliFlag2 = "audio-codec";
var ssrName = "audioCodec";
var defaultAudioCodecs = {
  "h264-mkv": {
    lossless: "pcm-16",
    compressed: "pcm-16"
  },
  "h264-ts": {
    lossless: "pcm-16",
    compressed: "aac"
  },
  aac: {
    lossless: "pcm-16",
    compressed: "aac"
  },
  gif: {
    lossless: null,
    compressed: null
  },
  h264: {
    lossless: "pcm-16",
    compressed: "aac"
  },
  h265: {
    lossless: "pcm-16",
    compressed: "aac"
  },
  mp3: {
    lossless: "pcm-16",
    compressed: "mp3"
  },
  prores: {
    lossless: "pcm-16",
    compressed: "pcm-16"
  },
  vp8: {
    lossless: "pcm-16",
    compressed: "opus"
  },
  vp9: {
    lossless: "pcm-16",
    compressed: "opus"
  },
  wav: {
    lossless: "pcm-16",
    compressed: "pcm-16"
  }
};
var extensionMap = {
  aac: "aac",
  mp3: "mp3",
  opus: "opus",
  "pcm-16": "wav"
};
var resolveAudioCodec = ({
  codec,
  setting,
  preferLossless,
  separateAudioTo
}) => {
  let derivedFromSeparateAudioToExtension = null;
  if (separateAudioTo) {
    const extension = separateAudioTo.split(".").pop();
    for (const [key, value] of Object.entries(extensionMap)) {
      if (value === extension) {
        derivedFromSeparateAudioToExtension = key;
        if (!supportedAudioCodecs[codec].includes(derivedFromSeparateAudioToExtension) && derivedFromSeparateAudioToExtension) {
          throw new Error(`The codec is ${codec} but the audio codec derived from --${separateAudioOption.cliFlag} is ${derivedFromSeparateAudioToExtension}. The only supported codecs are: ${supportedAudioCodecs[codec].join(", ")}`);
        }
      }
    }
  }
  if (preferLossless) {
    const selected = getDefaultAudioCodec({ codec, preferLossless });
    if (derivedFromSeparateAudioToExtension && selected !== derivedFromSeparateAudioToExtension) {
      throw new Error(`The audio codec derived from --${separateAudioOption.cliFlag} is ${derivedFromSeparateAudioToExtension}, but does not match the audio codec derived from the "Prefer lossless" option (${selected}). Remove any conflicting options.`);
    }
    return selected;
  }
  if (setting === null) {
    if (derivedFromSeparateAudioToExtension) {
      return derivedFromSeparateAudioToExtension;
    }
    return getDefaultAudioCodec({ codec, preferLossless });
  }
  if (derivedFromSeparateAudioToExtension !== setting && derivedFromSeparateAudioToExtension) {
    throw new Error(`The audio codec derived from --${separateAudioOption.cliFlag} is ${derivedFromSeparateAudioToExtension}, but does not match the audio codec derived from your ${audioCodecOption.name} setting (${setting}). Remove any conflicting options.`);
  }
  return setting;
};
var getDefaultAudioCodec = ({
  codec,
  preferLossless
}) => {
  return defaultAudioCodecs[codec][preferLossless ? "lossless" : "compressed"];
};
var _audioCodec = null;
var audioCodecOption = {
  cliFlag: cliFlag2,
  setConfig: (audioCodec) => {
    if (audioCodec === null) {
      _audioCodec = null;
      return;
    }
    if (!validAudioCodecs.includes(audioCodec)) {
      throw new Error(`Audio codec must be one of the following: ${validAudioCodecs.join(", ")}, but got ${audioCodec}`);
    }
    _audioCodec = audioCodec;
  },
  getValue: ({ commandLine }) => {
    if (commandLine[cliFlag2]) {
      const codec = commandLine[cliFlag2];
      if (!validAudioCodecs.includes(commandLine[cliFlag2])) {
        throw new Error(`Audio codec must be one of the following: ${validAudioCodecs.join(", ")}, but got ${codec}`);
      }
      return {
        source: "cli",
        value: commandLine[cliFlag2]
      };
    }
    if (_audioCodec !== null) {
      return {
        source: "config",
        value: _audioCodec
      };
    }
    return {
      source: "default",
      value: null
    };
  },
  description: () => `Set the format of the audio that is embedded in the video. Not all codec and audio codec combinations are supported and certain combinations require a certain file extension and container format. See the table in the docs to see possible combinations.`,
  docLink: "https://www.remotion.dev/docs/encoding/#audio-codec",
  name: "Audio Codec",
  ssrName,
  type: "aac"
};
var validateOutputFilename = ({
  codec,
  audioCodecSetting,
  extension,
  preferLossless,
  separateAudioTo
}) => {
  if (!defaultFileExtensionMap[codec]) {
    throw new TypeError(`The codec "${codec}" is not supported. Supported codecs are: ${Object.keys(defaultFileExtensionMap).join(", ")}`);
  }
  const map = defaultFileExtensionMap[codec];
  const resolvedAudioCodec = resolveAudioCodec({
    codec,
    preferLossless,
    setting: audioCodecSetting,
    separateAudioTo
  });
  if (resolvedAudioCodec === null) {
    if (extension !== map.default) {
      throw new TypeError(`When using the ${codec} codec, the output filename must end in .${map.default}.`);
    }
    return;
  }
  if (!(resolvedAudioCodec in map.forAudioCodec)) {
    throw new Error(`Audio codec ${resolvedAudioCodec} is not supported for codec ${codec}`);
  }
  const acceptableExtensions = map.forAudioCodec[resolvedAudioCodec].possible;
  if (!acceptableExtensions.includes(extension) && !separateAudioTo) {
    throw new TypeError(`When using the ${codec} codec with the ${resolvedAudioCodec} audio codec, the output filename must end in one of the following: ${acceptableExtensions.join(", ")}.`);
  }
};
var NoReactAPIs = {
  getExtensionOfFilename,
  getFileExtensionFromCodec,
  validateOutputFilename,
  getFramesToRender,
  codecSupportsMedia,
  isAudioCodec
};

// src/get-custom-out-name.ts
var getCustomOutName = ({
  renderMetadata,
  customCredentials
}) => {
  if (!renderMetadata.outName) {
    return null;
  }
  if (typeof renderMetadata.outName === "string") {
    return renderMetadata.outName;
  }
  if (renderMetadata.outName.s3OutputProvider) {
    if (!customCredentials && renderMetadata.privacy === "private") {
      throw new TypeError(`The file was rendered with a custom S3 implementation and is not public, but no custom credentials were passed to downloadMedia().`);
    }
    return {
      bucketName: renderMetadata.outName.bucketName,
      key: renderMetadata.outName.key,
      s3OutputProvider: {
        endpoint: renderMetadata.outName.s3OutputProvider.endpoint,
        accessKeyId: customCredentials?.accessKeyId ?? null,
        secretAccessKey: customCredentials?.secretAccessKey ?? null,
        region: customCredentials?.region,
        forcePathStyle: customCredentials?.forcePathStyle ?? false
      }
    };
  }
  return {
    bucketName: renderMetadata.outName.bucketName,
    key: renderMetadata.outName.key
  };
};

// src/validate-bucket-name.ts
var validateBucketName = ({
  bucketName,
  bucketNamePrefix,
  options
}) => {
  if (typeof bucketName !== "string") {
    throw new TypeError(`'bucketName' must be a string, but is ${JSON.stringify(bucketName)}`);
  }
  if (options.mustStartWithRemotion && !bucketName.startsWith(bucketNamePrefix)) {
    throw new Error(`The bucketName parameter must start with ${bucketNamePrefix}.`);
  }
  if (!bucketName.match(/^(?=^.{3,63}$)(?!^(\d+\.)+\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)*([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$)/)) {
    throw new Error(`The bucket ${bucketName} `);
  }
};

// src/validate-outname.ts
var validateS3Key = (s3Key) => {
  if (typeof s3Key !== "string") {
    throw new TypeError("The S3 key must be a string. Passed an object of type " + typeof s3Key);
  }
  if (!s3Key.match(/^([0-9a-zA-Z-!_.*'()/:&$@=;+,?]+)/g)) {
    throw new Error("The S3 Key must match the RegExp `/^([0-9a-zA-Z-!_.*'()/:&$@=;+,?]+)/g`. You passed: " + s3Key + ". Check for invalid characters.");
  }
};
var validateOutname = ({
  outName: outName2,
  codec,
  audioCodecSetting,
  separateAudioTo,
  bucketNamePrefix
}) => {
  if (typeof outName2 === "undefined" || outName2 === null) {
    return;
  }
  if (typeof outName2 !== "string") {
    validateS3Key(outName2.key);
    validateBucketName({
      bucketName: outName2.bucketName,
      bucketNamePrefix,
      options: {
        mustStartWithRemotion: false
      }
    });
    return;
  }
  if (codec) {
    NoReactAPIs.validateOutputFilename({
      codec,
      audioCodecSetting,
      extension: NoReactAPIs.getExtensionOfFilename(outName2),
      preferLossless: false,
      separateAudioTo
    });
  }
  validateS3Key(outName2);
};

// src/expected-out-name.ts
var getCredentialsFromOutName = (name) => {
  if (typeof name === "string") {
    return null;
  }
  if (name === null) {
    return null;
  }
  if (typeof name === "undefined") {
    return null;
  }
  return name.s3OutputProvider ?? null;
};
var getExpectedOutName = ({
  renderMetadata,
  bucketName,
  customCredentials,
  bucketNamePrefix
}) => {
  const outNameValue = getCustomOutName({
    customCredentials,
    renderMetadata
  });
  if (outNameValue) {
    validateOutname({
      outName: outNameValue,
      codec: renderMetadata.codec,
      audioCodecSetting: renderMetadata.audioCodec,
      separateAudioTo: null,
      bucketNamePrefix
    });
    return customOutName(renderMetadata.renderId, bucketName, outNameValue);
  }
  if (renderMetadata.type === "still") {
    return {
      renderBucketName: bucketName,
      key: outStillName(renderMetadata.renderId, renderMetadata.imageFormat),
      customCredentials: null
    };
  }
  if (renderMetadata.type === "video") {
    return {
      renderBucketName: bucketName,
      key: outName(renderMetadata.renderId, NoReactAPIs.getFileExtensionFromCodec(renderMetadata.codec, renderMetadata.audioCodec)),
      customCredentials: null
    };
  }
  throw new TypeError("no type passed");
};
// src/format-costs-info.ts
var display = (accrued) => {
  if (accrued < 0.001) {
    return "<$0.001";
  }
  return new Intl.NumberFormat("en-US", {
    currency: "USD",
    style: "currency",
    currencyDisplay: "narrowSymbol",
    minimumFractionDigits: 3
  }).format(accrued);
};
var formatCostsInfo = (accrued) => {
  return {
    accruedSoFar: accrued,
    displayCost: display(accrued),
    currency: "USD",
    disclaimer: "Estimated cost only. Does not include charges for other AWS services."
  };
};
// src/get-overall-progress-from-storage.ts
var getOverallProgressFromStorage = async ({
  renderId,
  bucketName,
  expectedBucketOwner,
  region,
  providerSpecifics,
  forcePathStyle,
  requestHandler
}) => {
  try {
    const Body = await providerSpecifics.readFile({
      bucketName,
      key: overallProgressKey(renderId),
      expectedBucketOwner,
      region,
      forcePathStyle,
      requestHandler
    });
    const str = await streamToString(Body);
    return JSON.parse(str);
  } catch (err) {
    if (err.name === "NotFound") {
      throw new TypeError(`No render with ID "${renderId}" found in bucket ${bucketName} and region ${region}`);
    }
    throw err;
  }
};
// src/inspect-error.ts
var FAILED_TO_LAUNCH_TOKEN = "Failed to launch browser.";
var getExplanation = (stack) => {
  if (stack.includes("FATAL:zygote_communication_linux.cc")) {
    return FAILED_TO_LAUNCH_TOKEN + " Will be retried - you can probably ignore this error.";
  }
  if (stack.includes("error while loading shared libraries: libnss3.so")) {
    return FAILED_TO_LAUNCH_TOKEN + " Will be retried - you can probably ignore this error.";
  }
  if (stack.includes("TooManyRequestsException") || stack.includes("ConcurrentInvocationLimitExceeded")) {
    return `AWS returned an "TooManyRequestsException" error message which could mean you reached the concurrency limit of AWS Lambda. You can increase the limit - read this troubleshooting page: ${DOCS_URL}/docs/lambda/troubleshooting/rate-limit`;
  }
  if (errorIsOutOfSpaceError(stack)) {
    return `Your lambda function reached the storage limit. Reduce the amount of space needed per lambda function or increase the storage limit: ${DOCS_URL}/docs/lambda/disk-size.`;
  }
  if (isErrInsufficientResourcesErr(stack)) {
    return "The lambda ran out of memory. Deploy a new function with more memory.";
  }
  if (isBrowserCrashedError(stack)) {
    return "The browser crashed while rendering the video. Deploy a new function with memory to give the browser more resources.";
  }
  return null;
};
var inspectErrors = ({
  errors
}) => {
  return errors.map((e) => {
    return {
      ...e,
      explanation: getExplanation(e.stack),
      s3Location: ""
    };
  });
};
// src/most-expensive-chunks.ts
var OVERHEAD_TIME_PER_LAMBDA = 100;
var getMostExpensiveChunks = ({
  parsedTimings,
  framesPerFunction: framesPerLambda,
  firstFrame,
  lastFrame
}) => {
  const mostExpensiveChunks = parsedTimings.slice(0).sort((a, b) => {
    const durA = a.rendered - a.start;
    const durB = b.rendered - b.start;
    return durB - durA;
  }).slice(0, 5);
  return mostExpensiveChunks.map((c) => {
    const isLastChunk = c.chunk === parsedTimings.length - 1;
    return {
      timeInMilliseconds: c.rendered - c.start,
      chunk: c.chunk,
      frameRange: [
        framesPerLambda * c.chunk + firstFrame,
        isLastChunk ? lastFrame : framesPerLambda * (c.chunk + 1) - 1 + firstFrame
      ]
    };
  });
};
// src/get-overall-progress.ts
var weights = {
  evaluating: 0.1,
  encoding: 0.1,
  frames: 0.6,
  invoking: 0.1,
  combining: 0.1
};
var getOverallProgress = ({
  encoding,
  invoking,
  frames,
  invokedLambda,
  visitedServeUrl,
  gotComposition,
  combining
}) => {
  const evaluationProgress = [
    Boolean(invokedLambda),
    Boolean(visitedServeUrl),
    Boolean(gotComposition)
  ].reduce((a, b) => Number(a) + Number(b), 0) / 3;
  return evaluationProgress * weights.evaluating + encoding * weights.encoding + invoking * weights.invoking + frames * weights.frames + combining * weights.combining;
};

// src/make-timeout-message.ts
var MAX_MISSING_CHUNKS = 5;
var makeChunkMissingMessage = ({
  missingChunks,
  renderMetadata,
  region,
  providerSpecifics,
  functionName
}) => {
  if (missingChunks.length === 0) {
    return "All chunks have been successfully rendered, but the main function has timed out.";
  }
  return [
    `The following chunks are missing (showing ${Math.min(MAX_MISSING_CHUNKS, missingChunks.length)} out of ${missingChunks.length}):`,
    ...missingChunks.map((ch) => {
      const isLastChunk = ch === renderMetadata.totalChunks - 1;
      const start = ch * renderMetadata.framesPerLambda;
      const end = renderMetadata.type === "still" ? 0 : isLastChunk ? renderMetadata.frameRange[1] : (ch + 1) * renderMetadata.framesPerLambda - 1;
      const msg = `Chunk ${ch} (Frames ${start} - ${end})`;
      return [
        msg,
        `▸ Logs for chunk ${ch}: ${providerSpecifics.getLoggingUrlForRendererFunction({
          functionName,
          region,
          rendererFunctionName: null,
          renderId: renderMetadata.renderId,
          chunk: ch
        })}`
      ].join(`
`);
    }).slice(0, 5)
  ].join(`
`);
};
var makeTimeoutMessage = ({
  timeoutInMilliseconds,
  missingChunks,
  renderMetadata,
  renderId,
  functionName,
  region,
  providerSpecifics
}) => {
  const cloudWatchRendererUrl = providerSpecifics.getLoggingUrlForRendererFunction({
    renderId,
    functionName,
    region,
    rendererFunctionName: functionName,
    chunk: null
  });
  const cloudWatchLaunchUrl = providerSpecifics.getLoggingUrlForMethod({
    renderId,
    functionName,
    method: "launch" /* launch */,
    region,
    rendererFunctionName: functionName
  });
  const message = [
    `The main function timed out after ${timeoutInMilliseconds}ms.`,
    makeChunkMissingMessage({
      missingChunks,
      renderMetadata,
      region,
      providerSpecifics,
      functionName
    }),
    "",
    `Consider increasing the timeout of your function.`,
    `▸ You can use the "--timeout" parameter when deploying a function via CLI, or the "timeoutInSeconds" parameter when using the deployFunction() API.`,
    `${DOCS_URL}/docs/lambda/cli/functions/deploy`,
    "",
    "▸ Visit the logs for the main function:",
    cloudWatchLaunchUrl,
    "▸ Visit the logs for the renderer functions:",
    cloudWatchRendererUrl,
    "",
    "▸ Get help on debugging this error:",
    `${DOCS_URL}/docs/lambda/troubleshooting/debug`
  ].join(`
`);
  return message;
};

// src/make-timeout-error.ts
var makeTimeoutError = ({
  timeoutInMilliseconds,
  missingChunks,
  renderMetadata,
  renderId,
  functionName,
  region,
  providerSpecifics
}) => {
  const message = makeTimeoutMessage({
    missingChunks,
    renderMetadata,
    timeoutInMilliseconds,
    renderId,
    functionName,
    region,
    providerSpecifics
  });
  const error = new Error(message);
  return {
    attempt: 1,
    chunk: null,
    explanation: null,
    frame: null,
    isFatal: true,
    s3Location: "",
    stack: error.stack,
    tmpDir: null,
    totalAttempts: 1,
    type: "stitcher",
    willRetry: false,
    message,
    name: "TimeoutError"
  };
};

// src/render-has-audio-video.ts
var lambdaRenderHasAudioVideo = (renderMetadata) => {
  if (renderMetadata.type === "still") {
    throw new Error("Cannot merge stills");
  }
  const support2 = NoReactAPIs.codecSupportsMedia(renderMetadata.codec);
  const hasVideo = renderMetadata ? !NoReactAPIs.isAudioCodec(renderMetadata.codec) : false;
  const hasAudio = renderMetadata ? !renderMetadata.muted && support2.audio : false;
  return {
    hasAudio,
    hasVideo
  };
};

// src/truthy.ts
function truthy3(value) {
  return Boolean(value);
}

// src/progress.ts
var getProgress = async ({
  bucketName,
  renderId,
  expectedBucketOwner,
  region,
  memorySizeInMb,
  timeoutInMilliseconds,
  customCredentials,
  providerSpecifics,
  forcePathStyle,
  functionName,
  requestHandler
}) => {
  const overallProgress = await getOverallProgressFromStorage({
    renderId,
    bucketName,
    expectedBucketOwner,
    region,
    providerSpecifics,
    forcePathStyle,
    requestHandler
  });
  if (overallProgress.postRenderData) {
    if (!overallProgress.renderMetadata) {
      throw new Error("No render metadata found even though render is finished");
    }
    if (overallProgress.renderMetadata.type === "still") {
      throw new Error("You don't need to call getRenderProgress() on a still render. Once you have obtained the `renderId`, the render is already done! \uD83D\uDE09");
    }
    const outData = getExpectedOutName({
      renderMetadata: overallProgress.renderMetadata,
      bucketName,
      customCredentials,
      bucketNamePrefix: providerSpecifics.getBucketPrefix()
    });
    const totalFrameCount = NoReactAPIs.getFramesToRender(overallProgress.renderMetadata.frameRange, overallProgress.renderMetadata.everyNthFrame).length;
    return {
      framesRendered: totalFrameCount,
      bucket: bucketName,
      renderSize: overallProgress.postRenderData.renderSize,
      chunks: overallProgress.renderMetadata.totalChunks,
      cleanup: {
        doneIn: overallProgress.postRenderData.timeToCleanUp,
        filesDeleted: overallProgress.postRenderData.filesCleanedUp,
        minFilesToDelete: overallProgress.postRenderData.filesCleanedUp
      },
      costs: {
        accruedSoFar: overallProgress.postRenderData.cost.estimatedCost,
        displayCost: overallProgress.postRenderData.cost.estimatedDisplayCost,
        currency: overallProgress.postRenderData.cost.currency,
        disclaimer: overallProgress.postRenderData.cost.disclaimer
      },
      currentTime: Date.now(),
      done: true,
      encodingStatus: {
        framesEncoded: totalFrameCount,
        combinedFrames: totalFrameCount,
        timeToCombine: overallProgress.postRenderData.timeToCombine
      },
      errors: overallProgress.postRenderData.errors,
      fatalErrorEncountered: false,
      lambdasInvoked: overallProgress.renderMetadata.totalChunks,
      outputFile: overallProgress.postRenderData.outputFile,
      renderId,
      timeToFinish: overallProgress.postRenderData.timeToFinish,
      timeToFinishChunks: overallProgress.postRenderData.timeToRenderChunks,
      timeToRenderFrames: overallProgress.postRenderData.timeToRenderFrames,
      overallProgress: 1,
      retriesInfo: overallProgress.postRenderData.retriesInfo,
      outKey: outData.key,
      outBucket: outData.renderBucketName,
      mostExpensiveFrameRanges: overallProgress.postRenderData.mostExpensiveFrameRanges ?? null,
      timeToEncode: overallProgress.postRenderData.timeToEncode,
      outputSizeInBytes: overallProgress.postRenderData.outputSize,
      type: "success",
      estimatedBillingDurationInMilliseconds: overallProgress.postRenderData.estimatedBillingDurationInMilliseconds,
      timeToCombine: overallProgress.postRenderData.timeToCombine,
      combinedFrames: totalFrameCount,
      renderMetadata: overallProgress.renderMetadata,
      timeoutTimestamp: overallProgress.timeoutTimestamp,
      compositionValidated: overallProgress.compositionValidated,
      functionLaunched: overallProgress.functionLaunched,
      serveUrlOpened: overallProgress.serveUrlOpened,
      artifacts: overallProgress.receivedArtifact
    };
  }
  const { renderMetadata } = overallProgress;
  const errorExplanations = inspectErrors({
    errors: overallProgress.errors
  });
  const { hasAudio, hasVideo } = renderMetadata ? lambdaRenderHasAudioVideo(renderMetadata) : { hasAudio: false, hasVideo: false };
  const chunkCount = overallProgress.chunks.length ?? 0;
  const cleanup = {
    doneIn: null,
    minFilesToDelete: 0,
    filesDeleted: 0
  };
  if (renderMetadata === null) {
    return {
      framesRendered: overallProgress.framesRendered ?? 0,
      chunks: chunkCount,
      done: false,
      encodingStatus: {
        framesEncoded: overallProgress.framesEncoded,
        combinedFrames: overallProgress.combinedFrames,
        timeToCombine: overallProgress.timeToCombine
      },
      timeToRenderFrames: overallProgress.timeToRenderFrames,
      costs: formatCostsInfo(0),
      renderId,
      renderMetadata,
      bucket: bucketName,
      outputFile: null,
      timeToFinish: null,
      errors: errorExplanations,
      fatalErrorEncountered: errorExplanations.some((f) => f.isFatal && !f.willRetry),
      currentTime: Date.now(),
      renderSize: 0,
      lambdasInvoked: overallProgress.lambdasInvoked ?? 0,
      cleanup,
      timeToFinishChunks: null,
      overallProgress: getOverallProgress({
        encoding: 0,
        invoking: 0,
        frames: 0,
        gotComposition: overallProgress.compositionValidated,
        visitedServeUrl: overallProgress.serveUrlOpened,
        invokedLambda: overallProgress.lambdasInvoked,
        combining: 0
      }),
      retriesInfo: overallProgress.retries ?? [],
      outKey: null,
      outBucket: null,
      mostExpensiveFrameRanges: null,
      timeToEncode: overallProgress.timeToEncode,
      outputSizeInBytes: null,
      estimatedBillingDurationInMilliseconds: null,
      combinedFrames: overallProgress.combinedFrames ?? 0,
      timeToCombine: overallProgress.timeToCombine ?? null,
      timeoutTimestamp: overallProgress.timeoutTimestamp,
      type: "success",
      compositionValidated: overallProgress.compositionValidated,
      functionLaunched: overallProgress.functionLaunched,
      serveUrlOpened: overallProgress.serveUrlOpened,
      artifacts: overallProgress.receivedArtifact
    };
  }
  const priceFromBucket = estimatePriceFromMetadata({
    renderMetadata,
    memorySizeInMb: providerSpecifics.parseFunctionName(renderMetadata.rendererFunctionName)?.memorySizeInMb ?? memorySizeInMb,
    functionsInvoked: renderMetadata.estimatedRenderLambdaInvokations ?? 0,
    diskSizeInMb: providerSpecifics.getEphemeralStorageForPriceCalculation(),
    timings: overallProgress.timings ?? [],
    region,
    providerSpecifics
  });
  const chunkMultiplier = [hasAudio, hasVideo].filter(truthy3).length;
  if (renderMetadata.type === "still") {
    throw new Error("You don't need to call getRenderProgress() on a still render. Once you have obtained the `renderId`, the render is already done! \uD83D\uDE09");
  }
  const allChunks = (overallProgress.chunks ?? []).length / chunkMultiplier === (renderMetadata.totalChunks ?? Infinity);
  const frameCount = NoReactAPIs.getFramesToRender(renderMetadata.frameRange, renderMetadata.everyNthFrame).length;
  const missingChunks = new Array(renderMetadata.totalChunks).fill(true).map((_, i) => i).filter((index) => {
    return typeof (overallProgress.chunks ?? []).find((c) => c === index) === "undefined";
  });
  const isBeyondTimeoutAndMissingChunks = Date.now() > renderMetadata.startedDate + timeoutInMilliseconds + 20000 && missingChunks && missingChunks.length > 0;
  const isBeyondTimeoutAndHasStitchTimeout = Date.now() > renderMetadata.startedDate + timeoutInMilliseconds * 2 + 20000;
  const allErrors = [
    isBeyondTimeoutAndMissingChunks || isBeyondTimeoutAndHasStitchTimeout ? makeTimeoutError({
      timeoutInMilliseconds,
      renderMetadata,
      renderId,
      missingChunks: missingChunks ?? [],
      region,
      functionName,
      providerSpecifics
    }) : null,
    ...errorExplanations
  ].filter(truthy3);
  return {
    framesRendered: overallProgress.framesRendered ?? 0,
    chunks: chunkCount,
    done: false,
    encodingStatus: {
      framesEncoded: overallProgress.framesEncoded,
      combinedFrames: overallProgress.combinedFrames,
      timeToCombine: overallProgress.timeToCombine
    },
    timeToRenderFrames: overallProgress.timeToRenderFrames,
    costs: priceFromBucket ? formatCostsInfo(priceFromBucket.accruedSoFar) : formatCostsInfo(0),
    renderId,
    renderMetadata,
    bucket: bucketName,
    outputFile: null,
    timeToFinish: null,
    errors: allErrors,
    fatalErrorEncountered: allErrors.some((f) => f.isFatal && !f.willRetry),
    currentTime: Date.now(),
    renderSize: 0,
    lambdasInvoked: overallProgress.lambdasInvoked ?? 0,
    cleanup,
    timeToFinishChunks: allChunks && overallProgress ? calculateChunkTimes({
      type: "absolute-time",
      timings: overallProgress.timings
    }) : null,
    overallProgress: getOverallProgress({
      encoding: frameCount ? (overallProgress.framesEncoded ?? 0) / frameCount : 0,
      invoking: (overallProgress.lambdasInvoked ?? 0) / renderMetadata.estimatedRenderLambdaInvokations,
      frames: (overallProgress.framesRendered ?? 0) / (frameCount ?? 1),
      gotComposition: overallProgress.compositionValidated,
      visitedServeUrl: overallProgress.serveUrlOpened,
      invokedLambda: overallProgress.lambdasInvoked,
      combining: overallProgress.combinedFrames / (frameCount ?? 1)
    }),
    retriesInfo: overallProgress.retries ?? [],
    outKey: null,
    outBucket: null,
    mostExpensiveFrameRanges: null,
    timeToEncode: overallProgress.timeToEncode,
    outputSizeInBytes: null,
    estimatedBillingDurationInMilliseconds: priceFromBucket ? priceFromBucket.estimatedBillingDurationInMilliseconds : null,
    combinedFrames: overallProgress.combinedFrames ?? 0,
    timeToCombine: overallProgress.timeToCombine ?? null,
    timeoutTimestamp: overallProgress.timeoutTimestamp,
    type: "success",
    compositionValidated: overallProgress.compositionValidated,
    functionLaunched: overallProgress.functionLaunched,
    serveUrlOpened: overallProgress.serveUrlOpened,
    artifacts: overallProgress.receivedArtifact
  };
};
// src/streaming/streaming.ts
var framesRendered = "frames-rendered";
var errorOccurred = "error-occurred";
var renderIdDetermined = "render-id-determined";
var videoChunkRendered = "video-chunk-rendered";
var audioChunkRendered = "audio-chunk-rendered";
var chunkComplete = "chunk-complete";
var stillRendered = "still-rendered";
var functionInvoked = "lambda-invoked";
var artifactEmitted = "artifact-emitted";
var messageTypes = {
  "1": { type: framesRendered },
  "2": { type: errorOccurred },
  "3": { type: renderIdDetermined },
  "4": { type: videoChunkRendered },
  "5": { type: audioChunkRendered },
  "6": { type: stillRendered },
  "7": { type: chunkComplete },
  "8": { type: functionInvoked },
  "9": { type: artifactEmitted }
};
var formatMap = {
  [framesRendered]: "json",
  [errorOccurred]: "json",
  [renderIdDetermined]: "json",
  [videoChunkRendered]: "binary",
  [audioChunkRendered]: "binary",
  [stillRendered]: "json",
  [chunkComplete]: "json",
  [functionInvoked]: "json",
  [artifactEmitted]: "json"
};
var messageTypeIdToMessageType = (messageTypeId) => {
  const types = messageTypes[messageTypeId];
  if (!types) {
    throw new Error(`Unknown message type id ${messageTypeId}`);
  }
  return types.type;
};
var messageTypeToMessageId = (messageType) => {
  const id = Object.keys(messageTypes).find((key) => messageTypes[key].type === messageType);
  if (!id) {
    throw new Error(`Unknown message type ${messageType}`);
  }
  return id;
};
var makeStreamPayload = ({
  message
}) => {
  const body = formatMap[message.type] === "json" ? new TextEncoder().encode(JSON.stringify(message.payload)) : message.payload;
  return makeStreamPayloadMessage({
    body,
    nonce: messageTypeToMessageId(message.type),
    status: 0
  });
};
// src/validate-privacy.ts
function validatePrivacy(privacy, allowPrivate) {
  if (typeof privacy !== "string") {
    throw new TypeError("Privacy must be a string");
  }
  if (!allowPrivate && privacy === "private") {
    throw new TypeError('Privacy must be either "public" or "no-acl"');
  }
  if (privacy !== "private" && privacy !== "public" && privacy !== "no-acl") {
    throw new TypeError('Privacy must be either "private", "public" or "no-acl"');
  }
}
// src/index.ts
var {
  ENABLE_V5_BREAKING_CHANGES: ENABLE_V5_BREAKING_CHANGES2,
  serializeJSONWithSpecialTypes: serializeJSONWithSpecialTypes2,
  validateFps: validateFps2,
  validateDimension: validateDimension2,
  validateDurationInFrames: validateDurationInFrames2,
  validateCodec: validateCodec2
} = NoReactInternals;
export {
  wrapWithErrorHandling,
  validateWebhook,
  validatePrivacy,
  validateOutname,
  validateFramesPerFunction,
  validateFps2 as validateFps,
  validateDurationInFrames2 as validateDurationInFrames,
  validateDownloadBehavior,
  validateDimension2 as validateDimension,
  validateCodec2 as validateCodec,
  validateBucketName,
  truthy3 as truthy,
  streamToString,
  serverlessCodecs,
  serializeOrThrow,
  serializeJSONWithSpecialTypes2 as serializeJSONWithSpecialTypes,
  serializeArtifact,
  resolvedPropsKey,
  rendersPrefix,
  random,
  overallProgressKey,
  outStillName,
  outName,
  messageTypeIdToMessageType,
  makeStreamer,
  makeStreamPayloadMessage,
  makeStreamPayload,
  makeBucketName,
  isErrInsufficientResourcesErr,
  isBrowserCrashedError,
  interpolate,
  internalGetOrCreateBucket,
  inspectErrors,
  inputPropsKey,
  getProgress,
  getOverallProgressFromStorage,
  getNeedsToUpload,
  getMostExpensiveChunks,
  getExpectedOutName,
  getCredentialsFromOutName,
  formatMap,
  formatCostsInfo,
  expiryDays,
  estimatePriceFromMetadata,
  errorIsOutOfSpaceError,
  deserializeArtifact,
  decompressInputProps,
  customOutName,
  compressInputProps,
  calculateChunkTimes,
  artifactName,
  VERSION,
  ServerlessRoutines,
  RENDERER_PATH_TOKEN,
  REMOTION_CONCATENATED_TOKEN,
  OVERHEAD_TIME_PER_LAMBDA,
  MINIMUM_FRAMES_PER_FUNCTION,
  MAX_FUNCTIONS_PER_RENDER,
  ENABLE_V5_BREAKING_CHANGES2 as ENABLE_V5_BREAKING_CHANGES,
  DOCS_URL,
  CONCAT_FOLDER_TOKEN,
  COMMAND_NOT_FOUND
};
