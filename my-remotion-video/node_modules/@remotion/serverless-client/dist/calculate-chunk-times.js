"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateChunkTimes = void 0;
const min_max_1 = require("./min-max");
const getAbsoluteTime = (parsedTimings) => {
    if (parsedTimings.length === 0) {
        return 0;
    }
    const allEnds = parsedTimings.map((p) => p.rendered);
    const allStarts = parsedTimings.map((p) => p.start);
    const biggestEnd = (0, min_max_1.max)(allEnds);
    const smallestStart = (0, min_max_1.min)(allStarts);
    return Math.max(0, biggestEnd - smallestStart);
};
const calculateChunkTimes = ({ type, timings, }) => {
    const parsedTimings = timings;
    const absoluteTime = getAbsoluteTime(parsedTimings);
    if (type === 'combined-time-for-cost-calculation') {
        const totalEncodingTimings = parsedTimings
            .map((p) => Math.max(0, p.rendered - p.start))
            .reduce((a, b) => a + b, 0);
        return totalEncodingTimings + absoluteTime;
    }
    if (type === 'absolute-time') {
        return absoluteTime;
    }
    throw new Error('invalid time for calculate chunk times');
};
exports.calculateChunkTimes = calculateChunkTimes;
