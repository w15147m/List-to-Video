// src/rules/deterministic-randomness.ts
var import_utils = require("@typescript-eslint/utils");
var createRule = import_utils.ESLintUtils.RuleCreator(() => {
  return `https://github.com/remotion-dev/remotion`;
});
var DeterministicRandomness = [
  "The result of Math.random() will change between frames while in rendering mode.",
  "Use the `random()` API from Remotion to get a deterministic pseudorandom value.",
  "If you are sure you want a true random value, use `random(null)` to hide this warning.",
  "See: https://remotion.dev/docs/using-randomness"
].join(`
`);
var deterministic_randomness_default = createRule({
  name: "deterministic-randomness",
  meta: {
    type: "problem",
    docs: {
      description: DeterministicRandomness,
      recommended: "warn"
    },
    fixable: undefined,
    schema: [],
    messages: {
      DeterministicRandomness
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      CallExpression: (node) => {
        const callee = node.callee;
        if (callee.type === "MemberExpression") {
          if (callee.object.type === "Identifier" && callee.object.name === "Math") {
            if (callee.property.type === "Identifier" && callee.property.name === "random") {
              context.report({
                messageId: "DeterministicRandomness",
                node
              });
            }
          }
        }
      }
    };
  }
});

// src/rules/even-dimensions.ts
var import_utils2 = require("@typescript-eslint/utils");
var createRule2 = import_utils2.ESLintUtils.RuleCreator(() => {
  return `https://github.com/remotion-dev/remotion`;
});
var EvenDimensions = "Videos rendered in H264/H265 codec do not support dimensions that are not divisible by 2. Remotion will round down your dimensions to satisfy this constraint. Ignore this warning if you don't plan on rendering this video with a H264 or H265 codec.";
var even_dimensions_default = createRule2({
  name: "even-dimensions",
  meta: {
    type: "problem",
    docs: {
      description: EvenDimensions,
      recommended: "warn"
    },
    fixable: undefined,
    schema: [],
    messages: {
      EvenDimensions
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      JSXAttribute: (node) => {
        if (node.type !== "JSXAttribute") {
          return;
        }
        if (node.name.name !== "width" && node.name.name !== "height") {
          return;
        }
        const value = node.value;
        if (!value || value.type !== "JSXExpressionContainer") {
          return;
        }
        const expression = value.expression;
        if (!expression || expression.type !== "Literal") {
          return;
        }
        const stringValue = expression.value;
        if (typeof stringValue !== "number") {
          return;
        }
        const parent = node.parent;
        if (!parent) {
          return;
        }
        if (parent.type !== "JSXOpeningElement") {
          return;
        }
        const name = parent.name;
        if (name.type !== "JSXIdentifier") {
          return;
        }
        if (name.name !== "Composition") {
          return;
        }
        if (stringValue % 2 !== 0) {
          context.report({
            messageId: "EvenDimensions",
            node
          });
        }
      }
    };
  }
});

// src/rules/no-background-image.ts
var import_utils3 = require("@typescript-eslint/utils");
var createRule3 = import_utils3.ESLintUtils.RuleCreator(() => {
  return "https://remotion.dev/docs/troubleshooting/background-image";
});
var BackgroundImage = [
  "Don't use background-image in Remotion.",
  "See: https://remotion.dev/docs/troubleshooting/background-image"
].join(`
`);
var no_background_image_default = createRule3({
  name: "no-background-image",
  meta: {
    type: "problem",
    docs: {
      description: BackgroundImage,
      recommended: "error"
    },
    fixable: undefined,
    schema: [],
    messages: {
      BackgroundImage
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      Property: (node) => {
        if (node.key.type !== "Identifier") {
          return;
        }
        if (node.key.name !== "backgroundImage") {
          return;
        }
        if (node.value.type === "Literal") {
          const { value } = node.value;
          if (typeof value === "string" && value.includes("url(")) {
            context.report({
              messageId: "BackgroundImage",
              node
            });
          }
        }
        if (node.value.type === "TemplateLiteral") {
          for (const element of node.value.quasis) {
            if (element.type !== "TemplateElement") {
              continue;
            }
            if (element.value.raw.includes("url(")) {
              context.report({
                messageId: "BackgroundImage",
                node
              });
            }
          }
        }
      }
    };
  }
});

// src/rules/no-duration-frames-infinity.ts
var import_utils4 = require("@typescript-eslint/utils");
var createRule4 = import_utils4.ESLintUtils.RuleCreator(() => {
  return `https://github.com/remotion-dev/remotion`;
});
var DurationInFrames = "Infinity is now the default, so you can remove the prop.";
var no_duration_frames_infinity_default = createRule4({
  name: "duration-in-frames",
  meta: {
    type: "problem",
    docs: {
      description: DurationInFrames,
      recommended: "warn"
    },
    fixable: "code",
    schema: [],
    messages: {
      DurationInFrames
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      JSXAttribute: (node) => {
        if (node.type !== "JSXAttribute") {
          return;
        }
        if (node.name.name !== "durationInFrames") {
          return;
        }
        const value = node.value;
        if (!value || value.type !== "JSXExpressionContainer") {
          return;
        }
        const expression = value.expression;
        if (!expression || expression.type !== "Identifier") {
          return;
        }
        const stringValue = expression.name;
        if (typeof stringValue !== "string") {
          return;
        }
        const parent = node.parent;
        if (!parent) {
          return;
        }
        if (parent.type !== "JSXOpeningElement") {
          return;
        }
        const name = parent.name;
        if (name.type !== "JSXIdentifier") {
          return;
        }
        if (name.name !== "Sequence") {
          return;
        }
        if (stringValue === "Infinity") {
          context.report({
            messageId: "DurationInFrames",
            node,
            fix: (fixer) => {
              return fixer.removeRange([node.name.range[0], value.range[1]]);
            }
          });
        }
      }
    };
  }
});

// src/rules/no-from-0.ts
var import_utils5 = require("@typescript-eslint/utils");
var createRule5 = import_utils5.ESLintUtils.RuleCreator(() => {
  return `https://github.com/remotion-dev/remotion`;
});
var From0 = "0 is now the default, so you can remove the prop.";
var no_from_0_default = createRule5({
  name: "from",
  meta: {
    type: "problem",
    docs: {
      description: From0,
      recommended: "warn"
    },
    fixable: "code",
    schema: [],
    messages: {
      From0
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      JSXAttribute: (node) => {
        if (node.type !== "JSXAttribute") {
          return;
        }
        if (node.name.name !== "from") {
          return;
        }
        const value = node.value;
        if (!value || value.type !== "JSXExpressionContainer") {
          return;
        }
        const expression = value.expression;
        if (!expression || expression.type !== "Literal") {
          return;
        }
        const stringValue = expression.value;
        if (stringValue !== 0) {
          return;
        }
        const parent = node.parent;
        if (!parent) {
          return;
        }
        if (parent.type !== "JSXOpeningElement") {
          return;
        }
        const name = parent.name;
        if (name.type !== "JSXIdentifier") {
          return;
        }
        if (name.name !== "Sequence") {
          return;
        }
        if (stringValue === 0) {
          context.report({
            messageId: "From0",
            node,
            fix: (fixer) => {
              return fixer.removeRange([node.name.range[0], value.range[1]]);
            }
          });
        }
      }
    };
  }
});

// src/rules/no-string-assets.ts
var import_utils6 = require("@typescript-eslint/utils");
var createRule6 = import_utils6.ESLintUtils.RuleCreator(() => {
  return `https://github.com/remotion-dev/remotion`;
});
var NoStringAssets = [
  "Don't reference local assets by string, use an import statement or staticFile() instead.",
  "See: https://www.remotion.dev/docs/assets"
].join(`
`);
var no_string_assets_default = createRule6({
  name: "no-string-assets",
  meta: {
    type: "problem",
    docs: {
      description: NoStringAssets,
      recommended: "warn"
    },
    fixable: undefined,
    schema: [],
    messages: {
      NoStringAssets
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      JSXAttribute: (node) => {
        if (node.type !== "JSXAttribute") {
          return;
        }
        if (node.name.name !== "src") {
          return;
        }
        const value = node.value;
        const insideCurlyBraces = value && value.type === "JSXExpressionContainer" && value.expression.type === "Literal";
        if (!value || value.type !== "Literal" && !insideCurlyBraces) {
          return;
        }
        const stringValue = value && value.type === "JSXExpressionContainer" && value.expression.type === "Literal" ? value.expression.value : value.type === "Literal" ? value.value : null;
        if (typeof stringValue !== "string") {
          return;
        }
        const parent = node.parent;
        if (!parent) {
          return;
        }
        if (parent.type !== "JSXOpeningElement") {
          return;
        }
        const name = parent.name;
        if (name.type !== "JSXIdentifier") {
          return;
        }
        if (name.name === "Img" || name.name === "img" || name.name === "Audio" || name.name === "audio" || name.name === "Video" || name.name === "video" || name.name === "source" || name.name === "Html5Video" || name.name === "Html5Audio") {
          if (stringValue.startsWith("http://")) {
            return;
          }
          if (stringValue.startsWith("https://")) {
            return;
          }
          if (stringValue.startsWith("data:")) {
            return;
          }
          context.report({
            messageId: "NoStringAssets",
            node
          });
        }
      }
    };
  }
});

// src/rules/non-pure-animation.ts
var import_utils7 = require("@typescript-eslint/utils");
var createRule7 = import_utils7.ESLintUtils.RuleCreator(() => {
  return "https://www.remotion.dev/docs/flickering";
});
var NonPureAnimation = [
  "This animation does not run purely off useCurrentFrame() and will lead to flickering.",
  "See: https://www.remotion.dev/docs/flickering"
].join(`
`);
var nonPureAnimationProperties = new Set(["transition"]);
var nonPureAnimationPropertiesKebab = new Set(["transition"]);
var nonPureAnimationTailwindClasses = [
  /\btransition-\w+\b/,
  /\btransition\b/
];
function findProblematicTailwindClass(classString) {
  for (const pattern of nonPureAnimationTailwindClasses) {
    const match = classString.match(pattern);
    if (match) {
      return {
        match: match[0],
        index: match.index
      };
    }
  }
  return null;
}
var non_pure_animation_default = createRule7({
  name: "non-pure-animation",
  meta: {
    type: "problem",
    docs: {
      description: NonPureAnimation,
      recommended: "warn"
    },
    fixable: undefined,
    schema: [],
    messages: {
      NonPureAnimation
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      Property: (node) => {
        let propertyName;
        if (node.key.type === "Identifier") {
          propertyName = node.key.name;
        } else if (node.key.type === "Literal" && typeof node.key.value === "string") {
          propertyName = node.key.value;
        }
        if (!propertyName) {
          return;
        }
        const isNonPureProperty = nonPureAnimationProperties.has(propertyName) || nonPureAnimationPropertiesKebab.has(propertyName);
        if (isNonPureProperty) {
          context.report({
            messageId: "NonPureAnimation",
            node
          });
        }
      },
      JSXAttribute: (node) => {
        if (node.name.type === "JSXIdentifier" && node.name.name === "className" && node.value) {
          let classString;
          let valueNode;
          if (node.value.type === "Literal" && typeof node.value.value === "string") {
            classString = node.value.value;
            valueNode = node.value;
          } else if (node.value.type === "JSXExpressionContainer" && node.value.expression.type === "Literal" && typeof node.value.expression.value === "string") {
            classString = node.value.expression.value;
            valueNode = node.value.expression;
          } else if (node.value.type === "JSXExpressionContainer" && node.value.expression.type === "TemplateLiteral") {
            const templateLiteral = node.value.expression;
            classString = templateLiteral.quasis.map((q) => q.value.cooked || q.value.raw).join(" ");
            valueNode = templateLiteral;
          }
          if (classString) {
            const problematicClass = findProblematicTailwindClass(classString);
            if (problematicClass) {
              const sourceCode = context.getSourceCode();
              const valueStart = valueNode.range[0];
              const quoteOffset = valueNode.type === "Literal" ? 1 : 0;
              const classStart = valueStart + quoteOffset + problematicClass.index;
              const classEnd = classStart + problematicClass.match.length;
              const start = sourceCode.getLocFromIndex(classStart);
              const end = sourceCode.getLocFromIndex(classEnd);
              context.report({
                messageId: "NonPureAnimation",
                loc: {
                  start,
                  end
                }
              });
            }
          }
        }
      }
    };
  }
});

// src/rules/slow-css-property.ts
var import_utils8 = require("@typescript-eslint/utils");
var createRule8 = import_utils8.ESLintUtils.RuleCreator(() => {
  return "https://remotion.dev/docs/gpu";
});
var SlowCssProperty = [
  "This GPU effect may slow down the render on machines which don't have a GPU.",
  "See: https://remotion.dev/docs/gpu"
].join(`
`);
var slowCssProperties = new Set(["boxShadow", "textShadow", "filter"]);
var slowCssPropertiesKebab = new Set(["box-shadow", "text-shadow", "filter"]);
var slowTailwindClasses = [
  /\bshadow-(?:sm|md|lg|xl|2xl|inner|none|\w+)\b/,
  /\bshadow-\w+(?:\/\d+)?\b/,
  /\bblur-(?:none|sm|md|lg|xl|2xl|3xl|\w+)\b/,
  /\bbrightness-\d+\b/,
  /\bcontrast-\d+\b/,
  /\bdrop-shadow-(?:sm|md|lg|xl|2xl|none|\w+)\b/,
  /\bgrayscale(?:-\d+)?\b/,
  /\bhue-rotate-\d+\b/,
  /\binvert(?:-\d+)?\b/,
  /\bsaturate-\d+\b/,
  /\bsepia(?:-\d+)?\b/,
  /\btext-shadow-\w+\b/
];
function containsSlowTailwindClass(classString) {
  return slowTailwindClasses.some((pattern) => pattern.test(classString));
}
var slow_css_property_default = createRule8({
  name: "slow-css-property",
  meta: {
    type: "problem",
    docs: {
      description: SlowCssProperty,
      recommended: "warn"
    },
    fixable: undefined,
    schema: [],
    messages: {
      SlowCssProperty
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      Property: (node) => {
        let propertyName;
        if (node.key.type === "Identifier") {
          propertyName = node.key.name;
        } else if (node.key.type === "Literal" && typeof node.key.value === "string") {
          propertyName = node.key.value;
        }
        if (!propertyName) {
          return;
        }
        const isSlowProperty = slowCssProperties.has(propertyName) || slowCssPropertiesKebab.has(propertyName);
        if (isSlowProperty) {
          context.report({
            messageId: "SlowCssProperty",
            node
          });
        }
      },
      JSXAttribute: (node) => {
        if (node.name.type === "JSXIdentifier" && node.name.name === "className" && node.value) {
          let classString;
          if (node.value.type === "Literal" && typeof node.value.value === "string") {
            classString = node.value.value;
          } else if (node.value.type === "JSXExpressionContainer" && node.value.expression.type === "Literal" && typeof node.value.expression.value === "string") {
            classString = node.value.expression.value;
          } else if (node.value.type === "JSXExpressionContainer" && node.value.expression.type === "TemplateLiteral") {
            const templateLiteral = node.value.expression;
            classString = templateLiteral.quasis.map((q) => q.value.cooked || q.value.raw).join(" ");
          }
          if (classString && containsSlowTailwindClass(classString)) {
            context.report({
              messageId: "SlowCssProperty",
              node
            });
          }
        }
      }
    };
  }
});

// src/rules/staticfile-no-relative.ts
var import_utils9 = require("@typescript-eslint/utils");
var createRule9 = import_utils9.ESLintUtils.RuleCreator(() => {
  return `https://remotion.dev/docs/staticfile-relative-paths`;
});
var RelativePathStaticFile = [
  "Don't pass a relative path to staticFile().",
  "See: https://remotion.dev/docs/staticfile-relative-paths"
].join(`
`);
var AbsoluteStaticFile = [
  "Do not pass an absolute path to staticFile().",
  "See: https://remotion.dev/docs/staticfile-relative-paths"
].join("");
var PublicStaticFile = [
  "Do not prefix your assets with public/.",
  "See: https://remotion.dev/docs/staticfile-relative-paths"
].join("");
var staticfile_no_relative_default = createRule9({
  name: "staticfile-no-relative",
  meta: {
    type: "problem",
    docs: {
      description: RelativePathStaticFile,
      recommended: "warn"
    },
    fixable: undefined,
    schema: [],
    messages: {
      RelativePathStaticFile,
      PublicStaticFile,
      AbsoluteStaticFile
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      CallExpression: (node) => {
        const value = node;
        if (!value) {
          return;
        }
        if (node.type === "CallExpression" && node.callee.type === "Identifier" && node.callee.name === "staticFile") {
          const args = node.arguments;
          if (args.length === 0) {
            return;
          }
          const firstArg = args[0];
          if (firstArg.type === "Literal") {
            const value2 = firstArg.value;
            if (typeof value2 !== "string") {
              return;
            }
            if (value2.startsWith("./")) {
              context.report({
                messageId: "RelativePathStaticFile",
                node
              });
            }
            if (value2.startsWith("../")) {
              context.report({
                messageId: "RelativePathStaticFile",
                node
              });
            }
            if (value2.startsWith("public/")) {
              context.report({
                messageId: "PublicStaticFile",
                node
              });
            }
            if (value2.startsWith("/Users") || value2.startsWith("/home") || value2.startsWith("/tmp") || value2.startsWith("/etc") || value2.startsWith("/opt") || value2.startsWith("/var") || value2.startsWith("C:") || value2.startsWith("D:") || value2.startsWith("E:")) {
              context.report({
                messageId: "AbsoluteStaticFile",
                node
              });
            }
          }
        }
      }
    };
  }
});

// src/rules/staticfile-no-remote.ts
var import_utils10 = require("@typescript-eslint/utils");
var createRule10 = import_utils10.ESLintUtils.RuleCreator(() => {
  return `https://remotion.dev/docs/staticfile-remote-urls`;
});
var RelativePathStaticFile2 = [
  "Don't pass a remote URL to staticFile().",
  "See: https://remotion.dev/docs/staticfile-remote-urls"
].join(`
`);
var staticfile_no_remote_default = createRule10({
  name: "staticfile-no-remote",
  meta: {
    type: "problem",
    docs: {
      description: RelativePathStaticFile2,
      recommended: "warn"
    },
    fixable: undefined,
    schema: [],
    messages: {
      RelativePathStaticFile: RelativePathStaticFile2
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      CallExpression: (node) => {
        const value = node;
        if (!value) {
          return;
        }
        if (node.type === "CallExpression" && node.callee.type === "Identifier" && node.callee.name === "staticFile") {
          const args = node.arguments;
          if (args.length === 0) {
            return;
          }
          const firstArg = args[0];
          if (firstArg.type === "Literal") {
            const value2 = firstArg.value;
            if (typeof value2 !== "string") {
              return;
            }
            if (value2.startsWith("http://")) {
              context.report({
                messageId: "RelativePathStaticFile",
                node
              });
            }
            if (value2.startsWith("https://")) {
              context.report({
                messageId: "RelativePathStaticFile",
                node
              });
            }
          }
        }
      }
    };
  }
});

// src/rules/use-gif-component.ts
var import_utils11 = require("@typescript-eslint/utils");
var createRule11 = import_utils11.ESLintUtils.RuleCreator(() => {
  return `https://github.com/remotion-dev/remotion`;
});
var UseGifComponent = [
  "Use the <Gif> component animated GIFs.",
  "See: https://www.remotion.dev/docs/gif.",
  "Ignore this message if this is a non-animated GIF."
].join(`
`);
var use_gif_component_default = createRule11({
  name: "use-gif-component",
  meta: {
    type: "problem",
    docs: {
      description: UseGifComponent,
      recommended: "warn"
    },
    fixable: undefined,
    schema: [],
    messages: {
      UseGifComponent
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      JSXAttribute: (node) => {
        if (node.type !== "JSXAttribute") {
          return;
        }
        if (node.name.name !== "src") {
          return;
        }
        const parent = node.parent;
        if (!parent) {
          return;
        }
        if (parent.type !== "JSXOpeningElement") {
          return;
        }
        const name = parent.name;
        if (name.type !== "JSXIdentifier") {
          return;
        }
        if (name.name !== "Img" && name.name !== "img") {
          return;
        }
        const value = node.value;
        if (!value) {
          return;
        }
        const stringValue = value && value.type === "JSXExpressionContainer" && value.expression.type === "Literal" ? value.expression.value : value.type === "Literal" ? value.value : null;
        if (typeof stringValue === "string") {
          if (stringValue.includes(".gif")) {
            context.report({
              messageId: "UseGifComponent",
              node
            });
          }
        }
        if (value.type === "JSXExpressionContainer" && value.expression.type === "CallExpression" && value.expression.callee.type === "Identifier" && value.expression.callee.name === "staticFile") {
          const args = value.expression.arguments;
          if (args.length === 0) {
            return;
          }
          const firstArg = args[0];
          if (firstArg.type === "Literal") {
            const value2 = firstArg.value;
            if (typeof value2 !== "string") {
              return;
            }
            if (value2.includes(".gif")) {
              context.report({
                messageId: "UseGifComponent",
                node
              });
            }
          }
        }
      }
    };
  }
});

// src/rules/v4-import.ts
var import_utils12 = require("@typescript-eslint/utils");
var createRule12 = import_utils12.ESLintUtils.RuleCreator(() => {
  return `https://www.remotion.dev/docs/4-0-migration`;
});
var ImportConfig = "Update the import to the new V4 location: import {Config} from '@remotion/cli/config'";
var rule = createRule12({
  name: "v4-config-import",
  meta: {
    type: "problem",
    docs: {
      description: ImportConfig,
      recommended: "warn"
    },
    fixable: undefined,
    schema: [],
    messages: {
      ImportConfig
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      ImportDeclaration: (node) => {
        if (node.source.value !== "remotion") {
          return;
        }
        const config = node.specifiers.find((s) => s.type === "ImportSpecifier" && s.imported.name === "Config");
        if (config) {
          context.report({
            messageId: "ImportConfig",
            node
          });
        }
      }
    };
  }
});
var v4_import_default = rule;

// src/rules/volume-callback.ts
var import_utils13 = require("@typescript-eslint/utils");
var createRule13 = import_utils13.ESLintUtils.RuleCreator(() => {
  return `https://github.com/remotion-dev/remotion`;
});
var VolumeCallback = "Prefer a callback function for setting the volume: `volume={(f) => interpolate(...)}`. See https://www.remotion.dev/docs/audio/volume";
var volume_callback_default = createRule13({
  name: "volume-callback",
  meta: {
    type: "problem",
    docs: {
      description: VolumeCallback,
      recommended: "warn"
    },
    fixable: undefined,
    schema: [],
    messages: {
      VolumeCallback
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      JSXAttribute: (node) => {
        if (node.type !== "JSXAttribute") {
          return;
        }
        if (node.name.name !== "volume") {
          return;
        }
        const value = node.value;
        if (!value || value.type !== "JSXExpressionContainer") {
          return;
        }
        const parent = node.parent;
        if (!parent) {
          return;
        }
        if (parent.type !== "JSXOpeningElement") {
          return;
        }
        const name = parent.name;
        if (name.type !== "JSXIdentifier") {
          return;
        }
        if (name.name !== "Video" && name.name !== "Audio" && name.name !== "Html5Video" && name.name !== "Html5Audio") {
          return;
        }
        const expression = value.expression;
        if (!expression) {
          return;
        }
        if (expression.type === "Literal") {
          return;
        }
        if (expression.type === "ArrowFunctionExpression") {
          return;
        }
        if (expression.type === "FunctionExpression") {
          return;
        }
        if (expression.type === "Identifier") {
          return;
        }
        context.report({
          messageId: "VolumeCallback",
          node
        });
      }
    };
  }
});

// src/rules/warn-native-media-tag.ts
var import_utils14 = require("@typescript-eslint/utils");
var createRule14 = import_utils14.ESLintUtils.RuleCreator(() => {
  return `https://github.com/remotion-dev/remotion`;
});
var NoNativeImgTag = "Prefer the <Img /> tag from 'remotion' package, because it will wait until the image is loaded when you are rendering your video.";
var NoNativeIFrameTag = "Prefer the <IFrame /> tag from 'remotion' package, because it will wait until the iframe is loaded when you are rendering your video.";
var NoNativeAudioTag = "Use the <Audio /> tag from '@remotion/media' package, because it will synchronize with the Remotion timeline.";
var NoNativeVideoTag = "Use the <Video /> tag from '@remotion/media' package, because it will synchronize with the Remotion timeline.";
var warn_native_media_tag_default = createRule14({
  name: "warn-native-media-tag",
  meta: {
    type: "problem",
    docs: {
      description: NoNativeImgTag,
      recommended: "warn"
    },
    fixable: undefined,
    schema: [],
    messages: {
      NoNativeImgTag,
      NoNativeIFrameTag,
      NoNativeAudioTag,
      NoNativeVideoTag
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      JSXOpeningElement: (node) => {
        if (node.name.type === "JSXIdentifier" && node.name.name === "img") {
          context.report({
            messageId: "NoNativeImgTag",
            node
          });
        }
        if (node.name.type === "JSXIdentifier" && node.name.name === "iframe") {
          context.report({
            messageId: "NoNativeIFrameTag",
            node
          });
        }
        if (node.name.type === "JSXIdentifier" && node.name.name === "video") {
          context.report({
            messageId: "NoNativeVideoTag",
            node
          });
        }
        if (node.name.type === "JSXIdentifier" && node.name.name === "audio") {
          context.report({
            messageId: "NoNativeAudioTag",
            node
          });
        }
      },
      TaggedTemplateExpression: (node) => {
        if (node.tag.type !== "MemberExpression") {
          return;
        }
        if (node.tag.object.type !== "Identifier") {
          return;
        }
        if (node.tag.object.name !== "styled") {
          return;
        }
        if (node.tag.property.type !== "Identifier") {
          return;
        }
        if (node.tag.property.name === "img") {
          context.report({
            messageId: "NoNativeImgTag",
            node
          });
        }
        if (node.tag.property.name === "iframe") {
          context.report({
            messageId: "NoNativeIFrameTag",
            node
          });
        }
        if (node.tag.property.name === "audio") {
          context.report({
            messageId: "NoNativeAudioTag",
            node
          });
        }
        if (node.tag.property.name === "video") {
          context.report({
            messageId: "NoNativeVideoTag",
            node
          });
        }
      }
    };
  }
});

// src/index.ts
var rules = {
  "warn-native-media-tag": warn_native_media_tag_default,
  "deterministic-randomness": deterministic_randomness_default,
  "no-string-assets": no_string_assets_default,
  "even-dimensions": even_dimensions_default,
  "duration-in-frames": no_duration_frames_infinity_default,
  "from-0": no_from_0_default,
  "volume-callback": volume_callback_default,
  "use-gif-component": use_gif_component_default,
  "staticfile-no-relative": staticfile_no_relative_default,
  "staticfile-no-remote": staticfile_no_remote_default,
  "no-background-image": no_background_image_default,
  "non-pure-animation": non_pure_animation_default,
  "slow-css-property": slow_css_property_default,
  "v4-config-import": v4_import_default
};
var recommendedRuleConfig = {
  "@remotion/warn-native-media-tag": "error",
  "@remotion/deterministic-randomness": "error",
  "@remotion/no-string-assets": "error",
  "@remotion/even-dimensions": "error",
  "@remotion/duration-in-frames": "error",
  "@remotion/from-0": "error",
  "@remotion/volume-callback": "error",
  "@remotion/use-gif-component": "error",
  "@remotion/staticfile-no-relative": "error",
  "@remotion/staticfile-no-remote": "error",
  "@remotion/no-background-image": "error",
  "@remotion/non-pure-animation": "warn",
  "@remotion/slow-css-property": "warn",
  "@remotion/v4-config-import": "error"
};
var configs = {
  recommended: {
    rules: recommendedRuleConfig,
    plugins: ["@remotion"]
  }
};
var flatPlugin = {
  rules: recommendedRuleConfig,
  plugins: {
    "@remotion": {
      rules
    }
  }
};
module.exports = {
  configs,
  rules,
  flatPlugin
};
