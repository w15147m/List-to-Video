import { type CompProps } from './Composition.js';
import type { TCompMetadata, TComposition, TRenderAsset, TSequence } from './CompositionManager.js';
import type { CompositionManagerContext } from './CompositionManagerContext.js';
import * as CSSUtils from './default-css.js';
import type { SerializedJSONWithCustomFields } from './input-props-serialization.js';
import type { LoggingContextValue } from './log-level-context.js';
import type { RemotionEnvironment } from './remotion-environment-context.js';
import type { SetTimelineContextValue, TimelineContextValue } from './timeline-position-state.js';
import * as TimelinePosition from './timeline-position-state.js';
import { truthy } from './truthy.js';
import type { MediaVolumeContextValue, SetMediaVolumeContextValue } from './volume-position-state.js';
import type { WatchRemotionStaticFilesPayload } from './watch-static-file.js';
import { useRemotionContexts } from './wrap-remotion-context.js';
export declare const Internals: {
    readonly useUnsafeVideoConfig: () => import("./video-config.js").VideoConfig | null;
    readonly useFrameForVolumeProp: (behavior: import("./audio/use-audio-frame.js").LoopVolumeCurveBehavior) => number;
    readonly useTimelinePosition: () => number;
    readonly evaluateVolume: ({ frame, volume, mediaVolume, }: {
        frame: number;
        volume: import("./volume-prop.js").VolumeProp | undefined;
        mediaVolume: number;
    }) => number;
    readonly getAbsoluteSrc: (relativeSrc: string) => string;
    readonly Timeline: typeof TimelinePosition;
    readonly validateMediaTrimProps: ({ startFrom, endAt, trimBefore, trimAfter, }: {
        startFrom: number | undefined;
        endAt: number | undefined;
        trimBefore: number | undefined;
        trimAfter: number | undefined;
    }) => void;
    readonly validateMediaProps: (props: {
        volume: import("./volume-prop.js").VolumeProp | undefined;
        playbackRate: number | undefined;
    }, component: "Html5Video" | "Html5Audio" | "Audio" | "Video") => void;
    readonly resolveTrimProps: ({ startFrom, endAt, trimBefore, trimAfter, }: {
        startFrom: number | undefined;
        endAt: number | undefined;
        trimBefore: number | undefined;
        trimAfter: number | undefined;
    }) => {
        trimBeforeValue: number | undefined;
        trimAfterValue: number | undefined;
    };
    readonly VideoForPreview: import("react").ForwardRefExoticComponent<Omit<import("./video/props.js").NativeVideoProps & {
        name?: string;
        volume?: import("./volume-prop.js").VolumeProp;
        playbackRate?: number;
        acceptableTimeShiftInSeconds?: number;
        allowAmplificationDuringRender?: boolean;
        useWebAudioApi?: boolean;
        toneFrequency?: number;
        pauseWhenBuffering?: boolean;
        showInTimeline?: boolean;
        delayRenderTimeoutInMilliseconds?: number;
        loopVolumeCurveBehavior?: import("./audio/use-audio-frame.js").LoopVolumeCurveBehavior;
        delayRenderRetries?: number;
        onError?: (err: Error) => void;
        onAutoPlayError?: null | (() => void);
        audioStreamIndex?: number;
    } & {
        readonly onlyWarnForMediaSeekingError: boolean;
        readonly onDuration: (src: string, durationInSeconds: number) => void;
        readonly pauseWhenBuffering: boolean;
        readonly _remotionInternalNativeLoopPassed: boolean;
        readonly _remotionInternalStack: string | null;
        readonly showInTimeline: boolean;
        readonly onVideoFrame: null | import("./index.js").OnVideoFrame;
        readonly crossOrigin?: "" | "anonymous" | "use-credentials";
    }, "ref"> & import("react").RefAttributes<HTMLVideoElement>>;
    readonly CompositionManager: import("react").Context<CompositionManagerContext>;
    readonly CompositionSetters: import("react").Context<import("./CompositionManagerContext.js").CompositionManagerSetters>;
    readonly SequenceManager: import("react").Context<import("./SequenceManager.js").SequenceManagerContext>;
    readonly SequenceVisibilityToggleContext: import("react").Context<import("./SequenceManager.js").SequenceVisibilityToggleState>;
    readonly RemotionRoot: import("react").FC<{
        readonly children: React.ReactNode;
        readonly numberOfAudioTags: number;
        readonly logLevel: import("./log.js").LogLevel;
        readonly onlyRenderComposition: string | null;
        readonly currentCompositionMetadata: import("./CompositionManagerContext.js").BaseMetadata | null;
        readonly audioLatencyHint: AudioContextLatencyCategory;
        readonly videoEnabled: boolean | null;
        readonly audioEnabled: boolean | null;
    }>;
    readonly useVideo: () => (import("./video-config.js").VideoConfig & {
        component: import("react").LazyExoticComponent<import("react").ComponentType<Record<string, unknown>>>;
    }) | null;
    readonly getRoot: () => import("react").FC<{}> | null;
    readonly useMediaVolumeState: () => readonly [number, (u: number) => void];
    readonly useMediaMutedState: () => readonly [boolean, (u: React.SetStateAction<boolean>) => void];
    readonly useMediaInTimeline: ({ volume, mediaVolume, src, mediaType, playbackRate, displayName, id, stack, showInTimeline, premountDisplay, postmountDisplay, loopDisplay, }: {
        volume: import("./volume-prop.js").VolumeProp | undefined;
        mediaVolume: number;
        src: string | undefined;
        mediaType: "audio" | "video";
        playbackRate: number;
        displayName: string | null;
        id: string;
        stack: string | null;
        showInTimeline: boolean;
        premountDisplay: number | null;
        postmountDisplay: number | null;
        loopDisplay: import("./CompositionManager.js").LoopDisplay | undefined;
    }) => void;
    readonly useLazyComponent: <Props>({ compProps, componentName, noSuspense, }: {
        compProps: CompProps<Props>;
        componentName: string;
        noSuspense: boolean;
    }) => import("react").ExoticComponent<Props | (import("react").PropsWithoutRef<Props> & import("react").RefAttributes<import("react").Component<Props, any, any>>)> & {
        readonly _result: import("react").ComponentType<Props>;
    };
    readonly truthy: typeof truthy;
    readonly SequenceContext: import("react").Context<import("./SequenceContext.js").SequenceContextType | null>;
    readonly useRemotionContexts: typeof useRemotionContexts;
    readonly RemotionContextProvider: (props: import("./wrap-remotion-context.js").RemotionContextProviderProps) => import("react/jsx-runtime.js").JSX.Element;
    readonly CSSUtils: typeof CSSUtils;
    readonly setupEnvVariables: () => void;
    readonly MediaVolumeContext: import("react").Context<MediaVolumeContextValue>;
    readonly SetMediaVolumeContext: import("react").Context<SetMediaVolumeContextValue>;
    readonly getRemotionEnvironment: () => RemotionEnvironment;
    readonly SharedAudioContext: import("react").Context<{
        registerAudio: (options: {
            aud: import("react").AudioHTMLAttributes<HTMLAudioElement>;
            audioId: string;
            premounting: boolean;
        }) => {
            id: number;
            props: import("react").AudioHTMLAttributes<HTMLAudioElement>;
            el: React.RefObject<HTMLAudioElement | null>;
            audioId: string;
            mediaElementSourceNode: import("./audio/shared-element-source-node.js").SharedElementSourceNode | null;
            premounting: boolean;
        };
        unregisterAudio: (id: number) => void;
        updateAudio: (options: {
            id: number;
            aud: import("react").AudioHTMLAttributes<HTMLAudioElement>;
            audioId: string;
            premounting: boolean;
        }) => void;
        playAllAudios: () => void;
        numberOfAudioTags: number;
        audioContext: AudioContext | null;
    } | null>;
    readonly SharedAudioContextProvider: import("react").FC<{
        readonly numberOfAudioTags: number;
        readonly children: React.ReactNode;
        readonly component: import("react").LazyExoticComponent<import("react").ComponentType<Record<string, unknown>>> | null;
        readonly audioLatencyHint: AudioContextLatencyCategory;
    }>;
    readonly invalidCompositionErrorMessage: string;
    readonly calculateMediaDuration: ({ trimAfter, mediaDurationInFrames, playbackRate, trimBefore, }: {
        mediaDurationInFrames: number;
        playbackRate: number;
        trimBefore: number | undefined;
        trimAfter: number | undefined;
    }) => number;
    readonly isCompositionIdValid: (id: string) => RegExpMatchArray | null;
    readonly getPreviewDomElement: () => HTMLElement | null;
    readonly compositionsRef: import("react").RefObject<{
        getCompositions: () => import("./CompositionManager.js").AnyComposition[];
    } | null>;
    readonly portalNode: () => HTMLElement;
    readonly waitForRoot: (fn: (comp: React.FC) => void) => (() => void);
    readonly CanUseRemotionHooksProvider: import("react").FC<{
        readonly children: React.ReactNode;
    }>;
    readonly CanUseRemotionHooks: import("react").Context<boolean>;
    readonly PrefetchProvider: import("react").FC<{
        readonly children: React.ReactNode;
    }>;
    readonly DurationsContextProvider: import("react").FC<{
        readonly children: React.ReactNode;
    }>;
    readonly IsPlayerContextProvider: import("react").FC<{
        children?: import("react").ReactNode | undefined;
    }>;
    readonly useIsPlayer: () => boolean;
    readonly EditorPropsProvider: import("react").FC<{
        readonly children: React.ReactNode;
    }>;
    readonly EditorPropsContext: import("react").Context<import("./EditorProps.js").EditorPropsContextType>;
    readonly usePreload: (src: string) => string;
    readonly NonceContext: import("react").Context<import("./nonce.js").TNonceContext>;
    readonly SetNonceContext: import("react").Context<import("./nonce.js").TSetNonceContext>;
    readonly resolveVideoConfig: ({ calculateMetadata, signal, defaultProps, originalProps, compositionId, compositionDurationInFrames, compositionFps, compositionHeight, compositionWidth, }: {
        compositionId: string;
        compositionWidth: number | null;
        compositionHeight: number | null;
        compositionFps: number | null;
        compositionDurationInFrames: number | null;
        calculateMetadata: import("./Composition.js").CalculateMetadataFunction<import("./props-if-has-props.js").InferProps<import("zod").AnyZodObject, Record<string, unknown>>> | null;
        signal: AbortSignal;
        defaultProps: Record<string, unknown>;
        originalProps: Record<string, unknown>;
    }) => import("./video-config.js").VideoConfig | Promise<import("./video-config.js").VideoConfig>;
    readonly useResolvedVideoConfig: (preferredCompositionId: string | null) => ({
        type: "loading";
    } | {
        type: "success";
        result: import("./video-config.js").VideoConfig;
    } | {
        type: "success-and-refreshing";
        result: import("./video-config.js").VideoConfig;
    } | {
        type: "error";
        error: Error;
    }) | null;
    readonly resolveCompositionsRef: import("react").RefObject<{
        setCurrentRenderModalComposition: (compositionId: string | null) => void;
        reloadCurrentlySelectedComposition: () => void;
    } | null>;
    readonly ResolveCompositionConfig: import("react").FC<import("react").PropsWithChildren<{
        children: React.ReactNode;
    }>>;
    readonly REMOTION_STUDIO_CONTAINER_ELEMENT: "__remotion-studio-container";
    readonly RenderAssetManager: import("react").Context<import("./RenderAssetManager.js").RenderAssetManagerContext>;
    readonly persistCurrentFrame: (time: {
        [x: string]: number;
    }) => void;
    readonly useTimelineSetFrame: () => ((u: React.SetStateAction<Record<string, number>>) => void);
    readonly isIosSafari: () => boolean;
    readonly WATCH_REMOTION_STATIC_FILES: "remotion_staticFilesChanged";
    readonly addSequenceStackTraces: (component: unknown) => void;
    readonly useMediaStartsAt: () => number;
    readonly BufferingProvider: import("react").FC<{
        readonly children: React.ReactNode;
    }>;
    readonly BufferingContextReact: import("react").Context<{
        addBlock: (block: {
            id: string;
        }) => {
            unblock: () => void;
        };
        listenForBuffering: (callback: () => void) => {
            remove: () => void;
        };
        listenForResume: (callback: () => void) => {
            remove: () => void;
        };
        buffering: React.MutableRefObject<boolean>;
    } | null>;
    readonly enableSequenceStackTraces: () => void;
    readonly CurrentScaleContext: import("react").Context<import("./use-current-scale.js").CurrentScaleContextType | null>;
    readonly PreviewSizeContext: import("react").Context<import("./use-current-scale.js").PreviewSizeCtx>;
    readonly calculateScale: ({ canvasSize, compositionHeight, compositionWidth, previewSize, }: {
        previewSize: import("./use-current-scale.js").PreviewSize["size"];
        compositionWidth: number;
        compositionHeight: number;
        canvasSize: {
            width: number;
            height: number;
        };
    }) => number;
    readonly editorPropsProviderRef: import("react").RefObject<{
        getProps: () => {
            [x: string]: Record<string, unknown>;
        };
        setProps: React.Dispatch<React.SetStateAction<{
            [x: string]: Record<string, unknown>;
        }>>;
    } | null>;
    readonly PROPS_UPDATED_EXTERNALLY: "remotion.propsUpdatedExternally";
    readonly validateRenderAsset: (artifact: TRenderAsset) => void;
    readonly Log: {
        trace: (options: {
            logLevel: import("./log.js").LogLevel;
            tag: string | null;
        }, message?: any, ...optionalParams: any[]) => void;
        verbose: (options: {
            logLevel: import("./log.js").LogLevel;
            tag: string | null;
        }, message?: any, ...optionalParams: any[]) => void;
        info: (options: {
            logLevel: import("./log.js").LogLevel;
            tag: string | null;
        }, message?: any, ...optionalParams: any[]) => void;
        warn: (options: {
            logLevel: import("./log.js").LogLevel;
            tag: string | null;
        }, message?: any, ...optionalParams: any[]) => void;
        error: (options: {
            logLevel: import("./log.js").LogLevel;
            tag: string | null;
        }, message?: any, ...optionalParams: any[]) => void;
    };
    readonly LogLevelContext: import("react").Context<LoggingContextValue>;
    readonly useLogLevel: () => import("./log.js").LogLevel;
    readonly playbackLogging: ({ logLevel, tag, message, mountTime, }: {
        logLevel: import("./log.js").LogLevel;
        tag: string;
        message: string;
        mountTime: number | null;
    }) => void;
    readonly timeValueRef: import("react").RefObject<{
        goToFrame: () => void;
        seek: (newFrame: number) => void;
        play: (e?: import("react").SyntheticEvent | PointerEvent) => void;
        pause: () => void;
        toggle: (e?: import("react").SyntheticEvent | PointerEvent) => void;
    } | null>;
    readonly compositionSelectorRef: import("react").RefObject<{
        expandComposition: (compName: string) => void;
        selectComposition: (compName: string) => void;
        toggleFolder: (folderName: string, parentName: string | null) => void;
    } | null>;
    readonly RemotionEnvironmentContext: import("react").Context<RemotionEnvironment | null>;
    readonly warnAboutTooHighVolume: (volume: number) => void;
    readonly AudioForPreview: import("react").ForwardRefExoticComponent<Omit<import("./audio/props.js").NativeAudioProps & {
        name?: string;
        volume?: import("./volume-prop.js").VolumeProp;
        playbackRate?: number;
        acceptableTimeShiftInSeconds?: number;
        allowAmplificationDuringRender?: boolean;
        _remotionInternalNeedsDurationCalculation?: boolean;
        _remotionInternalNativeLoopPassed?: boolean;
        toneFrequency?: number;
        useWebAudioApi?: boolean;
        pauseWhenBuffering?: boolean;
        showInTimeline?: boolean;
        delayRenderTimeoutInMilliseconds?: number;
        delayRenderRetries?: number;
        loopVolumeCurveBehavior?: import("./audio/use-audio-frame.js").LoopVolumeCurveBehavior;
        onError?: (err: Error) => void;
        audioStreamIndex?: number;
    } & {
        readonly shouldPreMountAudioTags: boolean;
        readonly onDuration: (src: string, durationInSeconds: number) => void;
        readonly pauseWhenBuffering: boolean;
        readonly _remotionInternalNativeLoopPassed: boolean;
        readonly _remotionInternalStack: string | null;
        readonly showInTimeline: boolean;
        readonly stack?: string | undefined;
        readonly onNativeError: React.ReactEventHandler<HTMLAudioElement>;
    }, "ref"> & import("react").RefAttributes<HTMLAudioElement>>;
    readonly OBJECTFIT_CONTAIN_CLASS_NAME: "__remotion_objectfitcontain";
    readonly InnerOffthreadVideo: import("react").FC<import("./video/props.js").AllOffthreadVideoProps>;
    readonly useBasicMediaInTimeline: ({ volume, mediaVolume, mediaType, src, displayName, trimBefore, trimAfter, playbackRate, }: {
        volume: import("./volume-prop.js").VolumeProp | undefined;
        mediaVolume: number;
        mediaType: "audio" | "video";
        src: string | undefined;
        displayName: string | null;
        trimBefore: number | undefined;
        trimAfter: number | undefined;
        playbackRate: number;
    }) => {
        volumes: string | number;
        duration: number;
        doesVolumeChange: boolean;
        nonce: number;
        rootId: string;
        isStudio: boolean;
        finalDisplayName: string;
    };
    readonly getInputPropsOverride: () => Record<string, unknown> | null;
    readonly setInputPropsOverride: (override: Record<string, unknown> | null) => void;
    readonly useVideoEnabled: () => boolean;
    readonly useAudioEnabled: () => boolean;
    readonly useIsPlayerBuffering: (bufferManager: {
        addBlock: (block: {
            id: string;
        }) => {
            unblock: () => void;
        };
        listenForBuffering: (callback: () => void) => {
            remove: () => void;
        };
        listenForResume: (callback: () => void) => {
            remove: () => void;
        };
        buffering: React.MutableRefObject<boolean>;
    }) => boolean;
};
export type { CompositionManagerContext, CompProps, LoggingContextValue, MediaVolumeContextValue, RemotionEnvironment, SerializedJSONWithCustomFields, SetMediaVolumeContextValue, SetTimelineContextValue, TCompMetadata, TComposition, TimelineContextValue, TRenderAsset, TSequence, WatchRemotionStaticFilesPayload, };
