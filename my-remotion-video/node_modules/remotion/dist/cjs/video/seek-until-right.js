"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.seekToTimeMultipleUntilRight = exports.seekToTime = void 0;
const is_approximately_the_same_1 = require("../is-approximately-the-same");
const seek_1 = require("../seek");
const roundTo6Commas = (num) => {
    return Math.round(num * 100000) / 100000;
};
const seekToTime = ({ element, desiredTime, logLevel, mountTime, }) => {
    if ((0, is_approximately_the_same_1.isApproximatelyTheSame)(element.currentTime, desiredTime)) {
        return {
            wait: Promise.resolve(desiredTime),
            cancel: () => { },
        };
    }
    (0, seek_1.seek)({
        logLevel,
        mediaRef: element,
        time: desiredTime,
        why: 'Seeking during rendering',
        mountTime,
    });
    let cancel;
    let cancelSeeked = null;
    const prom = new Promise((resolve) => {
        cancel = element.requestVideoFrameCallback((now, metadata) => {
            const displayIn = metadata.expectedDisplayTime - now;
            if (displayIn <= 0) {
                resolve(metadata.mediaTime);
                return;
            }
            setTimeout(() => {
                resolve(metadata.mediaTime);
            }, displayIn + 150);
        });
    });
    const waitForSeekedEvent = new Promise((resolve) => {
        const onDone = () => {
            resolve();
        };
        element.addEventListener('seeked', onDone, {
            once: true,
        });
        cancelSeeked = () => {
            element.removeEventListener('seeked', onDone);
        };
    });
    return {
        wait: Promise.all([prom, waitForSeekedEvent]).then(([time]) => time),
        cancel: () => {
            cancelSeeked === null || cancelSeeked === void 0 ? void 0 : cancelSeeked();
            element.cancelVideoFrameCallback(cancel);
        },
    };
};
exports.seekToTime = seekToTime;
const seekToTimeMultipleUntilRight = ({ element, desiredTime, fps, logLevel, mountTime, }) => {
    const threshold = 1 / fps / 2;
    let currentCancel = () => undefined;
    if (Number.isFinite(element.duration) &&
        element.currentTime >= element.duration &&
        desiredTime >= element.duration) {
        return {
            prom: Promise.resolve(),
            cancel: () => { },
        };
    }
    const prom = new Promise((resolve, reject) => {
        const firstSeek = (0, exports.seekToTime)({
            element,
            desiredTime: desiredTime + threshold,
            logLevel,
            mountTime,
        });
        firstSeek.wait.then((seekedTo) => {
            const difference = Math.abs(desiredTime - seekedTo);
            if (difference <= threshold) {
                return resolve();
            }
            const sign = desiredTime > seekedTo ? 1 : -1;
            const newSeek = (0, exports.seekToTime)({
                element,
                desiredTime: seekedTo + threshold * sign,
                logLevel,
                mountTime,
            });
            currentCancel = newSeek.cancel;
            newSeek.wait
                .then((newTime) => {
                const newDifference = Math.abs(desiredTime - newTime);
                if (roundTo6Commas(newDifference) <= roundTo6Commas(threshold)) {
                    return resolve();
                }
                const thirdSeek = (0, exports.seekToTime)({
                    element,
                    desiredTime: desiredTime + threshold,
                    logLevel,
                    mountTime,
                });
                currentCancel = thirdSeek.cancel;
                return thirdSeek.wait
                    .then(() => {
                    resolve();
                })
                    .catch((err) => {
                    reject(err);
                });
            })
                .catch((err) => {
                reject(err);
            });
        });
        currentCancel = firstSeek.cancel;
    });
    return {
        prom,
        cancel: () => {
            currentCancel();
        },
    };
};
exports.seekToTimeMultipleUntilRight = seekToTimeMultipleUntilRight;
