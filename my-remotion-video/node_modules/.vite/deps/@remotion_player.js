"use client";
import {
  NoReactInternals
} from "./chunk-YWH6WWVF.js";
import {
  Composition,
  Internals,
  interpolate,
  random
} from "./chunk-A22PLLWQ.js";
import {
  require_jsx_runtime
} from "./chunk-3OC7JQMP.js";
import "./chunk-2DERYF5V.js";
import {
  require_react
} from "./chunk-S5FHZHKU.js";
import {
  __publicField,
  __toESM
} from "./chunk-EQCVQC35.js";

// node_modules/@remotion/player/dist/esm/index.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_react8 = __toESM(require_react(), 1);
var import_react9 = __toESM(require_react(), 1);
var import_react10 = __toESM(require_react(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_react12 = __toESM(require_react(), 1);
var import_react13 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react14 = __toESM(require_react(), 1);
var import_react15 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react16 = __toESM(require_react(), 1);
var import_react17 = __toESM(require_react(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react18 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react19 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react20 = __toESM(require_react(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react21 = __toESM(require_react(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react22 = __toESM(require_react(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react23 = __toESM(require_react(), 1);
var import_react24 = __toESM(require_react(), 1);
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react25 = __toESM(require_react(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_react26 = __toESM(require_react(), 1);
var import_react27 = __toESM(require_react(), 1);
var import_react28 = __toESM(require_react(), 1);
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var ICON_SIZE = 25;
var fullscreenIconSize = 16;
var PlayIcon = () => {
  return (0, import_jsx_runtime.jsx)("svg", {
    width: ICON_SIZE,
    height: ICON_SIZE,
    viewBox: "0 0 25 25",
    fill: "none",
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M8 6.375C7.40904 8.17576 7.06921 10.2486 7.01438 12.3871C6.95955 14.5255 7.19163 16.6547 7.6875 18.5625C9.95364 18.2995 12.116 17.6164 14.009 16.5655C15.902 15.5147 17.4755 14.124 18.6088 12.5C17.5158 10.8949 15.9949 9.51103 14.1585 8.45082C12.3222 7.3906 10.2174 6.68116 8 6.375Z",
      fill: "white",
      stroke: "white",
      strokeWidth: "6.25",
      strokeLinejoin: "round"
    })
  });
};
var PauseIcon = () => {
  return (0, import_jsx_runtime.jsxs)("svg", {
    viewBox: "0 0 100 100",
    width: ICON_SIZE,
    height: ICON_SIZE,
    children: [
      (0, import_jsx_runtime.jsx)("rect", {
        x: "25",
        y: "20",
        width: "20",
        height: "60",
        fill: "#fff",
        ry: "5",
        rx: "5"
      }),
      (0, import_jsx_runtime.jsx)("rect", {
        x: "55",
        y: "20",
        width: "20",
        height: "60",
        fill: "#fff",
        ry: "5",
        rx: "5"
      })
    ]
  });
};
var FullscreenIcon = ({
  isFullscreen
}) => {
  const strokeWidth = 6;
  const viewSize = 32;
  const out = isFullscreen ? 0 : strokeWidth / 2;
  const middleInset = isFullscreen ? strokeWidth * 1.6 : strokeWidth / 2;
  const inset = isFullscreen ? strokeWidth * 1.6 : strokeWidth * 2;
  return (0, import_jsx_runtime.jsxs)("svg", {
    viewBox: `0 0 ${viewSize} ${viewSize}`,
    height: fullscreenIconSize,
    width: fullscreenIconSize,
    children: [
      (0, import_jsx_runtime.jsx)("path", {
        d: `
				M ${out} ${inset}
				L ${middleInset} ${middleInset}
				L ${inset} ${out}
				`,
        stroke: "#fff",
        strokeWidth,
        fill: "none"
      }),
      (0, import_jsx_runtime.jsx)("path", {
        d: `
				M ${viewSize - out} ${inset}
				L ${viewSize - middleInset} ${middleInset}
				L ${viewSize - inset} ${out}
				`,
        stroke: "#fff",
        strokeWidth,
        fill: "none"
      }),
      (0, import_jsx_runtime.jsx)("path", {
        d: `
				M ${out} ${viewSize - inset}
				L ${middleInset} ${viewSize - middleInset}
				L ${inset} ${viewSize - out}
				`,
        stroke: "#fff",
        strokeWidth,
        fill: "none"
      }),
      (0, import_jsx_runtime.jsx)("path", {
        d: `
				M ${viewSize - out} ${viewSize - inset}
				L ${viewSize - middleInset} ${viewSize - middleInset}
				L ${viewSize - inset} ${viewSize - out}
				`,
        stroke: "#fff",
        strokeWidth,
        fill: "none"
      })
    ]
  });
};
var VolumeOffIcon = () => {
  return (0, import_jsx_runtime.jsx)("svg", {
    width: ICON_SIZE,
    height: ICON_SIZE,
    viewBox: "0 0 24 24",
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M3.63 3.63a.996.996 0 000 1.41L7.29 8.7 7 9H4c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h3l3.29 3.29c.63.63 1.71.18 1.71-.71v-4.17l4.18 4.18c-.49.37-1.02.68-1.6.91-.36.15-.58.53-.58.92 0 .72.73 1.18 1.39.91.8-.33 1.55-.77 2.22-1.31l1.34 1.34a.996.996 0 101.41-1.41L5.05 3.63c-.39-.39-1.02-.39-1.42 0zM19 12c0 .82-.15 1.61-.41 2.34l1.53 1.53c.56-1.17.88-2.48.88-3.87 0-3.83-2.4-7.11-5.78-8.4-.59-.23-1.22.23-1.22.86v.19c0 .38.25.71.61.85C17.18 6.54 19 9.06 19 12zm-8.71-6.29l-.17.17L12 7.76V6.41c0-.89-1.08-1.33-1.71-.7zM16.5 12A4.5 4.5 0 0014 7.97v1.79l2.48 2.48c.01-.08.02-.16.02-.24z",
      fill: "#fff"
    })
  });
};
var VolumeOnIcon = () => {
  return (0, import_jsx_runtime.jsx)("svg", {
    width: ICON_SIZE,
    height: ICON_SIZE,
    viewBox: "0 0 24 24",
    children: (0, import_jsx_runtime.jsx)("path", {
      d: "M3 10v4c0 .55.45 1 1 1h3l3.29 3.29c.63.63 1.71.18 1.71-.71V6.41c0-.89-1.08-1.34-1.71-.71L7 9H4c-.55 0-1 .45-1 1zm13.5 2A4.5 4.5 0 0014 7.97v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 4.45v.2c0 .38.25.71.6.85C17.18 6.53 19 9.06 19 12s-1.82 5.47-4.4 6.5c-.36.14-.6.47-.6.85v.2c0 .63.63 1.07 1.21.85C18.6 19.11 21 15.84 21 12s-2.4-7.11-5.79-8.4c-.58-.23-1.21.22-1.21.85z",
      fill: "#fff"
    })
  });
};
var className = "__remotion_buffering_indicator";
var remotionBufferingAnimation = "__remotion_buffering_animation";
var playerStyle = {
  width: ICON_SIZE,
  height: ICON_SIZE,
  overflow: "hidden",
  lineHeight: "normal",
  fontSize: "inherit"
};
var studioStyle = {
  width: 14,
  height: 14,
  overflow: "hidden",
  lineHeight: "normal",
  fontSize: "inherit"
};
var BufferingIndicator = ({ type }) => {
  const style2 = type === "player" ? playerStyle : studioStyle;
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [
      (0, import_jsx_runtime2.jsx)("style", {
        type: "text/css",
        children: `
				@keyframes ${remotionBufferingAnimation} {
          0% {
            rotate: 0deg;
          }
          100% {
            rotate: 360deg;
          }
        }
        
        .${className} {
            animation: ${remotionBufferingAnimation} 1s linear infinite;
        }        
			`
      }),
      (0, import_jsx_runtime2.jsx)("div", {
        style: style2,
        children: (0, import_jsx_runtime2.jsx)("svg", {
          viewBox: type === "player" ? "0 0 22 22" : "0 0 18 18",
          style: style2,
          className,
          children: (0, import_jsx_runtime2.jsx)("path", {
            d: type === "player" ? "M 11 4 A 7 7 0 0 1 15.1145 16.66312" : "M 9 2 A 7 7 0 0 1 13.1145 14.66312",
            stroke: "white",
            strokeLinecap: "round",
            fill: "none",
            strokeWidth: 3
          })
        })
      })
    ]
  });
};
var calculatePlayerSize = ({
  currentSize,
  width,
  height,
  compositionWidth,
  compositionHeight
}) => {
  if (width !== void 0 && height === void 0) {
    return {
      aspectRatio: [compositionWidth, compositionHeight].join("/")
    };
  }
  if (height !== void 0 && width === void 0) {
    return {
      aspectRatio: [compositionWidth, compositionHeight].join("/")
    };
  }
  if (!currentSize) {
    return {
      width: compositionWidth,
      height: compositionHeight
    };
  }
  return {
    width: compositionWidth,
    height: compositionHeight
  };
};
var calculateCanvasTransformation = ({
  previewSize,
  compositionWidth,
  compositionHeight,
  canvasSize
}) => {
  const scale = Internals.calculateScale({
    canvasSize,
    compositionHeight,
    compositionWidth,
    previewSize
  });
  const correction = 0 - (1 - scale) / 2;
  const xCorrection = correction * compositionWidth;
  const yCorrection = correction * compositionHeight;
  const width = compositionWidth * scale;
  const height = compositionHeight * scale;
  const centerX = canvasSize.width / 2 - width / 2;
  const centerY = canvasSize.height / 2 - height / 2;
  return {
    centerX,
    centerY,
    xCorrection,
    yCorrection,
    scale
  };
};
var calculateOuterStyle = ({
  config,
  style: style2,
  canvasSize,
  overflowVisible,
  layout
}) => {
  if (!config) {
    return {};
  }
  return {
    position: "relative",
    overflow: overflowVisible ? "visible" : "hidden",
    ...calculatePlayerSize({
      compositionHeight: config.height,
      compositionWidth: config.width,
      currentSize: canvasSize,
      height: style2 == null ? void 0 : style2.height,
      width: style2 == null ? void 0 : style2.width
    }),
    opacity: layout ? 1 : 0,
    ...style2
  };
};
var calculateContainerStyle = ({
  config,
  layout,
  scale,
  overflowVisible
}) => {
  if (!config) {
    return {};
  }
  if (!layout) {
    return {
      position: "absolute",
      width: config.width,
      height: config.height,
      display: "flex",
      transform: `scale(${scale})`,
      overflow: overflowVisible ? "visible" : "hidden"
    };
  }
  return {
    position: "absolute",
    width: config.width,
    height: config.height,
    display: "flex",
    transform: `scale(${scale})`,
    marginLeft: layout.xCorrection,
    marginTop: layout.yCorrection,
    overflow: overflowVisible ? "visible" : "hidden"
  };
};
var calculateOuter = ({
  layout,
  scale,
  config,
  overflowVisible
}) => {
  if (!config) {
    return {};
  }
  if (!layout) {
    return {
      width: config.width * scale,
      height: config.height * scale,
      display: "flex",
      flexDirection: "column",
      position: "absolute",
      overflow: overflowVisible ? "visible" : "hidden"
    };
  }
  const { centerX, centerY } = layout;
  return {
    width: config.width * scale,
    height: config.height * scale,
    display: "flex",
    flexDirection: "column",
    position: "absolute",
    left: centerX,
    top: centerY,
    overflow: overflowVisible ? "visible" : "hidden"
  };
};
var PlayerEventEmitterContext = import_react.default.createContext(void 0);
var ThumbnailEmitterContext = import_react.default.createContext(void 0);
var PlayerEmitter = class {
  constructor() {
    __publicField(this, "listeners", {
      ended: [],
      error: [],
      pause: [],
      play: [],
      ratechange: [],
      scalechange: [],
      seeked: [],
      timeupdate: [],
      frameupdate: [],
      fullscreenchange: [],
      volumechange: [],
      mutechange: [],
      waiting: [],
      resume: []
    });
    __publicField(this, "dispatchSeek", (frame) => {
      this.dispatchEvent("seeked", {
        frame
      });
    });
    __publicField(this, "dispatchVolumeChange", (volume) => {
      this.dispatchEvent("volumechange", {
        volume
      });
    });
    __publicField(this, "dispatchPause", () => {
      this.dispatchEvent("pause", void 0);
    });
    __publicField(this, "dispatchPlay", () => {
      this.dispatchEvent("play", void 0);
    });
    __publicField(this, "dispatchEnded", () => {
      this.dispatchEvent("ended", void 0);
    });
    __publicField(this, "dispatchRateChange", (playbackRate) => {
      this.dispatchEvent("ratechange", {
        playbackRate
      });
    });
    __publicField(this, "dispatchScaleChange", (scale) => {
      this.dispatchEvent("scalechange", {
        scale
      });
    });
    __publicField(this, "dispatchError", (error) => {
      this.dispatchEvent("error", {
        error
      });
    });
    __publicField(this, "dispatchTimeUpdate", (event) => {
      this.dispatchEvent("timeupdate", event);
    });
    __publicField(this, "dispatchFrameUpdate", (event) => {
      this.dispatchEvent("frameupdate", event);
    });
    __publicField(this, "dispatchFullscreenChange", (event) => {
      this.dispatchEvent("fullscreenchange", event);
    });
    __publicField(this, "dispatchMuteChange", (event) => {
      this.dispatchEvent("mutechange", event);
    });
    __publicField(this, "dispatchWaiting", (event) => {
      this.dispatchEvent("waiting", event);
    });
    __publicField(this, "dispatchResume", (event) => {
      this.dispatchEvent("resume", event);
    });
  }
  addEventListener(name, callback) {
    this.listeners[name].push(callback);
  }
  removeEventListener(name, callback) {
    this.listeners[name] = this.listeners[name].filter((l) => l !== callback);
  }
  dispatchEvent(dispatchName, context) {
    this.listeners[dispatchName].forEach((callback) => {
      callback({ detail: context });
    });
  }
};
var ThumbnailEmitter = class {
  constructor() {
    __publicField(this, "listeners", {
      error: [],
      waiting: [],
      resume: []
    });
    __publicField(this, "dispatchError", (error) => {
      this.dispatchEvent("error", {
        error
      });
    });
    __publicField(this, "dispatchWaiting", (event) => {
      this.dispatchEvent("waiting", event);
    });
    __publicField(this, "dispatchResume", (event) => {
      this.dispatchEvent("resume", event);
    });
  }
  addEventListener(name, callback) {
    this.listeners[name].push(callback);
  }
  removeEventListener(name, callback) {
    this.listeners[name] = this.listeners[name].filter((l) => l !== callback);
  }
  dispatchEvent(dispatchName, context) {
    this.listeners[dispatchName].forEach((callback) => {
      callback({ detail: context });
    });
  }
};
var useBufferStateEmitter = (emitter) => {
  const bufferManager = (0, import_react3.useContext)(Internals.BufferingContextReact);
  if (!bufferManager) {
    throw new Error("BufferingContextReact not found");
  }
  (0, import_react3.useEffect)(() => {
    const clear1 = bufferManager.listenForBuffering(() => {
      bufferManager.buffering.current = true;
      emitter.dispatchWaiting({});
    });
    const clear2 = bufferManager.listenForResume(() => {
      bufferManager.buffering.current = false;
      emitter.dispatchResume({});
    });
    return () => {
      clear1.remove();
      clear2.remove();
    };
  }, [bufferManager, emitter]);
};
var PlayerEmitterProvider = ({ children, currentPlaybackRate }) => {
  const [emitter] = (0, import_react2.useState)(() => new PlayerEmitter());
  const bufferManager = (0, import_react2.useContext)(Internals.BufferingContextReact);
  if (!bufferManager) {
    throw new Error("BufferingContextReact not found");
  }
  (0, import_react2.useEffect)(() => {
    if (currentPlaybackRate) {
      emitter.dispatchRateChange(currentPlaybackRate);
    }
  }, [emitter, currentPlaybackRate]);
  useBufferStateEmitter(emitter);
  return (0, import_jsx_runtime3.jsx)(PlayerEventEmitterContext.Provider, {
    value: emitter,
    children
  });
};
var useFrameImperative = () => {
  const frame = Internals.Timeline.useTimelinePosition();
  const frameRef = (0, import_react4.useRef)(frame);
  frameRef.current = frame;
  const getCurrentFrame = (0, import_react4.useCallback)(() => {
    return frameRef.current;
  }, []);
  return getCurrentFrame;
};
var useHoverState = (ref, hideControlsWhenPointerDoesntMove) => {
  const [hovered, setHovered] = (0, import_react5.useState)(false);
  (0, import_react5.useEffect)(() => {
    const { current } = ref;
    if (!current) {
      return;
    }
    let hoverTimeout;
    const addHoverTimeout = () => {
      if (hideControlsWhenPointerDoesntMove) {
        clearTimeout(hoverTimeout);
        hoverTimeout = setTimeout(() => {
          setHovered(false);
        }, hideControlsWhenPointerDoesntMove === true ? 3e3 : hideControlsWhenPointerDoesntMove);
      }
    };
    const onHover = () => {
      setHovered(true);
      addHoverTimeout();
    };
    const onLeave = () => {
      setHovered(false);
      clearTimeout(hoverTimeout);
    };
    const onMove = () => {
      setHovered(true);
      addHoverTimeout();
    };
    current.addEventListener("mouseenter", onHover);
    current.addEventListener("mouseleave", onLeave);
    current.addEventListener("mousemove", onMove);
    return () => {
      current.removeEventListener("mouseenter", onHover);
      current.removeEventListener("mouseleave", onLeave);
      current.removeEventListener("mousemove", onMove);
      clearTimeout(hoverTimeout);
    };
  }, [hideControlsWhenPointerDoesntMove, ref]);
  return hovered;
};
var usePlayer = () => {
  const [playing, setPlaying, imperativePlaying] = Internals.Timeline.usePlayingState();
  const [hasPlayed, setHasPlayed] = (0, import_react8.useState)(false);
  const frame = Internals.Timeline.useTimelinePosition();
  const playStart = (0, import_react8.useRef)(frame);
  const setFrame = Internals.Timeline.useTimelineSetFrame();
  const setTimelinePosition = Internals.Timeline.useTimelineSetFrame();
  const audioContext = (0, import_react8.useContext)(Internals.SharedAudioContext);
  const { audioAndVideoTags } = (0, import_react8.useContext)(Internals.Timeline.TimelineContext);
  const frameRef = (0, import_react8.useRef)(frame);
  frameRef.current = frame;
  const video = Internals.useVideo();
  const config = Internals.useUnsafeVideoConfig();
  const emitter = (0, import_react8.useContext)(PlayerEventEmitterContext);
  const lastFrame = ((config == null ? void 0 : config.durationInFrames) ?? 1) - 1;
  const isLastFrame = frame === lastFrame;
  const isFirstFrame = frame === 0;
  if (!emitter) {
    throw new TypeError("Expected Player event emitter context");
  }
  const bufferingContext = (0, import_react8.useContext)(Internals.BufferingContextReact);
  if (!bufferingContext) {
    throw new Error("Missing the buffering context. Most likely you have a Remotion version mismatch.");
  }
  const { buffering } = bufferingContext;
  const seek = (0, import_react8.useCallback)((newFrame) => {
    if (video == null ? void 0 : video.id) {
      setTimelinePosition((c) => ({ ...c, [video.id]: newFrame }));
    }
    frameRef.current = newFrame;
    emitter.dispatchSeek(newFrame);
  }, [emitter, setTimelinePosition, video == null ? void 0 : video.id]);
  const play = (0, import_react8.useCallback)((e) => {
    var _a;
    if (imperativePlaying.current) {
      return;
    }
    setHasPlayed(true);
    if (isLastFrame) {
      seek(0);
    }
    (_a = audioContext == null ? void 0 : audioContext.audioContext) == null ? void 0 : _a.resume();
    if (audioContext && audioContext.numberOfAudioTags > 0 && e) {
      audioContext.playAllAudios();
    }
    audioAndVideoTags.current.forEach((a) => a.play("player play() was called and playing audio from a click"));
    imperativePlaying.current = true;
    setPlaying(true);
    playStart.current = frameRef.current;
    emitter.dispatchPlay();
  }, [
    imperativePlaying,
    isLastFrame,
    audioContext,
    setPlaying,
    emitter,
    seek,
    audioAndVideoTags
  ]);
  const pause = (0, import_react8.useCallback)(() => {
    var _a;
    if (imperativePlaying.current) {
      imperativePlaying.current = false;
      setPlaying(false);
      emitter.dispatchPause();
      (_a = audioContext == null ? void 0 : audioContext.audioContext) == null ? void 0 : _a.suspend();
    }
  }, [emitter, imperativePlaying, setPlaying, audioContext]);
  const pauseAndReturnToPlayStart = (0, import_react8.useCallback)(() => {
    if (imperativePlaying.current) {
      imperativePlaying.current = false;
      frameRef.current = playStart.current;
      if (config) {
        setTimelinePosition((c) => ({
          ...c,
          [config.id]: playStart.current
        }));
        setPlaying(false);
        emitter.dispatchPause();
      }
    }
  }, [config, emitter, imperativePlaying, setPlaying, setTimelinePosition]);
  const videoId = video == null ? void 0 : video.id;
  const frameBack = (0, import_react8.useCallback)((frames) => {
    if (!videoId) {
      return null;
    }
    if (imperativePlaying.current) {
      return;
    }
    setFrame((c) => {
      const prevFrame = c[videoId] ?? window.remotion_initialFrame ?? 0;
      const newFrame = Math.max(0, prevFrame - frames);
      if (prevFrame === newFrame) {
        return c;
      }
      return {
        ...c,
        [videoId]: newFrame
      };
    });
  }, [imperativePlaying, setFrame, videoId]);
  const frameForward = (0, import_react8.useCallback)((frames) => {
    if (!videoId) {
      return null;
    }
    if (imperativePlaying.current) {
      return;
    }
    setFrame((c) => {
      const prevFrame = c[videoId] ?? window.remotion_initialFrame ?? 0;
      const newFrame = Math.min(lastFrame, prevFrame + frames);
      if (prevFrame === newFrame) {
        return c;
      }
      return {
        ...c,
        [videoId]: newFrame
      };
    });
  }, [videoId, imperativePlaying, lastFrame, setFrame]);
  const toggle = (0, import_react8.useCallback)((e) => {
    if (imperativePlaying.current) {
      pause();
    } else {
      play(e);
    }
  }, [imperativePlaying, pause, play]);
  const returnValue = (0, import_react8.useMemo)(() => {
    return {
      frameBack,
      frameForward,
      isLastFrame,
      emitter,
      playing,
      play,
      pause,
      seek,
      isFirstFrame,
      getCurrentFrame: () => frameRef.current,
      isPlaying: () => imperativePlaying.current,
      isBuffering: () => buffering.current,
      pauseAndReturnToPlayStart,
      hasPlayed,
      toggle
    };
  }, [
    buffering,
    emitter,
    frameBack,
    frameForward,
    hasPlayed,
    imperativePlaying,
    isFirstFrame,
    isLastFrame,
    pause,
    pauseAndReturnToPlayStart,
    play,
    playing,
    seek,
    toggle
  ]);
  return returnValue;
};
var useBrowserMediaSession = ({
  browserMediaControlsBehavior,
  videoConfig,
  playbackRate
}) => {
  const { playing, pause, play, emitter, getCurrentFrame, seek } = usePlayer();
  (0, import_react7.useEffect)(() => {
    if (!navigator.mediaSession) {
      return;
    }
    if (browserMediaControlsBehavior.mode === "do-nothing") {
      return;
    }
    if (playing) {
      navigator.mediaSession.playbackState = "playing";
    } else {
      navigator.mediaSession.playbackState = "paused";
    }
  }, [browserMediaControlsBehavior.mode, playing]);
  (0, import_react7.useEffect)(() => {
    if (!navigator.mediaSession) {
      return;
    }
    if (browserMediaControlsBehavior.mode === "do-nothing") {
      return;
    }
    const onTimeUpdate = () => {
      if (!videoConfig) {
        return;
      }
      if (navigator.mediaSession) {
        navigator.mediaSession.setPositionState({
          duration: videoConfig.durationInFrames / videoConfig.fps,
          playbackRate,
          position: getCurrentFrame() / videoConfig.fps
        });
      }
    };
    emitter.addEventListener("timeupdate", onTimeUpdate);
    return () => {
      emitter.removeEventListener("timeupdate", onTimeUpdate);
    };
  }, [
    browserMediaControlsBehavior.mode,
    emitter,
    getCurrentFrame,
    playbackRate,
    videoConfig
  ]);
  (0, import_react7.useEffect)(() => {
    if (!navigator.mediaSession) {
      return;
    }
    if (browserMediaControlsBehavior.mode === "do-nothing") {
      return;
    }
    navigator.mediaSession.setActionHandler("play", () => {
      if (browserMediaControlsBehavior.mode === "register-media-session") {
        play();
      }
    });
    navigator.mediaSession.setActionHandler("pause", () => {
      if (browserMediaControlsBehavior.mode === "register-media-session") {
        pause();
      }
    });
    navigator.mediaSession.setActionHandler("seekto", (event) => {
      if (browserMediaControlsBehavior.mode === "register-media-session" && event.seekTime !== void 0 && videoConfig) {
        seek(Math.round(event.seekTime * videoConfig.fps));
      }
    });
    navigator.mediaSession.setActionHandler("seekbackward", () => {
      if (browserMediaControlsBehavior.mode === "register-media-session" && videoConfig) {
        seek(Math.max(0, Math.round((getCurrentFrame() - 10) * videoConfig.fps)));
      }
    });
    navigator.mediaSession.setActionHandler("seekforward", () => {
      if (browserMediaControlsBehavior.mode === "register-media-session" && videoConfig) {
        seek(Math.max(videoConfig.durationInFrames - 1, Math.round((getCurrentFrame() + 10) * videoConfig.fps)));
      }
    });
    navigator.mediaSession.setActionHandler("previoustrack", () => {
      if (browserMediaControlsBehavior.mode === "register-media-session") {
        seek(0);
      }
    });
    return () => {
      navigator.mediaSession.metadata = null;
      navigator.mediaSession.setActionHandler("play", null);
      navigator.mediaSession.setActionHandler("pause", null);
      navigator.mediaSession.setActionHandler("seekto", null);
      navigator.mediaSession.setActionHandler("seekbackward", null);
      navigator.mediaSession.setActionHandler("seekforward", null);
      navigator.mediaSession.setActionHandler("previoustrack", null);
    };
  }, [
    browserMediaControlsBehavior.mode,
    getCurrentFrame,
    pause,
    play,
    seek,
    videoConfig
  ]);
};
var calculateNextFrame = ({
  time,
  currentFrame: startFrame,
  playbackSpeed,
  fps,
  actualLastFrame,
  actualFirstFrame,
  framesAdvanced,
  shouldLoop
}) => {
  const op = playbackSpeed < 0 ? Math.ceil : Math.floor;
  const framesToAdvance = op(time * playbackSpeed / (1e3 / fps)) - framesAdvanced;
  const nextFrame = framesToAdvance + startFrame;
  const isCurrentFrameOutside = startFrame > actualLastFrame || startFrame < actualFirstFrame;
  const isNextFrameOutside = nextFrame > actualLastFrame || nextFrame < actualFirstFrame;
  const hasEnded = !shouldLoop && isNextFrameOutside && !isCurrentFrameOutside;
  if (playbackSpeed > 0) {
    if (isNextFrameOutside) {
      return {
        nextFrame: actualFirstFrame,
        framesToAdvance,
        hasEnded
      };
    }
    return { nextFrame, framesToAdvance, hasEnded };
  }
  if (isNextFrameOutside) {
    return { nextFrame: actualLastFrame, framesToAdvance, hasEnded };
  }
  return { nextFrame, framesToAdvance, hasEnded };
};
var getIsBackgrounded = () => {
  if (typeof document === "undefined") {
    return false;
  }
  return document.visibilityState === "hidden";
};
var useIsBackgrounded = () => {
  const isBackgrounded = (0, import_react9.useRef)(getIsBackgrounded());
  (0, import_react9.useEffect)(() => {
    const onVisibilityChange = () => {
      isBackgrounded.current = getIsBackgrounded();
    };
    document.addEventListener("visibilitychange", onVisibilityChange);
    return () => {
      document.removeEventListener("visibilitychange", onVisibilityChange);
    };
  }, []);
  return isBackgrounded;
};
var usePlayback = ({
  loop,
  playbackRate,
  moveToBeginningWhenEnded,
  inFrame,
  outFrame,
  browserMediaControlsBehavior,
  getCurrentFrame
}) => {
  const config = Internals.useUnsafeVideoConfig();
  const frame = Internals.Timeline.useTimelinePosition();
  const { playing, pause, emitter } = usePlayer();
  const setFrame = Internals.Timeline.useTimelineSetFrame();
  const isBackgroundedRef = useIsBackgrounded();
  const lastTimeUpdateEvent = (0, import_react6.useRef)(null);
  const context = (0, import_react6.useContext)(Internals.BufferingContextReact);
  if (!context) {
    throw new Error("Missing the buffering context. Most likely you have a Remotion version mismatch.");
  }
  useBrowserMediaSession({
    browserMediaControlsBehavior,
    playbackRate,
    videoConfig: config
  });
  (0, import_react6.useEffect)(() => {
    if (!config) {
      return;
    }
    if (!playing) {
      return;
    }
    let hasBeenStopped = false;
    let reqAnimFrameCall = null;
    let startedTime = performance.now();
    let framesAdvanced = 0;
    const cancelQueuedFrame = () => {
      if (reqAnimFrameCall !== null) {
        if (reqAnimFrameCall.type === "raf") {
          cancelAnimationFrame(reqAnimFrameCall.id);
        } else {
          clearTimeout(reqAnimFrameCall.id);
        }
      }
    };
    const stop = () => {
      hasBeenStopped = true;
      cancelQueuedFrame();
    };
    const callback = () => {
      if (hasBeenStopped) {
        return;
      }
      const time = performance.now() - startedTime;
      const actualLastFrame = outFrame ?? config.durationInFrames - 1;
      const actualFirstFrame = inFrame ?? 0;
      const currentFrame = getCurrentFrame();
      const { nextFrame, framesToAdvance, hasEnded } = calculateNextFrame({
        time,
        currentFrame,
        playbackSpeed: playbackRate,
        fps: config.fps,
        actualFirstFrame,
        actualLastFrame,
        framesAdvanced,
        shouldLoop: loop
      });
      framesAdvanced += framesToAdvance;
      if (nextFrame !== getCurrentFrame() && (!hasEnded || moveToBeginningWhenEnded)) {
        setFrame((c) => ({ ...c, [config.id]: nextFrame }));
      }
      if (hasEnded) {
        stop();
        pause();
        emitter.dispatchEnded();
        return;
      }
      queueNextFrame();
    };
    const queueNextFrame = () => {
      if (context.buffering.current) {
        const stopListening = context.listenForResume(() => {
          stopListening.remove();
          startedTime = performance.now();
          framesAdvanced = 0;
          queueNextFrame();
        });
        return;
      }
      if (isBackgroundedRef.current) {
        reqAnimFrameCall = {
          type: "timeout",
          id: setTimeout(callback, 1e3 / config.fps)
        };
        return;
      }
      reqAnimFrameCall = { type: "raf", id: requestAnimationFrame(callback) };
    };
    queueNextFrame();
    const onVisibilityChange = () => {
      if (document.visibilityState === "visible") {
        return;
      }
      cancelQueuedFrame();
      callback();
    };
    window.addEventListener("visibilitychange", onVisibilityChange);
    return () => {
      window.removeEventListener("visibilitychange", onVisibilityChange);
      stop();
    };
  }, [
    config,
    loop,
    pause,
    playing,
    setFrame,
    emitter,
    playbackRate,
    inFrame,
    outFrame,
    moveToBeginningWhenEnded,
    isBackgroundedRef,
    getCurrentFrame,
    context
  ]);
  (0, import_react6.useEffect)(() => {
    const interval = setInterval(() => {
      if (lastTimeUpdateEvent.current === getCurrentFrame()) {
        return;
      }
      emitter.dispatchTimeUpdate({ frame: getCurrentFrame() });
      lastTimeUpdateEvent.current = getCurrentFrame();
    }, 250);
    return () => clearInterval(interval);
  }, [emitter, getCurrentFrame]);
  (0, import_react6.useEffect)(() => {
    emitter.dispatchFrameUpdate({ frame });
  }, [emitter, frame]);
};
var elementSizeHooks = [];
var updateAllElementsSizes = () => {
  for (const listener of elementSizeHooks) {
    listener();
  }
};
var useElementSize = (ref, options) => {
  const [size, setSize] = (0, import_react10.useState)(() => {
    if (!ref.current) {
      return null;
    }
    const rect = ref.current.getClientRects();
    if (!rect[0]) {
      return null;
    }
    return {
      width: rect[0].width,
      height: rect[0].height,
      left: rect[0].x,
      top: rect[0].y,
      windowSize: {
        height: window.innerHeight,
        width: window.innerWidth
      }
    };
  });
  const observer = (0, import_react10.useMemo)(() => {
    if (typeof ResizeObserver === "undefined") {
      return null;
    }
    return new ResizeObserver((entries) => {
      const { contentRect, target } = entries[0];
      const newSize = target.getClientRects();
      if (!(newSize == null ? void 0 : newSize[0])) {
        setSize(null);
        return;
      }
      const probableCssParentScale = contentRect.width === 0 ? 1 : newSize[0].width / contentRect.width;
      const width = options.shouldApplyCssTransforms || probableCssParentScale === 0 ? newSize[0].width : newSize[0].width * (1 / probableCssParentScale);
      const height = options.shouldApplyCssTransforms || probableCssParentScale === 0 ? newSize[0].height : newSize[0].height * (1 / probableCssParentScale);
      setSize((prevState) => {
        const isSame = prevState && prevState.width === width && prevState.height === height && prevState.left === newSize[0].x && prevState.top === newSize[0].y && prevState.windowSize.height === window.innerHeight && prevState.windowSize.width === window.innerWidth;
        if (isSame) {
          return prevState;
        }
        return {
          width,
          height,
          left: newSize[0].x,
          top: newSize[0].y,
          windowSize: {
            height: window.innerHeight,
            width: window.innerWidth
          }
        };
      });
    });
  }, [options.shouldApplyCssTransforms]);
  const updateSize = (0, import_react10.useCallback)(() => {
    if (!ref.current) {
      return;
    }
    const rect = ref.current.getClientRects();
    if (!rect[0]) {
      setSize(null);
      return;
    }
    setSize((prevState) => {
      const isSame = prevState && prevState.width === rect[0].width && prevState.height === rect[0].height && prevState.left === rect[0].x && prevState.top === rect[0].y && prevState.windowSize.height === window.innerHeight && prevState.windowSize.width === window.innerWidth;
      if (isSame) {
        return prevState;
      }
      return {
        width: rect[0].width,
        height: rect[0].height,
        left: rect[0].x,
        top: rect[0].y,
        windowSize: {
          height: window.innerHeight,
          width: window.innerWidth
        }
      };
    });
  }, [ref]);
  (0, import_react10.useEffect)(() => {
    if (!observer) {
      return;
    }
    const { current } = ref;
    if (current) {
      observer.observe(current);
    }
    return () => {
      if (current) {
        observer.unobserve(current);
      }
    };
  }, [observer, ref, updateSize]);
  (0, import_react10.useEffect)(() => {
    if (!options.triggerOnWindowResize) {
      return;
    }
    window.addEventListener("resize", updateSize);
    return () => {
      window.removeEventListener("resize", updateSize);
    };
  }, [options.triggerOnWindowResize, updateSize]);
  (0, import_react10.useEffect)(() => {
    elementSizeHooks.push(updateSize);
    return () => {
      elementSizeHooks = elementSizeHooks.filter((e) => e !== updateSize);
    };
  }, [updateSize]);
  return (0, import_react10.useMemo)(() => {
    if (!size) {
      return null;
    }
    return { ...size, refresh: updateSize };
  }, [size, updateSize]);
};
var DefaultPlayPauseButton = ({ playing, buffering }) => {
  if (playing && buffering) {
    return (0, import_jsx_runtime4.jsx)(BufferingIndicator, {
      type: "player"
    });
  }
  if (playing) {
    return (0, import_jsx_runtime4.jsx)(PauseIcon, {});
  }
  return (0, import_jsx_runtime4.jsx)(PlayIcon, {});
};
var KNOB_SIZE = 12;
var BAR_HEIGHT = 5;
var DefaultVolumeSlider = ({
  volume,
  isVertical,
  onBlur,
  inputRef,
  setVolume
}) => {
  const sliderContainer = (0, import_react15.useMemo)(() => {
    const paddingLeft = 5;
    const common = {
      paddingLeft,
      height: ICON_SIZE,
      width: VOLUME_SLIDER_WIDTH,
      display: "inline-flex",
      alignItems: "center"
    };
    if (isVertical) {
      return {
        ...common,
        position: "absolute",
        transform: `rotate(-90deg) translateX(${VOLUME_SLIDER_WIDTH / 2 + ICON_SIZE / 2}px)`
      };
    }
    return {
      ...common
    };
  }, [isVertical]);
  const randomId = typeof import_react15.default.useId === "undefined" ? "volume-slider" : import_react15.default.useId();
  const [randomClass] = (0, import_react15.useState)(() => `__remotion-volume-slider-${random(randomId)}`.replace(".", ""));
  const onVolumeChange = (0, import_react15.useCallback)((e) => {
    setVolume(parseFloat(e.target.value));
  }, [setVolume]);
  const inputStyle = (0, import_react15.useMemo)(() => {
    const commonStyle = {
      WebkitAppearance: "none",
      backgroundColor: "rgba(255, 255, 255, 0.5)",
      borderRadius: BAR_HEIGHT / 2,
      cursor: "pointer",
      height: BAR_HEIGHT,
      width: VOLUME_SLIDER_WIDTH,
      backgroundImage: `linear-gradient(
				to right,
				white ${volume * 100}%, rgba(255, 255, 255, 0) ${volume * 100}%
			)`
    };
    if (isVertical) {
      return {
        ...commonStyle,
        bottom: ICON_SIZE + VOLUME_SLIDER_WIDTH / 2
      };
    }
    return commonStyle;
  }, [isVertical, volume]);
  const sliderStyle = `
	.${randomClass}::-webkit-slider-thumb {
		-webkit-appearance: none;
		background-color: white;
		border-radius: ${KNOB_SIZE / 2}px;
		box-shadow: 0 0 2px black;
		height: ${KNOB_SIZE}px;
		width: ${KNOB_SIZE}px;
	}

	.${randomClass}::-moz-range-thumb {
		-webkit-appearance: none;
		background-color: white;
		border-radius: ${KNOB_SIZE / 2}px;
		box-shadow: 0 0 2px black;
		height: ${KNOB_SIZE}px;
		width: ${KNOB_SIZE}px;
	}
`;
  return (0, import_jsx_runtime5.jsxs)("div", {
    style: sliderContainer,
    children: [
      (0, import_jsx_runtime5.jsx)("style", {
        dangerouslySetInnerHTML: {
          __html: sliderStyle
        }
      }),
      (0, import_jsx_runtime5.jsx)("input", {
        ref: inputRef,
        "aria-label": "Change volume",
        className: randomClass,
        max: 1,
        min: 0,
        onBlur,
        onChange: onVolumeChange,
        step: 0.01,
        type: "range",
        value: volume,
        style: inputStyle
      })
    ]
  });
};
var renderDefaultVolumeSlider = (props) => {
  return (0, import_jsx_runtime5.jsx)(DefaultVolumeSlider, {
    ...props
  });
};
var VOLUME_SLIDER_WIDTH = 100;
var MediaVolumeSlider = ({ displayVerticalVolumeSlider, renderMuteButton, renderVolumeSlider }) => {
  const [mediaMuted, setMediaMuted] = Internals.useMediaMutedState();
  const [mediaVolume, setMediaVolume] = Internals.useMediaVolumeState();
  const [focused, setFocused] = (0, import_react14.useState)(false);
  const parentDivRef = (0, import_react14.useRef)(null);
  const inputRef = (0, import_react14.useRef)(null);
  const hover = useHoverState(parentDivRef, false);
  const onBlur = (0, import_react14.useCallback)(() => {
    setTimeout(() => {
      if (inputRef.current && document.activeElement !== inputRef.current) {
        setFocused(false);
      }
    }, 10);
  }, []);
  const isVolume0 = mediaVolume === 0;
  const onClick = (0, import_react14.useCallback)(() => {
    if (isVolume0) {
      setMediaVolume(1);
      setMediaMuted(false);
      return;
    }
    setMediaMuted((mute) => !mute);
  }, [isVolume0, setMediaMuted, setMediaVolume]);
  const parentDivStyle = (0, import_react14.useMemo)(() => {
    return {
      display: "inline-flex",
      background: "none",
      border: "none",
      justifyContent: "center",
      alignItems: "center",
      touchAction: "none",
      ...displayVerticalVolumeSlider && { position: "relative" }
    };
  }, [displayVerticalVolumeSlider]);
  const volumeContainer = (0, import_react14.useMemo)(() => {
    return {
      display: "inline",
      width: ICON_SIZE,
      height: ICON_SIZE,
      cursor: "pointer",
      appearance: "none",
      background: "none",
      border: "none",
      padding: 0
    };
  }, []);
  const renderDefaultMuteButton = (0, import_react14.useCallback)(({ muted, volume }) => {
    const isMutedOrZero = muted || volume === 0;
    return (0, import_jsx_runtime6.jsx)("button", {
      "aria-label": isMutedOrZero ? "Unmute sound" : "Mute sound",
      title: isMutedOrZero ? "Unmute sound" : "Mute sound",
      onClick,
      onBlur,
      onFocus: () => setFocused(true),
      style: volumeContainer,
      type: "button",
      children: isMutedOrZero ? (0, import_jsx_runtime6.jsx)(VolumeOffIcon, {}) : (0, import_jsx_runtime6.jsx)(VolumeOnIcon, {})
    });
  }, [onBlur, onClick, volumeContainer]);
  const muteButton = (0, import_react14.useMemo)(() => {
    return renderMuteButton ? renderMuteButton({ muted: mediaMuted, volume: mediaVolume }) : renderDefaultMuteButton({ muted: mediaMuted, volume: mediaVolume });
  }, [mediaMuted, mediaVolume, renderDefaultMuteButton, renderMuteButton]);
  const volumeSlider = (0, import_react14.useMemo)(() => {
    return (focused || hover) && !mediaMuted && !Internals.isIosSafari() ? (renderVolumeSlider ?? renderDefaultVolumeSlider)({
      isVertical: displayVerticalVolumeSlider,
      volume: mediaVolume,
      onBlur: () => setFocused(false),
      inputRef,
      setVolume: setMediaVolume
    }) : null;
  }, [
    displayVerticalVolumeSlider,
    focused,
    hover,
    mediaMuted,
    mediaVolume,
    renderVolumeSlider,
    setMediaVolume
  ]);
  return (0, import_jsx_runtime6.jsxs)("div", {
    ref: parentDivRef,
    style: parentDivStyle,
    children: [
      muteButton,
      volumeSlider
    ]
  });
};
function useComponentVisible(initialIsVisible) {
  const [isComponentVisible, setIsComponentVisible] = (0, import_react17.useState)(initialIsVisible);
  const ref = (0, import_react17.useRef)(null);
  (0, import_react17.useEffect)(() => {
    const handleClickOutside = (event) => {
      if (ref.current && !ref.current.contains(event.target)) {
        setIsComponentVisible(false);
      }
    };
    document.addEventListener("pointerup", handleClickOutside, true);
    return () => {
      document.removeEventListener("pointerup", handleClickOutside, true);
    };
  }, []);
  return { ref, isComponentVisible, setIsComponentVisible };
}
var BOTTOM = 35;
var THRESHOLD = 70;
var rateDiv = {
  height: 30,
  paddingRight: 15,
  paddingLeft: 12,
  display: "flex",
  flexDirection: "row",
  alignItems: "center"
};
var checkmarkContainer = {
  width: 22,
  display: "flex",
  alignItems: "center"
};
var checkmarkStyle = {
  width: 14,
  height: 14,
  color: "black"
};
var Checkmark = () => (0, import_jsx_runtime7.jsx)("svg", {
  viewBox: "0 0 512 512",
  style: checkmarkStyle,
  children: (0, import_jsx_runtime7.jsx)("path", {
    fill: "currentColor",
    d: "M435.848 83.466L172.804 346.51l-96.652-96.652c-4.686-4.686-12.284-4.686-16.971 0l-28.284 28.284c-4.686 4.686-4.686 12.284 0 16.971l133.421 133.421c4.686 4.686 12.284 4.686 16.971 0l299.813-299.813c4.686-4.686 4.686-12.284 0-16.971l-28.284-28.284c-4.686-4.686-12.284-4.686-16.97 0z"
  })
});
var formatPlaybackRate = (rate) => {
  const str = rate.toString();
  return str.includes(".") ? str : str + ".0";
};
var PlaybackrateOption = ({ rate, onSelect, selectedRate, keyboardSelectedRate }) => {
  const onClick = (0, import_react16.useCallback)((e) => {
    e.stopPropagation();
    e.preventDefault();
    onSelect(rate);
  }, [onSelect, rate]);
  const [hovered, setHovered] = (0, import_react16.useState)(false);
  const onMouseEnter = (0, import_react16.useCallback)(() => {
    setHovered(true);
  }, []);
  const onMouseLeave = (0, import_react16.useCallback)(() => {
    setHovered(false);
  }, []);
  const isFocused = keyboardSelectedRate === rate;
  const actualStyle = (0, import_react16.useMemo)(() => {
    return {
      ...rateDiv,
      backgroundColor: hovered || isFocused ? "#eee" : "transparent"
    };
  }, [hovered, isFocused]);
  return (0, import_jsx_runtime7.jsxs)("div", {
    onMouseEnter,
    onMouseLeave,
    tabIndex: 0,
    style: actualStyle,
    onClick,
    children: [
      (0, import_jsx_runtime7.jsx)("div", {
        style: checkmarkContainer,
        children: rate === selectedRate ? (0, import_jsx_runtime7.jsx)(Checkmark, {}) : null
      }),
      formatPlaybackRate(rate),
      "x"
    ]
  }, rate);
};
var PlaybackPopup = ({ setIsComponentVisible, playbackRates, canvasSize }) => {
  const { setPlaybackRate, playbackRate } = (0, import_react16.useContext)(Internals.Timeline.TimelineContext);
  const [keyboardSelectedRate, setKeyboardSelectedRate] = (0, import_react16.useState)(playbackRate);
  (0, import_react16.useEffect)(() => {
    const listener = (e) => {
      e.preventDefault();
      if (e.key === "ArrowUp") {
        const currentIndex = playbackRates.findIndex((rate) => rate === keyboardSelectedRate);
        if (currentIndex === 0) {
          return;
        }
        if (currentIndex === -1) {
          setKeyboardSelectedRate(playbackRates[0]);
        } else {
          setKeyboardSelectedRate(playbackRates[currentIndex - 1]);
        }
      } else if (e.key === "ArrowDown") {
        const currentIndex = playbackRates.findIndex((rate) => rate === keyboardSelectedRate);
        if (currentIndex === playbackRates.length - 1) {
          return;
        }
        if (currentIndex === -1) {
          setKeyboardSelectedRate(playbackRates[playbackRates.length - 1]);
        } else {
          setKeyboardSelectedRate(playbackRates[currentIndex + 1]);
        }
      } else if (e.key === "Enter") {
        setPlaybackRate(keyboardSelectedRate);
        setIsComponentVisible(false);
      }
    };
    window.addEventListener("keydown", listener);
    return () => {
      window.removeEventListener("keydown", listener);
    };
  }, [
    playbackRates,
    keyboardSelectedRate,
    setPlaybackRate,
    setIsComponentVisible
  ]);
  const onSelect = (0, import_react16.useCallback)((rate) => {
    setPlaybackRate(rate);
    setIsComponentVisible(false);
  }, [setIsComponentVisible, setPlaybackRate]);
  const playbackPopup = (0, import_react16.useMemo)(() => {
    return {
      position: "absolute",
      right: 0,
      width: 125,
      maxHeight: canvasSize.height - THRESHOLD - BOTTOM,
      bottom: 35,
      background: "#fff",
      borderRadius: 4,
      overflow: "auto",
      color: "black",
      textAlign: "left"
    };
  }, [canvasSize.height]);
  return (0, import_jsx_runtime7.jsx)("div", {
    style: playbackPopup,
    children: playbackRates.map((rate) => {
      return (0, import_jsx_runtime7.jsx)(PlaybackrateOption, {
        selectedRate: playbackRate,
        onSelect,
        rate,
        keyboardSelectedRate
      }, rate);
    })
  });
};
var label = {
  fontSize: 13,
  fontWeight: "bold",
  color: "white",
  border: "2px solid white",
  borderRadius: 20,
  paddingLeft: 8,
  paddingRight: 8,
  paddingTop: 2,
  paddingBottom: 2
};
var playerButtonStyle = {
  appearance: "none",
  backgroundColor: "transparent",
  border: "none",
  cursor: "pointer",
  paddingLeft: 0,
  paddingRight: 0,
  paddingTop: 6,
  paddingBottom: 6,
  height: 37,
  display: "inline-flex",
  marginBottom: 0,
  marginTop: 0,
  alignItems: "center"
};
var button = {
  ...playerButtonStyle,
  position: "relative"
};
var PlaybackrateControl = ({ playbackRates, canvasSize }) => {
  const { ref, isComponentVisible, setIsComponentVisible } = useComponentVisible(false);
  const { playbackRate } = (0, import_react16.useContext)(Internals.Timeline.TimelineContext);
  const onClick = (0, import_react16.useCallback)((e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsComponentVisible((prevIsComponentVisible) => !prevIsComponentVisible);
  }, [setIsComponentVisible]);
  return (0, import_jsx_runtime7.jsx)("div", {
    ref,
    children: (0, import_jsx_runtime7.jsxs)("button", {
      type: "button",
      "aria-label": "Change playback rate",
      style: button,
      onClick,
      children: [
        (0, import_jsx_runtime7.jsxs)("div", {
          style: label,
          children: [
            playbackRate,
            "x"
          ]
        }),
        isComponentVisible && (0, import_jsx_runtime7.jsx)(PlaybackPopup, {
          canvasSize,
          playbackRates,
          setIsComponentVisible
        })
      ]
    })
  });
};
var getFrameFromX = (clientX, durationInFrames, width) => {
  const pos = clientX;
  const frame = Math.round(interpolate(pos, [0, width], [0, durationInFrames - 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  }));
  return frame;
};
var BAR_HEIGHT2 = 5;
var KNOB_SIZE2 = 12;
var VERTICAL_PADDING = 4;
var containerStyle = {
  userSelect: "none",
  WebkitUserSelect: "none",
  paddingTop: VERTICAL_PADDING,
  paddingBottom: VERTICAL_PADDING,
  boxSizing: "border-box",
  cursor: "pointer",
  position: "relative",
  touchAction: "none"
};
var barBackground = {
  height: BAR_HEIGHT2,
  backgroundColor: "rgba(255, 255, 255, 0.25)",
  width: "100%",
  borderRadius: BAR_HEIGHT2 / 2
};
var findBodyInWhichDivIsLocated = (div) => {
  let current = div;
  while (current.parentElement) {
    current = current.parentElement;
  }
  return current;
};
var PlayerSeekBar = ({ durationInFrames, onSeekEnd, onSeekStart, inFrame, outFrame }) => {
  const containerRef = (0, import_react18.useRef)(null);
  const barHovered = useHoverState(containerRef, false);
  const size = useElementSize(containerRef, {
    triggerOnWindowResize: true,
    shouldApplyCssTransforms: true
  });
  const { seek, play, pause, playing } = usePlayer();
  const frame = Internals.Timeline.useTimelinePosition();
  const [dragging, setDragging] = (0, import_react18.useState)({
    dragging: false
  });
  const width = (size == null ? void 0 : size.width) ?? 0;
  const onPointerDown = (0, import_react18.useCallback)((e) => {
    var _a;
    if (e.button !== 0) {
      return;
    }
    const posLeft = (_a = containerRef.current) == null ? void 0 : _a.getBoundingClientRect().left;
    const _frame = getFrameFromX(e.clientX - posLeft, durationInFrames, width);
    pause();
    seek(_frame);
    setDragging({
      dragging: true,
      wasPlaying: playing
    });
    onSeekStart();
  }, [durationInFrames, width, pause, seek, playing, onSeekStart]);
  const onPointerMove = (0, import_react18.useCallback)((e) => {
    var _a;
    if (!size) {
      throw new Error("Player has no size");
    }
    if (!dragging.dragging) {
      return;
    }
    const posLeft = (_a = containerRef.current) == null ? void 0 : _a.getBoundingClientRect().left;
    const _frame = getFrameFromX(e.clientX - posLeft, durationInFrames, size.width);
    seek(_frame);
  }, [dragging.dragging, durationInFrames, seek, size]);
  const onPointerUp = (0, import_react18.useCallback)(() => {
    setDragging({
      dragging: false
    });
    if (!dragging.dragging) {
      return;
    }
    if (dragging.wasPlaying) {
      play();
    } else {
      pause();
    }
    onSeekEnd();
  }, [dragging, onSeekEnd, pause, play]);
  (0, import_react18.useEffect)(() => {
    if (!dragging.dragging) {
      return;
    }
    const body = findBodyInWhichDivIsLocated(containerRef.current);
    body.addEventListener("pointermove", onPointerMove);
    body.addEventListener("pointerup", onPointerUp);
    return () => {
      body.removeEventListener("pointermove", onPointerMove);
      body.removeEventListener("pointerup", onPointerUp);
    };
  }, [dragging.dragging, onPointerMove, onPointerUp]);
  const knobStyle = (0, import_react18.useMemo)(() => {
    return {
      height: KNOB_SIZE2,
      width: KNOB_SIZE2,
      borderRadius: KNOB_SIZE2 / 2,
      position: "absolute",
      top: VERTICAL_PADDING - KNOB_SIZE2 / 2 + 5 / 2,
      backgroundColor: "white",
      left: Math.max(0, frame / Math.max(1, durationInFrames - 1) * width - KNOB_SIZE2 / 2),
      boxShadow: "0 0 2px black",
      opacity: Number(barHovered || dragging.dragging)
    };
  }, [barHovered, dragging.dragging, durationInFrames, frame, width]);
  const fillStyle = (0, import_react18.useMemo)(() => {
    return {
      height: BAR_HEIGHT2,
      backgroundColor: "rgba(255, 255, 255, 1)",
      width: (frame - (inFrame ?? 0)) / (durationInFrames - 1) * width,
      marginLeft: (inFrame ?? 0) / (durationInFrames - 1) * width,
      borderRadius: BAR_HEIGHT2 / 2
    };
  }, [durationInFrames, frame, inFrame, width]);
  const active = (0, import_react18.useMemo)(() => {
    return {
      height: BAR_HEIGHT2,
      backgroundColor: "rgba(255, 255, 255, 0.25)",
      width: ((outFrame ?? durationInFrames - 1) - (inFrame ?? 0)) / (durationInFrames - 1) * 100 + "%",
      marginLeft: (inFrame ?? 0) / (durationInFrames - 1) * 100 + "%",
      borderRadius: BAR_HEIGHT2 / 2,
      position: "absolute"
    };
  }, [durationInFrames, inFrame, outFrame]);
  return (0, import_jsx_runtime8.jsxs)("div", {
    ref: containerRef,
    onPointerDown,
    style: containerStyle,
    children: [
      (0, import_jsx_runtime8.jsxs)("div", {
        style: barBackground,
        children: [
          (0, import_jsx_runtime8.jsx)("div", {
            style: active
          }),
          (0, import_jsx_runtime8.jsx)("div", {
            style: fillStyle
          })
        ]
      }),
      (0, import_jsx_runtime8.jsx)("div", {
        style: knobStyle
      })
    ]
  });
};
var formatTime = (timeInSeconds) => {
  const minutes = Math.floor(timeInSeconds / 60);
  const seconds = Math.floor(timeInSeconds - minutes * 60);
  return `${String(minutes)}:${String(seconds).padStart(2, "0")}`;
};
var PlayerTimeLabel = ({ durationInFrames, maxTimeLabelWidth, fps }) => {
  const frame = Internals.Timeline.useTimelinePosition();
  const timeLabel = (0, import_react19.useMemo)(() => {
    return {
      color: "white",
      fontFamily: "sans-serif",
      fontSize: 14,
      maxWidth: maxTimeLabelWidth === null ? void 0 : maxTimeLabelWidth,
      overflow: "hidden",
      textOverflow: "ellipsis"
    };
  }, [maxTimeLabelWidth]);
  const isLastFrame = frame === durationInFrames - 1;
  const frameToDisplay = isLastFrame ? frame + 1 : frame;
  return (0, import_jsx_runtime9.jsxs)("div", {
    style: timeLabel,
    children: [
      formatTime(frameToDisplay / fps),
      " / ",
      formatTime(durationInFrames / fps)
    ]
  });
};
var X_SPACER = 10;
var X_PADDING = 12;
var useVideoControlsResize = ({
  allowFullscreen: allowFullScreen,
  playerWidth
}) => {
  const resizeInfo = (0, import_react20.useMemo)(() => {
    const playPauseIconSize = ICON_SIZE;
    const volumeIconSize = ICON_SIZE;
    const _fullscreenIconSize = allowFullScreen ? fullscreenIconSize : 0;
    const elementsSize = volumeIconSize + playPauseIconSize + _fullscreenIconSize + X_PADDING * 2 + X_SPACER * 2;
    const maxTimeLabelWidth = playerWidth - elementsSize;
    const maxTimeLabelWidthWithoutNegativeValue = Math.max(maxTimeLabelWidth, 0);
    const availableTimeLabelWidthIfVolumeOpen = maxTimeLabelWidthWithoutNegativeValue - VOLUME_SLIDER_WIDTH;
    const computedLabelWidth = availableTimeLabelWidthIfVolumeOpen < VOLUME_SLIDER_WIDTH ? maxTimeLabelWidthWithoutNegativeValue : availableTimeLabelWidthIfVolumeOpen;
    const minWidthForHorizontalDisplay = computedLabelWidth + elementsSize + VOLUME_SLIDER_WIDTH;
    const displayVerticalVolumeSlider = playerWidth < minWidthForHorizontalDisplay;
    return {
      maxTimeLabelWidth: maxTimeLabelWidthWithoutNegativeValue === 0 ? null : maxTimeLabelWidthWithoutNegativeValue,
      displayVerticalVolumeSlider
    };
  }, [allowFullScreen, playerWidth]);
  return resizeInfo;
};
var gradientSteps = [
  0,
  0.013,
  0.049,
  0.104,
  0.175,
  0.259,
  0.352,
  0.45,
  0.55,
  0.648,
  0.741,
  0.825,
  0.896,
  0.951,
  0.987
];
var gradientOpacities = [
  0,
  8.1,
  15.5,
  22.5,
  29,
  35.3,
  41.2,
  47.1,
  52.9,
  58.8,
  64.7,
  71,
  77.5,
  84.5,
  91.9
];
var globalGradientOpacity = 1 / 0.7;
var containerStyle2 = {
  boxSizing: "border-box",
  position: "absolute",
  bottom: 0,
  width: "100%",
  paddingTop: 40,
  paddingBottom: 10,
  backgroundImage: `linear-gradient(to bottom,${gradientSteps.map((g, i) => {
    return `hsla(0, 0%, 0%, ${g}) ${gradientOpacities[i] * globalGradientOpacity}%`;
  }).join(", ")}, hsl(0, 0%, 0%) 100%)`,
  backgroundSize: "auto 145px",
  display: "flex",
  paddingRight: X_PADDING,
  paddingLeft: X_PADDING,
  flexDirection: "column",
  transition: "opacity 0.3s"
};
var controlsRow = {
  display: "flex",
  flexDirection: "row",
  width: "100%",
  alignItems: "center",
  justifyContent: "center",
  userSelect: "none",
  WebkitUserSelect: "none"
};
var leftPartStyle = {
  display: "flex",
  flexDirection: "row",
  userSelect: "none",
  WebkitUserSelect: "none",
  alignItems: "center"
};
var xSpacer = {
  width: 12
};
var ySpacer = {
  height: 8
};
var flex1 = {
  flex: 1
};
var fullscreen = {};
var Controls = ({
  durationInFrames,
  isFullscreen,
  fps,
  showVolumeControls,
  onFullscreenButtonClick,
  allowFullscreen,
  onExitFullscreenButtonClick,
  spaceKeyToPlayOrPause,
  onSeekEnd,
  onSeekStart,
  inFrame,
  outFrame,
  initiallyShowControls,
  canvasSize,
  renderPlayPauseButton,
  renderFullscreenButton,
  alwaysShowControls,
  showPlaybackRateControl,
  containerRef,
  buffering,
  hideControlsWhenPointerDoesntMove,
  onPointerDown,
  onDoubleClick,
  renderMuteButton,
  renderVolumeSlider,
  playing,
  toggle
}) => {
  const playButtonRef = (0, import_react13.useRef)(null);
  const [supportsFullscreen, setSupportsFullscreen] = (0, import_react13.useState)(false);
  const hovered = useHoverState(containerRef, hideControlsWhenPointerDoesntMove);
  const { maxTimeLabelWidth, displayVerticalVolumeSlider } = useVideoControlsResize({
    allowFullscreen,
    playerWidth: (canvasSize == null ? void 0 : canvasSize.width) ?? 0
  });
  const [shouldShowInitially, setInitiallyShowControls] = (0, import_react13.useState)(() => {
    if (typeof initiallyShowControls === "boolean") {
      return initiallyShowControls;
    }
    if (typeof initiallyShowControls === "number") {
      if (initiallyShowControls % 1 !== 0) {
        throw new Error("initiallyShowControls must be an integer or a boolean");
      }
      if (Number.isNaN(initiallyShowControls)) {
        throw new Error("initiallyShowControls must not be NaN");
      }
      if (!Number.isFinite(initiallyShowControls)) {
        throw new Error("initiallyShowControls must be finite");
      }
      if (initiallyShowControls <= 0) {
        throw new Error("initiallyShowControls must be a positive integer");
      }
      return initiallyShowControls;
    }
    throw new TypeError("initiallyShowControls must be a number or a boolean");
  });
  const containerCss = (0, import_react13.useMemo)(() => {
    const shouldShow = hovered || !playing || shouldShowInitially || alwaysShowControls;
    return {
      ...containerStyle2,
      opacity: Number(shouldShow)
    };
  }, [hovered, shouldShowInitially, playing, alwaysShowControls]);
  (0, import_react13.useEffect)(() => {
    if (playButtonRef.current && spaceKeyToPlayOrPause) {
      playButtonRef.current.focus({
        preventScroll: true
      });
    }
  }, [playing, spaceKeyToPlayOrPause]);
  (0, import_react13.useEffect)(() => {
    setSupportsFullscreen((typeof document !== "undefined" && (document.fullscreenEnabled || document.webkitFullscreenEnabled)) ?? false);
  }, []);
  (0, import_react13.useEffect)(() => {
    if (shouldShowInitially === false) {
      return;
    }
    const time = shouldShowInitially === true ? 2e3 : shouldShowInitially;
    const timeout = setTimeout(() => {
      setInitiallyShowControls(false);
    }, time);
    return () => {
      clearInterval(timeout);
    };
  }, [shouldShowInitially]);
  const playbackRates = (0, import_react13.useMemo)(() => {
    if (showPlaybackRateControl === true) {
      return [0.5, 0.8, 1, 1.2, 1.5, 1.8, 2, 2.5, 3];
    }
    if (Array.isArray(showPlaybackRateControl)) {
      for (const rate of showPlaybackRateControl) {
        if (typeof rate !== "number") {
          throw new Error("Every item in showPlaybackRateControl must be a number");
        }
        if (rate <= 0) {
          throw new Error("Every item in showPlaybackRateControl must be positive");
        }
      }
      return showPlaybackRateControl;
    }
    return null;
  }, [showPlaybackRateControl]);
  const ref = (0, import_react13.useRef)(null);
  const flexRef = (0, import_react13.useRef)(null);
  const onPointerDownIfContainer = (0, import_react13.useCallback)((e) => {
    if (e.target === ref.current || e.target === flexRef.current) {
      onPointerDown == null ? void 0 : onPointerDown(e);
    }
  }, [onPointerDown]);
  const onDoubleClickIfContainer = (0, import_react13.useCallback)((e) => {
    if (e.target === ref.current || e.target === flexRef.current) {
      onDoubleClick == null ? void 0 : onDoubleClick(e);
    }
  }, [onDoubleClick]);
  return (0, import_jsx_runtime10.jsxs)("div", {
    ref,
    style: containerCss,
    onPointerDown: onPointerDownIfContainer,
    onDoubleClick: onDoubleClickIfContainer,
    children: [
      (0, import_jsx_runtime10.jsxs)("div", {
        ref: flexRef,
        style: controlsRow,
        children: [
          (0, import_jsx_runtime10.jsxs)("div", {
            style: leftPartStyle,
            children: [
              (0, import_jsx_runtime10.jsx)("button", {
                ref: playButtonRef,
                type: "button",
                style: playerButtonStyle,
                onClick: toggle,
                "aria-label": playing ? "Pause video" : "Play video",
                title: playing ? "Pause video" : "Play video",
                children: renderPlayPauseButton === null ? (0, import_jsx_runtime10.jsx)(DefaultPlayPauseButton, {
                  buffering,
                  playing
                }) : renderPlayPauseButton({
                  playing,
                  isBuffering: buffering
                }) ?? (0, import_jsx_runtime10.jsx)(DefaultPlayPauseButton, {
                  buffering,
                  playing
                })
              }),
              showVolumeControls ? (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, {
                children: [
                  (0, import_jsx_runtime10.jsx)("div", {
                    style: xSpacer
                  }),
                  (0, import_jsx_runtime10.jsx)(MediaVolumeSlider, {
                    renderMuteButton,
                    renderVolumeSlider,
                    displayVerticalVolumeSlider
                  })
                ]
              }) : null,
              (0, import_jsx_runtime10.jsx)("div", {
                style: xSpacer
              }),
              (0, import_jsx_runtime10.jsx)(PlayerTimeLabel, {
                durationInFrames,
                fps,
                maxTimeLabelWidth
              }),
              (0, import_jsx_runtime10.jsx)("div", {
                style: xSpacer
              })
            ]
          }),
          (0, import_jsx_runtime10.jsx)("div", {
            style: flex1
          }),
          playbackRates && canvasSize && (0, import_jsx_runtime10.jsx)(PlaybackrateControl, {
            canvasSize,
            playbackRates
          }),
          playbackRates && supportsFullscreen && allowFullscreen ? (0, import_jsx_runtime10.jsx)("div", {
            style: xSpacer
          }) : null,
          (0, import_jsx_runtime10.jsx)("div", {
            style: fullscreen,
            children: supportsFullscreen && allowFullscreen ? (0, import_jsx_runtime10.jsx)("button", {
              type: "button",
              "aria-label": isFullscreen ? "Exit fullscreen" : "Enter Fullscreen",
              title: isFullscreen ? "Exit fullscreen" : "Enter Fullscreen",
              style: playerButtonStyle,
              onClick: isFullscreen ? onExitFullscreenButtonClick : onFullscreenButtonClick,
              children: renderFullscreenButton === null ? (0, import_jsx_runtime10.jsx)(FullscreenIcon, {
                isFullscreen
              }) : renderFullscreenButton({ isFullscreen })
            }) : null
          })
        ]
      }),
      (0, import_jsx_runtime10.jsx)("div", {
        style: ySpacer
      }),
      (0, import_jsx_runtime10.jsx)(PlayerSeekBar, {
        onSeekEnd,
        onSeekStart,
        durationInFrames,
        inFrame,
        outFrame
      })
    ]
  });
};
var errorStyle = {
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  flex: 1,
  height: "100%",
  width: "100%"
};
var ErrorBoundary = class extends import_react21.default.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", { hasError: null });
  }
  static getDerivedStateFromError(error) {
    return { hasError: error };
  }
  componentDidCatch(error) {
    this.props.onError(error);
  }
  render() {
    if (this.state.hasError) {
      return (0, import_jsx_runtime11.jsx)("div", {
        style: errorStyle,
        children: this.props.errorFallback({
          error: this.state.hasError
        })
      });
    }
    return this.props.children;
  }
};
var getHashOfDomain = async () => {
  if (typeof window === "undefined") {
    return null;
  }
  if (typeof window.crypto === "undefined") {
    return null;
  }
  if (typeof window.crypto.subtle === "undefined") {
    return null;
  }
  try {
    const hashBuffer = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(window.location.hostname));
    return Array.from(new Uint8Array(hashBuffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
  } catch {
    return null;
  }
};
var style = {
  backgroundColor: "red",
  position: "absolute",
  padding: 12,
  fontFamily: "Arial"
};
var DOMAIN_BLACKLIST = [
  "28d262b44cc61fa750f1686b16ad0604dabfe193fbc263eec05c89b7ad4c2cd6",
  "4db1b0a94be33165dfefcb3ba03d04c7a2666dd27c496d3dc9fa41858e94925e",
  "fbc48530bbf245da790f63675e84e06bab38c3b114fab07eb350025119922bdc",
  "7baf10a8932757b1b3a22b3fce10a048747ac2f8eaf638603487e3705b07eb83",
  "8a6c21a598d8c667272b5207c051b85997bf5b45d5fb712378be3f27cd72c6a6",
  "a2f7aaac9c50a9255e7fc376110c4e0bfe153722dc66ed3c5d3bf2a135f65518"
];
var ran = false;
var RenderWarningIfBlacklist = () => {
  const [unlicensed, setUnlicensed] = import_react22.default.useState(false);
  (0, import_react22.useEffect)(() => {
    if (ran) {
      return;
    }
    ran = true;
    getHashOfDomain().then((hash) => {
      if (hash && DOMAIN_BLACKLIST.includes(hash)) {
        setUnlicensed(true);
      }
    }).catch(() => {
    });
  }, []);
  (0, import_react22.useEffect)(() => {
    if (!unlicensed) {
      return;
    }
    const ensureBanner = () => {
      const banner = document.querySelector(".warning-banner");
      if (!banner) {
        const div = document.createElement("div");
        div.className = "warning-banner";
        Object.assign(div.style, style, {
          zIndex: "9999",
          cssText: `${style.cssText} !important;`
        });
        div.innerHTML = `
	        <a href="https://github.com/remotion-dev/remotion/pull/4589" style="color: white;">
	          Remotion Unlicensed  Contact hi@remotion.dev
	        </a>
	      `;
        document.body.appendChild(div);
      }
    };
    const observer = new MutationObserver(() => ensureBanner());
    observer.observe(document.body, { childList: true, subtree: true });
    return () => {
      observer.disconnect();
    };
  }, [unlicensed]);
  if (!unlicensed) {
    return null;
  }
  return (0, import_jsx_runtime12.jsx)("div", {
    style,
    className: "warning-banner",
    children: (0, import_jsx_runtime12.jsx)("a", {
      style: { color: "white" },
      href: "https://github.com/remotion-dev/remotion/pull/4589",
      children: "Remotion Unlicensed  Contact hi@remotion.dev"
    })
  });
};
var playerCssClassname = (override) => {
  return override ?? "__remotion-player";
};
var IS_NODE = typeof document === "undefined";
var cancellablePromise = (promise) => {
  let isCanceled = false;
  const wrappedPromise = new Promise((resolve, reject) => {
    promise.then((value) => {
      if (isCanceled) {
        reject({ isCanceled, value });
        return;
      }
      resolve(value);
    }).catch((error) => {
      reject({ isCanceled, error });
    });
  });
  return {
    promise: wrappedPromise,
    cancel: () => {
      isCanceled = true;
    }
  };
};
var delay = (n) => new Promise((resolve) => setTimeout(resolve, n));
var useCancellablePromises = () => {
  const pendingPromises = (0, import_react24.useRef)([]);
  const appendPendingPromise = (0, import_react24.useCallback)((promise) => {
    pendingPromises.current = [...pendingPromises.current, promise];
  }, []);
  const removePendingPromise = (0, import_react24.useCallback)((promise) => {
    pendingPromises.current = pendingPromises.current.filter((p) => p !== promise);
  }, []);
  const clearPendingPromises = (0, import_react24.useCallback)(() => pendingPromises.current.map((p) => p.cancel()), []);
  const api = (0, import_react24.useMemo)(() => ({
    appendPendingPromise,
    removePendingPromise,
    clearPendingPromises
  }), [appendPendingPromise, clearPendingPromises, removePendingPromise]);
  return api;
};
var useClickPreventionOnDoubleClick = (onClick, onDoubleClick, doubleClickToFullscreen) => {
  const api = useCancellablePromises();
  const handleClick = (0, import_react23.useCallback)(async (e) => {
    if (e instanceof PointerEvent ? e.pointerType === "touch" : e.nativeEvent.pointerType === "touch") {
      onClick(e);
      return;
    }
    api.clearPendingPromises();
    const waitForClick = cancellablePromise(delay(200));
    api.appendPendingPromise(waitForClick);
    try {
      await waitForClick.promise;
      api.removePendingPromise(waitForClick);
      onClick(e);
    } catch (errorInfo) {
      const info = errorInfo;
      api.removePendingPromise(waitForClick);
      if (!info.isCanceled) {
        throw info.error;
      }
    }
  }, [api, onClick]);
  const handlePointerDown = (0, import_react23.useCallback)(() => {
    document.addEventListener("pointerup", (newEvt) => {
      handleClick(newEvt);
    }, {
      once: true
    });
  }, [handleClick]);
  const handleDoubleClick = (0, import_react23.useCallback)(() => {
    api.clearPendingPromises();
    onDoubleClick();
  }, [api, onDoubleClick]);
  const returnValue = (0, import_react23.useMemo)(() => {
    if (!doubleClickToFullscreen) {
      return { handlePointerDown: onClick, handleDoubleClick: () => {
        return;
      } };
    }
    return { handlePointerDown, handleDoubleClick };
  }, [doubleClickToFullscreen, handleDoubleClick, handlePointerDown, onClick]);
  return returnValue;
};
var reactVersion = import_react12.default.version.split(".")[0];
if (reactVersion === "0") {
  throw new Error(`Version ${reactVersion} of "react" is not supported by Remotion`);
}
var doesReactVersionSupportSuspense = parseInt(reactVersion, 10) >= 18;
var PlayerUI = ({
  controls,
  style: style2,
  loop,
  autoPlay,
  allowFullscreen,
  inputProps,
  clickToPlay,
  showVolumeControls,
  doubleClickToFullscreen,
  spaceKeyToPlayOrPause,
  errorFallback,
  playbackRate,
  renderLoading,
  renderPoster,
  className: className2,
  moveToBeginningWhenEnded,
  showPosterWhenUnplayed,
  showPosterWhenEnded,
  showPosterWhenPaused,
  showPosterWhenBuffering,
  showPosterWhenBufferingAndPaused,
  inFrame,
  outFrame,
  initiallyShowControls,
  renderFullscreen: renderFullscreenButton,
  renderPlayPauseButton,
  renderMuteButton,
  renderVolumeSlider,
  alwaysShowControls,
  showPlaybackRateControl,
  posterFillMode,
  bufferStateDelayInMilliseconds,
  hideControlsWhenPointerDoesntMove,
  overflowVisible,
  browserMediaControlsBehavior,
  overrideInternalClassName,
  noSuspense
}, ref) => {
  const config = Internals.useUnsafeVideoConfig();
  const video = Internals.useVideo();
  const container = (0, import_react12.useRef)(null);
  const canvasSize = useElementSize(container, {
    triggerOnWindowResize: false,
    shouldApplyCssTransforms: false
  });
  const [hasPausedToResume, setHasPausedToResume] = (0, import_react12.useState)(false);
  const [shouldAutoplay, setShouldAutoPlay] = (0, import_react12.useState)(autoPlay);
  const [isFullscreen, setIsFullscreen] = (0, import_react12.useState)(() => false);
  const [seeking, setSeeking] = (0, import_react12.useState)(false);
  const supportsFullScreen = (0, import_react12.useMemo)(() => {
    if (typeof document === "undefined") {
      return false;
    }
    return Boolean(document.fullscreenEnabled || document.webkitFullscreenEnabled);
  }, []);
  const player = usePlayer();
  const playerToggle = player.toggle;
  usePlayback({
    loop,
    playbackRate,
    moveToBeginningWhenEnded,
    inFrame,
    outFrame,
    getCurrentFrame: player.getCurrentFrame,
    browserMediaControlsBehavior
  });
  (0, import_react12.useEffect)(() => {
    if (hasPausedToResume && !player.playing) {
      setHasPausedToResume(false);
      player.play();
    }
  }, [hasPausedToResume, player]);
  (0, import_react12.useEffect)(() => {
    const { current } = container;
    if (!current) {
      return;
    }
    const onFullscreenChange = () => {
      const newValue = document.fullscreenElement === current || document.webkitFullscreenElement === current;
      setIsFullscreen(newValue);
    };
    document.addEventListener("fullscreenchange", onFullscreenChange);
    document.addEventListener("webkitfullscreenchange", onFullscreenChange);
    return () => {
      document.removeEventListener("fullscreenchange", onFullscreenChange);
      document.removeEventListener("webkitfullscreenchange", onFullscreenChange);
    };
  }, []);
  const toggle = (0, import_react12.useCallback)((e) => {
    playerToggle(e);
  }, [playerToggle]);
  const requestFullscreen = (0, import_react12.useCallback)(() => {
    if (!allowFullscreen) {
      throw new Error("allowFullscreen is false");
    }
    if (!supportsFullScreen) {
      throw new Error("Browser doesnt support fullscreen");
    }
    if (!container.current) {
      throw new Error("No player ref found");
    }
    if (container.current.webkitRequestFullScreen) {
      container.current.webkitRequestFullScreen();
    } else {
      container.current.requestFullscreen();
    }
  }, [allowFullscreen, supportsFullScreen]);
  const exitFullscreen = (0, import_react12.useCallback)(() => {
    if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    } else {
      document.exitFullscreen();
    }
  }, []);
  (0, import_react12.useEffect)(() => {
    const { current } = container;
    if (!current) {
      return;
    }
    const fullscreenChange = () => {
      const element = document.webkitFullscreenElement ?? document.fullscreenElement;
      if (element && element === container.current) {
        player.emitter.dispatchFullscreenChange({
          isFullscreen: true
        });
      } else {
        player.emitter.dispatchFullscreenChange({
          isFullscreen: false
        });
      }
    };
    current.addEventListener("webkitfullscreenchange", fullscreenChange);
    current.addEventListener("fullscreenchange", fullscreenChange);
    return () => {
      current.removeEventListener("webkitfullscreenchange", fullscreenChange);
      current.removeEventListener("fullscreenchange", fullscreenChange);
    };
  }, [player.emitter]);
  const durationInFrames = (config == null ? void 0 : config.durationInFrames) ?? 1;
  const layout = (0, import_react12.useMemo)(() => {
    if (!config || !canvasSize) {
      return null;
    }
    return calculateCanvasTransformation({
      canvasSize,
      compositionHeight: config.height,
      compositionWidth: config.width,
      previewSize: "auto"
    });
  }, [canvasSize, config]);
  const scale = (layout == null ? void 0 : layout.scale) ?? 1;
  const initialScaleIgnored = (0, import_react12.useRef)(false);
  (0, import_react12.useEffect)(() => {
    if (!initialScaleIgnored.current) {
      initialScaleIgnored.current = true;
      return;
    }
    player.emitter.dispatchScaleChange(scale);
  }, [player.emitter, scale]);
  const { setMediaVolume, setMediaMuted } = (0, import_react12.useContext)(Internals.SetMediaVolumeContext);
  const { mediaMuted, mediaVolume } = (0, import_react12.useContext)(Internals.MediaVolumeContext);
  (0, import_react12.useEffect)(() => {
    player.emitter.dispatchVolumeChange(mediaVolume);
  }, [player.emitter, mediaVolume]);
  const isMuted = mediaMuted || mediaVolume === 0;
  (0, import_react12.useEffect)(() => {
    player.emitter.dispatchMuteChange({
      isMuted
    });
  }, [player.emitter, isMuted]);
  const [showBufferIndicator, setShowBufferState] = (0, import_react12.useState)(false);
  (0, import_react12.useEffect)(() => {
    let timeout = null;
    let stopped = false;
    const onBuffer = () => {
      stopped = false;
      requestAnimationFrame(() => {
        if (bufferStateDelayInMilliseconds === 0) {
          setShowBufferState(true);
        } else {
          timeout = setTimeout(() => {
            if (!stopped) {
              setShowBufferState(true);
            }
          }, bufferStateDelayInMilliseconds);
        }
      });
    };
    const onResume = () => {
      requestAnimationFrame(() => {
        stopped = true;
        setShowBufferState(false);
        if (timeout) {
          clearTimeout(timeout);
        }
      });
    };
    player.emitter.addEventListener("waiting", onBuffer);
    player.emitter.addEventListener("resume", onResume);
    return () => {
      player.emitter.removeEventListener("waiting", onBuffer);
      player.emitter.removeEventListener("resume", onResume);
      setShowBufferState(false);
      if (timeout) {
        clearTimeout(timeout);
      }
      stopped = true;
    };
  }, [bufferStateDelayInMilliseconds, player.emitter]);
  (0, import_react12.useImperativeHandle)(ref, () => {
    const methods = {
      play: player.play,
      pause: () => {
        setHasPausedToResume(false);
        player.pause();
      },
      toggle,
      getContainerNode: () => container.current,
      getCurrentFrame: player.getCurrentFrame,
      isPlaying: player.isPlaying,
      seekTo: (f) => {
        const lastFrame = durationInFrames - 1;
        const frameToSeekTo = Math.max(0, Math.min(lastFrame, f));
        if (player.isPlaying()) {
          const pauseToResume = frameToSeekTo !== lastFrame || loop;
          setHasPausedToResume(pauseToResume);
          player.pause();
        }
        if (frameToSeekTo === lastFrame && !loop) {
          player.emitter.dispatchEnded();
        }
        player.seek(frameToSeekTo);
      },
      isFullscreen: () => {
        const { current } = container;
        if (!current) {
          return false;
        }
        return document.fullscreenElement === current || document.webkitFullscreenElement === current;
      },
      requestFullscreen,
      exitFullscreen,
      getVolume: () => {
        if (mediaMuted) {
          return 0;
        }
        return mediaVolume;
      },
      setVolume: (vol) => {
        if (typeof vol !== "number") {
          throw new TypeError(`setVolume() takes a number, got value of type ${typeof vol}`);
        }
        if (isNaN(vol)) {
          throw new TypeError(`setVolume() got a number that is NaN. Volume must be between 0 and 1.`);
        }
        if (vol < 0 || vol > 1) {
          throw new TypeError(`setVolume() got a number that is out of range. Must be between 0 and 1, got ${typeof vol}`);
        }
        setMediaVolume(vol);
      },
      isMuted: () => isMuted,
      mute: () => {
        setMediaMuted(true);
      },
      unmute: () => {
        setMediaMuted(false);
      },
      getScale: () => scale,
      pauseAndReturnToPlayStart: () => {
        player.pauseAndReturnToPlayStart();
      }
    };
    return Object.assign(player.emitter, methods);
  }, [
    durationInFrames,
    exitFullscreen,
    loop,
    mediaMuted,
    isMuted,
    mediaVolume,
    player,
    requestFullscreen,
    setMediaMuted,
    setMediaVolume,
    toggle,
    scale
  ]);
  const VideoComponent = video ? video.component : null;
  const outerStyle = (0, import_react12.useMemo)(() => {
    return calculateOuterStyle({
      canvasSize,
      config,
      style: style2,
      overflowVisible,
      layout
    });
  }, [canvasSize, config, layout, overflowVisible, style2]);
  const outer = (0, import_react12.useMemo)(() => {
    return calculateOuter({ config, layout, scale, overflowVisible });
  }, [config, layout, overflowVisible, scale]);
  const containerStyle3 = (0, import_react12.useMemo)(() => {
    return calculateContainerStyle({
      config,
      layout,
      scale,
      overflowVisible
    });
  }, [config, layout, overflowVisible, scale]);
  const playerPause = player.pause;
  const playerDispatchError = player.emitter.dispatchError;
  const onError = (0, import_react12.useCallback)((error) => {
    playerPause();
    playerDispatchError(error);
  }, [playerDispatchError, playerPause]);
  const onFullscreenButtonClick = (0, import_react12.useCallback)((e) => {
    e.stopPropagation();
    requestFullscreen();
  }, [requestFullscreen]);
  const onExitFullscreenButtonClick = (0, import_react12.useCallback)((e) => {
    e.stopPropagation();
    exitFullscreen();
  }, [exitFullscreen]);
  const onSingleClick = (0, import_react12.useCallback)((e) => {
    const rightClick = e instanceof MouseEvent ? e.button === 2 : e.nativeEvent.button;
    if (rightClick) {
      return;
    }
    toggle(e);
  }, [toggle]);
  const onSeekStart = (0, import_react12.useCallback)(() => {
    setSeeking(true);
  }, []);
  const onSeekEnd = (0, import_react12.useCallback)(() => {
    setSeeking(false);
  }, []);
  const onDoubleClick = (0, import_react12.useCallback)(() => {
    if (isFullscreen) {
      exitFullscreen();
    } else {
      requestFullscreen();
    }
  }, [exitFullscreen, isFullscreen, requestFullscreen]);
  const { handlePointerDown, handleDoubleClick } = useClickPreventionOnDoubleClick(onSingleClick, onDoubleClick, doubleClickToFullscreen && allowFullscreen && supportsFullScreen);
  (0, import_react12.useEffect)(() => {
    if (shouldAutoplay) {
      player.play();
      setShouldAutoPlay(false);
    }
  }, [shouldAutoplay, player]);
  const loadingMarkup = (0, import_react12.useMemo)(() => {
    return renderLoading ? renderLoading({
      height: outerStyle.height,
      width: outerStyle.width,
      isBuffering: showBufferIndicator
    }) : null;
  }, [outerStyle.height, outerStyle.width, renderLoading, showBufferIndicator]);
  const currentScale = (0, import_react12.useMemo)(() => {
    return {
      type: "scale",
      scale
    };
  }, [scale]);
  if (!config) {
    return null;
  }
  const poster = renderPoster ? renderPoster({
    height: posterFillMode === "player-size" ? outerStyle.height : config.height,
    width: posterFillMode === "player-size" ? outerStyle.width : config.width,
    isBuffering: showBufferIndicator
  }) : null;
  if (poster === void 0) {
    throw new TypeError("renderPoster() must return a React element, but undefined was returned");
  }
  const shouldShowPoster = poster && [
    showPosterWhenPaused && !player.isPlaying() && !seeking,
    showPosterWhenEnded && player.isLastFrame && !player.isPlaying(),
    showPosterWhenUnplayed && !player.hasPlayed && !player.isPlaying(),
    showPosterWhenBuffering && showBufferIndicator && player.isPlaying(),
    showPosterWhenBufferingAndPaused && showBufferIndicator && !player.isPlaying()
  ].some(Boolean);
  const { left, top, width, height, ...outerWithoutScale } = outer;
  const content = (0, import_jsx_runtime13.jsxs)(import_jsx_runtime13.Fragment, {
    children: [
      (0, import_jsx_runtime13.jsxs)("div", {
        style: outer,
        onPointerDown: clickToPlay ? handlePointerDown : void 0,
        onDoubleClick: doubleClickToFullscreen ? handleDoubleClick : void 0,
        children: [
          (0, import_jsx_runtime13.jsxs)("div", {
            style: containerStyle3,
            className: playerCssClassname(overrideInternalClassName),
            children: [
              VideoComponent ? (0, import_jsx_runtime13.jsx)(ErrorBoundary, {
                onError,
                errorFallback,
                children: (0, import_jsx_runtime13.jsx)(Internals.CurrentScaleContext.Provider, {
                  value: currentScale,
                  children: (0, import_jsx_runtime13.jsx)(VideoComponent, {
                    ...(video == null ? void 0 : video.props) ?? {},
                    ...inputProps ?? {}
                  })
                })
              }) : null,
              shouldShowPoster && posterFillMode === "composition-size" ? (0, import_jsx_runtime13.jsx)("div", {
                style: {
                  ...outerWithoutScale,
                  width: config.width,
                  height: config.height
                },
                onPointerDown: clickToPlay ? handlePointerDown : void 0,
                onDoubleClick: doubleClickToFullscreen ? handleDoubleClick : void 0,
                children: poster
              }) : null
            ]
          }),
          (0, import_jsx_runtime13.jsx)(RenderWarningIfBlacklist, {})
        ]
      }),
      shouldShowPoster && posterFillMode === "player-size" ? (0, import_jsx_runtime13.jsx)("div", {
        style: outer,
        onPointerDown: clickToPlay ? handlePointerDown : void 0,
        onDoubleClick: doubleClickToFullscreen ? handleDoubleClick : void 0,
        children: poster
      }) : null,
      controls ? (0, import_jsx_runtime13.jsx)(Controls, {
        fps: config.fps,
        playing: player.playing,
        toggle: player.toggle,
        durationInFrames: config.durationInFrames,
        containerRef: container,
        onFullscreenButtonClick,
        isFullscreen,
        allowFullscreen,
        showVolumeControls,
        onExitFullscreenButtonClick,
        spaceKeyToPlayOrPause,
        onSeekEnd,
        onSeekStart,
        inFrame,
        outFrame,
        initiallyShowControls,
        canvasSize,
        renderFullscreenButton,
        renderPlayPauseButton,
        alwaysShowControls,
        showPlaybackRateControl,
        buffering: showBufferIndicator,
        hideControlsWhenPointerDoesntMove,
        onDoubleClick: doubleClickToFullscreen ? handleDoubleClick : void 0,
        onPointerDown: clickToPlay ? handlePointerDown : void 0,
        renderMuteButton,
        renderVolumeSlider
      }) : null
    ]
  });
  if (noSuspense || IS_NODE && !doesReactVersionSupportSuspense) {
    return (0, import_jsx_runtime13.jsx)("div", {
      ref: container,
      style: outerStyle,
      className: className2,
      children: content
    });
  }
  return (0, import_jsx_runtime13.jsx)("div", {
    ref: container,
    style: outerStyle,
    className: className2,
    children: (0, import_jsx_runtime13.jsx)(import_react12.Suspense, {
      fallback: loadingMarkup,
      children: content
    })
  });
};
var PlayerUI_default = (0, import_react12.forwardRef)(PlayerUI);
var DEFAULT_VOLUME_PERSISTANCE_KEY = "remotion.volumePreference";
var persistVolume = (volume, logLevel, volumePersistenceKey) => {
  if (typeof window === "undefined") {
    return;
  }
  try {
    window.localStorage.setItem(volumePersistenceKey ?? DEFAULT_VOLUME_PERSISTANCE_KEY, String(volume));
  } catch (e) {
    Internals.Log.error({ logLevel, tag: null }, "Could not persist volume", e);
  }
};
var getPreferredVolume = (volumePersistenceKey) => {
  if (typeof window === "undefined") {
    return 1;
  }
  try {
    const val = window.localStorage.getItem(volumePersistenceKey ?? DEFAULT_VOLUME_PERSISTANCE_KEY);
    return val ? Number(val) : 1;
  } catch {
    return 1;
  }
};
var PLAYER_COMP_ID = "player-comp";
var SharedPlayerContexts = ({
  children,
  timelineContext,
  fps,
  compositionHeight,
  compositionWidth,
  durationInFrames,
  component,
  numberOfSharedAudioTags,
  initiallyMuted,
  logLevel,
  audioLatencyHint,
  volumePersistenceKey
}) => {
  const compositionManagerContext = (0, import_react25.useMemo)(() => {
    const context = {
      compositions: [
        {
          component,
          durationInFrames,
          height: compositionHeight,
          width: compositionWidth,
          fps,
          id: PLAYER_COMP_ID,
          nonce: 777,
          folderName: null,
          parentFolderName: null,
          schema: null,
          calculateMetadata: null
        }
      ],
      folders: [],
      currentCompositionMetadata: null,
      canvasContent: { type: "composition", compositionId: "player-comp" }
    };
    return context;
  }, [component, durationInFrames, compositionHeight, compositionWidth, fps]);
  const [mediaMuted, setMediaMuted] = (0, import_react25.useState)(() => initiallyMuted);
  const [mediaVolume, setMediaVolume] = (0, import_react25.useState)(() => getPreferredVolume(volumePersistenceKey ?? null));
  const mediaVolumeContextValue = (0, import_react25.useMemo)(() => {
    return {
      mediaMuted,
      mediaVolume
    };
  }, [mediaMuted, mediaVolume]);
  const setMediaVolumeAndPersist = (0, import_react25.useCallback)((vol) => {
    setMediaVolume(vol);
    persistVolume(vol, logLevel, volumePersistenceKey ?? null);
  }, [logLevel, volumePersistenceKey]);
  const setMediaVolumeContextValue = (0, import_react25.useMemo)(() => {
    return {
      setMediaMuted,
      setMediaVolume: setMediaVolumeAndPersist
    };
  }, [setMediaVolumeAndPersist]);
  const logLevelContext = (0, import_react25.useMemo)(() => {
    return {
      logLevel,
      mountTime: Date.now()
    };
  }, [logLevel]);
  const env = (0, import_react25.useMemo)(() => {
    return {
      isPlayer: true,
      isRendering: false,
      isStudio: false,
      isClientSideRendering: false,
      isReadOnlyStudio: false
    };
  }, []);
  return (0, import_jsx_runtime14.jsx)(Internals.RemotionEnvironmentContext.Provider, {
    value: env,
    children: (0, import_jsx_runtime14.jsx)(Internals.LogLevelContext.Provider, {
      value: logLevelContext,
      children: (0, import_jsx_runtime14.jsx)(Internals.CanUseRemotionHooksProvider, {
        children: (0, import_jsx_runtime14.jsx)(Internals.Timeline.TimelineContext.Provider, {
          value: timelineContext,
          children: (0, import_jsx_runtime14.jsx)(Internals.CompositionManager.Provider, {
            value: compositionManagerContext,
            children: (0, import_jsx_runtime14.jsx)(Internals.ResolveCompositionConfig, {
              children: (0, import_jsx_runtime14.jsx)(Internals.PrefetchProvider, {
                children: (0, import_jsx_runtime14.jsx)(Internals.DurationsContextProvider, {
                  children: (0, import_jsx_runtime14.jsx)(Internals.MediaVolumeContext.Provider, {
                    value: mediaVolumeContextValue,
                    children: (0, import_jsx_runtime14.jsx)(Internals.SetMediaVolumeContext.Provider, {
                      value: setMediaVolumeContextValue,
                      children: (0, import_jsx_runtime14.jsx)(Internals.SharedAudioContextProvider, {
                        numberOfAudioTags: numberOfSharedAudioTags,
                        component,
                        audioLatencyHint,
                        children: (0, import_jsx_runtime14.jsx)(Internals.BufferingProvider, {
                          children
                        })
                      })
                    })
                  })
                })
              })
            })
          })
        })
      })
    })
  });
};
var warningShown = false;
var acknowledgeRemotionLicenseMessage = (acknowledge, logLevel) => {
  if (acknowledge) {
    return;
  }
  if (warningShown) {
    return;
  }
  warningShown = true;
  Internals.Log.warn({ logLevel, tag: null }, "Note: Some companies are required to obtain a license to use Remotion. See: https://remotion.dev/license\nPass the `acknowledgeRemotionLicense` prop to `<Player />` function to make this message disappear.");
};
var validateSingleFrame = (frame, variableName) => {
  if (typeof frame === "undefined" || frame === null) {
    return frame ?? null;
  }
  if (typeof frame !== "number") {
    throw new TypeError(`"${variableName}" must be a number, but is ${JSON.stringify(frame)}`);
  }
  if (Number.isNaN(frame)) {
    throw new TypeError(`"${variableName}" must not be NaN, but is ${JSON.stringify(frame)}`);
  }
  if (!Number.isFinite(frame)) {
    throw new TypeError(`"${variableName}" must be finite, but is ${JSON.stringify(frame)}`);
  }
  if (frame % 1 !== 0) {
    throw new TypeError(`"${variableName}" must be an integer, but is ${JSON.stringify(frame)}`);
  }
  return frame;
};
var validateInOutFrames = ({
  inFrame,
  durationInFrames,
  outFrame
}) => {
  const validatedInFrame = validateSingleFrame(inFrame, "inFrame");
  const validatedOutFrame = validateSingleFrame(outFrame, "outFrame");
  if (validatedInFrame === null && validatedOutFrame === null) {
    return;
  }
  if (validatedInFrame !== null && validatedInFrame > durationInFrames - 1) {
    throw new Error("inFrame must be less than (durationInFrames - 1), but is " + validatedInFrame);
  }
  if (validatedOutFrame !== null && validatedOutFrame > durationInFrames - 1) {
    throw new Error("outFrame must be less than (durationInFrames - 1), but is " + validatedOutFrame);
  }
  if (validatedInFrame !== null && validatedInFrame < 0) {
    throw new Error("inFrame must be greater than 0, but is " + validatedInFrame);
  }
  if (validatedOutFrame !== null && validatedOutFrame <= 0) {
    throw new Error(`outFrame must be greater than 0, but is ${validatedOutFrame}. If you want to render a single frame, use <Thumbnail /> instead.`);
  }
  if (validatedOutFrame !== null && validatedInFrame !== null && validatedOutFrame <= validatedInFrame) {
    throw new Error("outFrame must be greater than inFrame, but is " + validatedOutFrame + " <= " + validatedInFrame);
  }
};
var validateInitialFrame = ({
  initialFrame,
  durationInFrames
}) => {
  if (typeof durationInFrames !== "number") {
    throw new Error(`\`durationInFrames\` must be a number, but is ${JSON.stringify(durationInFrames)}`);
  }
  if (typeof initialFrame === "undefined") {
    return;
  }
  if (typeof initialFrame !== "number") {
    throw new Error(`\`initialFrame\` must be a number, but is ${JSON.stringify(initialFrame)}`);
  }
  if (Number.isNaN(initialFrame)) {
    throw new Error(`\`initialFrame\` must be a number, but is NaN`);
  }
  if (!Number.isFinite(initialFrame)) {
    throw new Error(`\`initialFrame\` must be a number, but is Infinity`);
  }
  if (initialFrame % 1 !== 0) {
    throw new Error(`\`initialFrame\` must be an integer, but is ${JSON.stringify(initialFrame)}`);
  }
  if (initialFrame > durationInFrames - 1) {
    throw new Error(`\`initialFrame\` must be less or equal than \`durationInFrames - 1\`, but is ${JSON.stringify(initialFrame)}`);
  }
};
var validatePlaybackRate = (playbackRate) => {
  if (playbackRate === void 0) {
    return;
  }
  if (playbackRate > 4) {
    throw new Error(`The highest possible playback rate is 4. You passed: ${playbackRate}`);
  }
  if (playbackRate < -4) {
    throw new Error(`The lowest possible playback rate is -4. You passed: ${playbackRate}`);
  }
  if (playbackRate === 0) {
    throw new Error(`A playback rate of 0 is not supported.`);
  }
};
var validateFps = NoReactInternals.validateFps;
var validateDimension = NoReactInternals.validateDimension;
var validateDurationInFrames = NoReactInternals.validateDurationInFrames;
var validateDefaultAndInputProps = NoReactInternals.validateDefaultAndInputProps;
var componentOrNullIfLazy = (props) => {
  if ("component" in props) {
    return props.component;
  }
  return null;
};
var PlayerFn = ({
  durationInFrames,
  compositionHeight,
  compositionWidth,
  fps,
  inputProps,
  style: style2,
  controls = false,
  loop = false,
  autoPlay = false,
  showVolumeControls = true,
  allowFullscreen = true,
  clickToPlay,
  doubleClickToFullscreen = false,
  spaceKeyToPlayOrPause = true,
  moveToBeginningWhenEnded = true,
  numberOfSharedAudioTags = 5,
  errorFallback = () => "",
  playbackRate = 1,
  renderLoading,
  className: className2,
  showPosterWhenUnplayed,
  showPosterWhenEnded,
  showPosterWhenPaused,
  showPosterWhenBuffering,
  showPosterWhenBufferingAndPaused,
  initialFrame,
  renderPoster,
  inFrame,
  outFrame,
  initiallyShowControls,
  renderFullscreenButton,
  renderPlayPauseButton,
  renderVolumeSlider,
  alwaysShowControls = false,
  initiallyMuted = false,
  showPlaybackRateControl = false,
  posterFillMode = "player-size",
  bufferStateDelayInMilliseconds,
  hideControlsWhenPointerDoesntMove = true,
  overflowVisible = false,
  renderMuteButton,
  browserMediaControlsBehavior: passedBrowserMediaControlsBehavior,
  overrideInternalClassName,
  logLevel = "info",
  noSuspense,
  acknowledgeRemotionLicense,
  audioLatencyHint = "interactive",
  volumePersistenceKey,
  ...componentProps
}, ref) => {
  if (typeof window !== "undefined") {
    window.remotion_isPlayer = true;
  }
  if (componentProps.defaultProps !== void 0) {
    throw new Error("The <Player /> component does not accept `defaultProps`, but some were passed. Use `inputProps` instead.");
  }
  const componentForValidation = componentOrNullIfLazy(componentProps);
  if ((componentForValidation == null ? void 0 : componentForValidation.type) === Composition) {
    throw new TypeError(`'component' should not be an instance of <Composition/>. Pass the React component directly, and set the duration, fps and dimensions as separate props. See https://www.remotion.dev/docs/player/examples for an example.`);
  }
  if (componentForValidation === Composition) {
    throw new TypeError(`'component' must not be the 'Composition' component. Pass your own React component directly, and set the duration, fps and dimensions as separate props. See https://www.remotion.dev/docs/player/examples for an example.`);
  }
  (0, import_react11.useState)(() => acknowledgeRemotionLicenseMessage(Boolean(acknowledgeRemotionLicense), logLevel));
  const component = Internals.useLazyComponent({
    compProps: componentProps,
    componentName: "Player",
    noSuspense: Boolean(noSuspense)
  });
  validateInitialFrame({ initialFrame, durationInFrames });
  const [frame, setFrame] = (0, import_react11.useState)(() => ({
    [PLAYER_COMP_ID]: initialFrame ?? 0
  }));
  const [playing, setPlaying] = (0, import_react11.useState)(false);
  const [rootId] = (0, import_react11.useState)("player-comp");
  const rootRef = (0, import_react11.useRef)(null);
  const audioAndVideoTags = (0, import_react11.useRef)([]);
  const imperativePlaying = (0, import_react11.useRef)(false);
  const [currentPlaybackRate, setCurrentPlaybackRate] = (0, import_react11.useState)(playbackRate);
  if (typeof compositionHeight !== "number") {
    throw new TypeError(`'compositionHeight' must be a number but got '${typeof compositionHeight}' instead`);
  }
  if (typeof compositionWidth !== "number") {
    throw new TypeError(`'compositionWidth' must be a number but got '${typeof compositionWidth}' instead`);
  }
  validateDimension(compositionHeight, "compositionHeight", "of the <Player /> component");
  validateDimension(compositionWidth, "compositionWidth", "of the <Player /> component");
  validateDurationInFrames(durationInFrames, {
    component: "of the <Player/> component",
    allowFloats: false
  });
  validateFps(fps, "as a prop of the <Player/> component", false);
  validateDefaultAndInputProps(inputProps, "inputProps", null);
  validateInOutFrames({
    durationInFrames,
    inFrame,
    outFrame
  });
  if (typeof controls !== "boolean" && typeof controls !== "undefined") {
    throw new TypeError(`'controls' must be a boolean or undefined but got '${typeof controls}' instead`);
  }
  if (typeof autoPlay !== "boolean" && typeof autoPlay !== "undefined") {
    throw new TypeError(`'autoPlay' must be a boolean or undefined but got '${typeof autoPlay}' instead`);
  }
  if (typeof loop !== "boolean" && typeof loop !== "undefined") {
    throw new TypeError(`'loop' must be a boolean or undefined but got '${typeof loop}' instead`);
  }
  if (typeof doubleClickToFullscreen !== "boolean" && typeof doubleClickToFullscreen !== "undefined") {
    throw new TypeError(`'doubleClickToFullscreen' must be a boolean or undefined but got '${typeof doubleClickToFullscreen}' instead`);
  }
  if (typeof showVolumeControls !== "boolean" && typeof showVolumeControls !== "undefined") {
    throw new TypeError(`'showVolumeControls' must be a boolean or undefined but got '${typeof showVolumeControls}' instead`);
  }
  if (typeof allowFullscreen !== "boolean" && typeof allowFullscreen !== "undefined") {
    throw new TypeError(`'allowFullscreen' must be a boolean or undefined but got '${typeof allowFullscreen}' instead`);
  }
  if (typeof clickToPlay !== "boolean" && typeof clickToPlay !== "undefined") {
    throw new TypeError(`'clickToPlay' must be a boolean or undefined but got '${typeof clickToPlay}' instead`);
  }
  if (typeof spaceKeyToPlayOrPause !== "boolean" && typeof spaceKeyToPlayOrPause !== "undefined") {
    throw new TypeError(`'spaceKeyToPlayOrPause' must be a boolean or undefined but got '${typeof spaceKeyToPlayOrPause}' instead`);
  }
  if (typeof numberOfSharedAudioTags !== "number" || numberOfSharedAudioTags % 1 !== 0 || !Number.isFinite(numberOfSharedAudioTags) || Number.isNaN(numberOfSharedAudioTags) || numberOfSharedAudioTags < 0) {
    throw new TypeError(`'numberOfSharedAudioTags' must be an integer but got '${numberOfSharedAudioTags}' instead`);
  }
  validatePlaybackRate(currentPlaybackRate);
  (0, import_react11.useEffect)(() => {
    setCurrentPlaybackRate(playbackRate);
  }, [playbackRate]);
  (0, import_react11.useImperativeHandle)(ref, () => rootRef.current, []);
  (0, import_react11.useState)(() => {
    Internals.playbackLogging({
      logLevel,
      message: `[player] Mounting <Player>. User agent = ${typeof navigator === "undefined" ? "server" : navigator.userAgent}`,
      tag: "player",
      mountTime: Date.now()
    });
  });
  const timelineContextValue = (0, import_react11.useMemo)(() => {
    return {
      frame,
      playing,
      rootId,
      playbackRate: currentPlaybackRate,
      imperativePlaying,
      setPlaybackRate: (rate) => {
        setCurrentPlaybackRate(rate);
      },
      audioAndVideoTags
    };
  }, [frame, currentPlaybackRate, playing, rootId]);
  const setTimelineContextValue = (0, import_react11.useMemo)(() => {
    return {
      setFrame,
      setPlaying
    };
  }, [setFrame]);
  if (typeof window !== "undefined") {
    (0, import_react11.useLayoutEffect)(() => {
      Internals.CSSUtils.injectCSS(Internals.CSSUtils.makeDefaultPreviewCSS(`.${playerCssClassname(overrideInternalClassName)}`, "#fff"));
    }, [overrideInternalClassName]);
  }
  const actualInputProps = (0, import_react11.useMemo)(() => inputProps ?? {}, [inputProps]);
  const browserMediaControlsBehavior = (0, import_react11.useMemo)(() => {
    return passedBrowserMediaControlsBehavior ?? {
      mode: "prevent-media-session"
    };
  }, [passedBrowserMediaControlsBehavior]);
  return (0, import_jsx_runtime15.jsx)(Internals.IsPlayerContextProvider, {
    children: (0, import_jsx_runtime15.jsx)(SharedPlayerContexts, {
      timelineContext: timelineContextValue,
      component,
      compositionHeight,
      compositionWidth,
      durationInFrames,
      fps,
      numberOfSharedAudioTags,
      initiallyMuted,
      logLevel,
      audioLatencyHint,
      volumePersistenceKey,
      children: (0, import_jsx_runtime15.jsx)(Internals.Timeline.SetTimelineContext.Provider, {
        value: setTimelineContextValue,
        children: (0, import_jsx_runtime15.jsx)(PlayerEmitterProvider, {
          currentPlaybackRate,
          children: (0, import_jsx_runtime15.jsx)(PlayerUI_default, {
            ref: rootRef,
            posterFillMode,
            renderLoading,
            autoPlay: Boolean(autoPlay),
            loop: Boolean(loop),
            controls: Boolean(controls),
            errorFallback,
            style: style2,
            inputProps: actualInputProps,
            allowFullscreen: Boolean(allowFullscreen),
            moveToBeginningWhenEnded: Boolean(moveToBeginningWhenEnded),
            clickToPlay: typeof clickToPlay === "boolean" ? clickToPlay : Boolean(controls),
            showVolumeControls: Boolean(showVolumeControls),
            doubleClickToFullscreen: Boolean(doubleClickToFullscreen),
            spaceKeyToPlayOrPause: Boolean(spaceKeyToPlayOrPause),
            playbackRate: currentPlaybackRate,
            className: className2 ?? void 0,
            showPosterWhenUnplayed: Boolean(showPosterWhenUnplayed),
            showPosterWhenEnded: Boolean(showPosterWhenEnded),
            showPosterWhenPaused: Boolean(showPosterWhenPaused),
            showPosterWhenBuffering: Boolean(showPosterWhenBuffering),
            showPosterWhenBufferingAndPaused: Boolean(showPosterWhenBufferingAndPaused),
            renderPoster,
            inFrame: inFrame ?? null,
            outFrame: outFrame ?? null,
            initiallyShowControls: initiallyShowControls ?? true,
            renderFullscreen: renderFullscreenButton ?? null,
            renderPlayPauseButton: renderPlayPauseButton ?? null,
            renderMuteButton: renderMuteButton ?? null,
            renderVolumeSlider: renderVolumeSlider ?? null,
            alwaysShowControls,
            showPlaybackRateControl,
            bufferStateDelayInMilliseconds: bufferStateDelayInMilliseconds ?? 300,
            hideControlsWhenPointerDoesntMove,
            overflowVisible,
            browserMediaControlsBehavior,
            overrideInternalClassName: overrideInternalClassName ?? void 0,
            noSuspense: Boolean(noSuspense)
          })
        })
      })
    })
  });
};
var forward = import_react11.forwardRef;
var Player = forward(PlayerFn);
var useThumbnail = () => {
  const emitter = (0, import_react28.useContext)(ThumbnailEmitterContext);
  if (!emitter) {
    throw new TypeError("Expected Player event emitter context");
  }
  const returnValue = (0, import_react28.useMemo)(() => {
    return {
      emitter
    };
  }, [emitter]);
  return returnValue;
};
var reactVersion2 = import_react27.default.version.split(".")[0];
if (reactVersion2 === "0") {
  throw new Error(`Version ${reactVersion2} of "react" is not supported by Remotion`);
}
var doesReactVersionSupportSuspense2 = parseInt(reactVersion2, 10) >= 18;
var ThumbnailUI = ({
  style: style2,
  inputProps,
  errorFallback,
  renderLoading,
  className: className2,
  overflowVisible,
  noSuspense,
  overrideInternalClassName
}, ref) => {
  const config = Internals.useUnsafeVideoConfig();
  const video = Internals.useVideo();
  const container = (0, import_react27.useRef)(null);
  const canvasSize = useElementSize(container, {
    triggerOnWindowResize: false,
    shouldApplyCssTransforms: false
  });
  const layout = (0, import_react27.useMemo)(() => {
    if (!config || !canvasSize) {
      return null;
    }
    return calculateCanvasTransformation({
      canvasSize,
      compositionHeight: config.height,
      compositionWidth: config.width,
      previewSize: "auto"
    });
  }, [canvasSize, config]);
  const scale = (layout == null ? void 0 : layout.scale) ?? 1;
  const thumbnail = useThumbnail();
  useBufferStateEmitter(thumbnail.emitter);
  (0, import_react27.useImperativeHandle)(ref, () => {
    const methods = {
      getContainerNode: () => container.current,
      getScale: () => scale
    };
    return Object.assign(thumbnail.emitter, methods);
  }, [scale, thumbnail.emitter]);
  const VideoComponent = video ? video.component : null;
  const outerStyle = (0, import_react27.useMemo)(() => {
    return calculateOuterStyle({
      config,
      style: style2,
      canvasSize,
      overflowVisible,
      layout
    });
  }, [canvasSize, config, layout, overflowVisible, style2]);
  const outer = (0, import_react27.useMemo)(() => {
    return calculateOuter({ config, layout, scale, overflowVisible });
  }, [config, layout, overflowVisible, scale]);
  const containerStyle3 = (0, import_react27.useMemo)(() => {
    return calculateContainerStyle({
      config,
      layout,
      scale,
      overflowVisible
    });
  }, [config, layout, overflowVisible, scale]);
  const onError = (0, import_react27.useCallback)((error) => {
    thumbnail.emitter.dispatchError(error);
  }, [thumbnail.emitter]);
  const loadingMarkup = (0, import_react27.useMemo)(() => {
    return renderLoading ? renderLoading({
      height: outerStyle.height,
      width: outerStyle.width,
      isBuffering: false
    }) : null;
  }, [outerStyle.height, outerStyle.width, renderLoading]);
  const currentScaleContext = (0, import_react27.useMemo)(() => {
    return {
      type: "scale",
      scale
    };
  }, [scale]);
  if (!config) {
    return null;
  }
  const content = (0, import_jsx_runtime16.jsx)("div", {
    style: outer,
    children: (0, import_jsx_runtime16.jsx)("div", {
      style: containerStyle3,
      className: playerCssClassname(overrideInternalClassName),
      children: VideoComponent ? (0, import_jsx_runtime16.jsx)(ErrorBoundary, {
        onError,
        errorFallback,
        children: (0, import_jsx_runtime16.jsx)(Internals.CurrentScaleContext.Provider, {
          value: currentScaleContext,
          children: (0, import_jsx_runtime16.jsx)(VideoComponent, {
            ...(video == null ? void 0 : video.props) ?? {},
            ...inputProps ?? {}
          })
        })
      }) : null
    })
  });
  if (noSuspense || IS_NODE && !doesReactVersionSupportSuspense2) {
    return (0, import_jsx_runtime16.jsx)("div", {
      ref: container,
      style: outerStyle,
      className: className2,
      children: content
    });
  }
  return (0, import_jsx_runtime16.jsx)("div", {
    ref: container,
    style: outerStyle,
    className: className2,
    children: (0, import_jsx_runtime16.jsx)(import_react27.Suspense, {
      fallback: loadingMarkup,
      children: content
    })
  });
};
var ThumbnailUI_default = (0, import_react27.forwardRef)(ThumbnailUI);
var ThumbnailFn = ({
  frameToDisplay,
  style: style2,
  inputProps,
  compositionHeight,
  compositionWidth,
  durationInFrames,
  fps,
  className: className2,
  errorFallback = () => "",
  renderLoading,
  overflowVisible = false,
  overrideInternalClassName,
  logLevel = "info",
  noSuspense,
  ...componentProps
}, ref) => {
  if (typeof window !== "undefined") {
    (0, import_react26.useLayoutEffect)(() => {
      window.remotion_isPlayer = true;
    }, []);
  }
  const [thumbnailId] = (0, import_react26.useState)(() => String(random(null)));
  const rootRef = (0, import_react26.useRef)(null);
  const timelineState = (0, import_react26.useMemo)(() => {
    const value = {
      playing: false,
      frame: {
        [PLAYER_COMP_ID]: frameToDisplay
      },
      rootId: thumbnailId,
      imperativePlaying: {
        current: false
      },
      playbackRate: 1,
      setPlaybackRate: () => {
        throw new Error("thumbnail");
      },
      audioAndVideoTags: { current: [] }
    };
    return value;
  }, [frameToDisplay, thumbnailId]);
  (0, import_react26.useImperativeHandle)(ref, () => rootRef.current, []);
  const Component = Internals.useLazyComponent({
    compProps: componentProps,
    componentName: "Thumbnail",
    noSuspense: Boolean(noSuspense)
  });
  const [emitter] = (0, import_react26.useState)(() => new ThumbnailEmitter());
  const passedInputProps = (0, import_react26.useMemo)(() => {
    return inputProps ?? {};
  }, [inputProps]);
  return (0, import_jsx_runtime17.jsx)(Internals.IsPlayerContextProvider, {
    children: (0, import_jsx_runtime17.jsx)(SharedPlayerContexts, {
      timelineContext: timelineState,
      component: Component,
      compositionHeight,
      compositionWidth,
      durationInFrames,
      fps,
      numberOfSharedAudioTags: 0,
      initiallyMuted: true,
      logLevel,
      audioLatencyHint: "playback",
      children: (0, import_jsx_runtime17.jsx)(ThumbnailEmitterContext.Provider, {
        value: emitter,
        children: (0, import_jsx_runtime17.jsx)(ThumbnailUI_default, {
          ref: rootRef,
          className: className2,
          errorFallback,
          inputProps: passedInputProps,
          renderLoading,
          style: style2,
          overflowVisible,
          overrideInternalClassName,
          noSuspense: Boolean(noSuspense)
        })
      })
    })
  });
};
var forward2 = import_react26.forwardRef;
var Thumbnail = forward2(ThumbnailFn);
var PlayerInternals = {
  PlayerEventEmitterContext,
  PlayerEmitter,
  usePlayer,
  usePlayback,
  useElementSize,
  calculateCanvasTransformation,
  useHoverState,
  updateAllElementsSizes,
  PlayerEmitterProvider,
  BufferingIndicator,
  useFrameImperative
};
export {
  Player,
  PlayerInternals,
  Thumbnail
};
//# sourceMappingURL=@remotion_player.js.map
