import {
  PathInternals,
  reduceInstructions,
  resetPath,
  serializeInstructions
} from "./chunk-IMHENDHH.js";
import {
  require_jsx_runtime
} from "./chunk-3OC7JQMP.js";
import {
  require_react_dom
} from "./chunk-2DERYF5V.js";
import {
  require_react
} from "./chunk-S5FHZHKU.js";
import {
  __toESM
} from "./chunk-EQCVQC35.js";

// node_modules/@remotion/shapes/dist/esm/index.mjs
var import_react = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var makeCircle = ({ radius }) => {
  const instructions = [
    {
      type: "M",
      x: radius,
      y: 0
    },
    {
      type: "a",
      rx: radius,
      ry: radius,
      xAxisRotation: 0,
      largeArcFlag: true,
      sweepFlag: true,
      dx: 0,
      dy: radius * 2
    },
    {
      type: "a",
      rx: radius,
      ry: radius,
      xAxisRotation: 0,
      largeArcFlag: true,
      sweepFlag: true,
      dx: 0,
      dy: -radius * 2
    },
    {
      type: "Z"
    }
  ];
  const path = serializeInstructions(instructions);
  return {
    height: radius * 2,
    width: radius * 2,
    path,
    instructions,
    transformOrigin: `${radius} ${radius}`
  };
};
var doesReactSupportTransformOriginProperty = (version2) => {
  if (version2.includes("canary") || version2.includes("experimental")) {
    const last8Chars = parseInt(version2.slice(-8), 10);
    return last8Chars > 20230209;
  }
  const [major] = version2.split(".").map(Number);
  return major > 18;
};
var RenderSvg = ({
  width,
  height,
  path,
  style,
  pathStyle,
  transformOrigin,
  debug,
  instructions,
  ...props
}) => {
  const actualStyle = (0, import_react.useMemo)(() => {
    return {
      overflow: "visible",
      ...style ?? {}
    };
  }, [style]);
  const actualPathStyle = (0, import_react.useMemo)(() => {
    return {
      transformBox: "fill-box",
      ...pathStyle ?? {}
    };
  }, [pathStyle]);
  const reactSupportsTransformOrigin = doesReactSupportTransformOriginProperty(import_react_dom.version);
  return (0, import_jsx_runtime.jsxs)("svg", {
    width,
    height,
    viewBox: `0 0 ${width} ${height}`,
    xmlns: "http://www.w3.org/2000/svg",
    style: actualStyle,
    children: [
      (0, import_jsx_runtime.jsx)("path", {
        ...reactSupportsTransformOrigin ? {
          transformOrigin
        } : {
          "transform-origin": transformOrigin
        },
        d: path,
        style: actualPathStyle,
        ...props
      }),
      debug ? instructions.map((i, index) => {
        if (i.type === "C") {
          const prevInstruction = index === 0 ? instructions[instructions.length - 1] : instructions[index - 1];
          if (prevInstruction.type === "V" || prevInstruction.type === "H" || prevInstruction.type === "a" || prevInstruction.type === "Z" || prevInstruction.type === "t" || prevInstruction.type === "q" || prevInstruction.type === "l" || prevInstruction.type === "c" || prevInstruction.type === "m" || prevInstruction.type === "h" || prevInstruction.type === "s" || prevInstruction.type === "v") {
            return null;
          }
          const prevX = prevInstruction.x;
          const prevY = prevInstruction.y;
          return (0, import_jsx_runtime.jsxs)(import_react.default.Fragment, {
            children: [
              (0, import_jsx_runtime.jsx)("path", {
                d: `M ${prevX} ${prevY} ${i.cp1x} ${i.cp1y}`,
                strokeWidth: 2,
                stroke: "rgba(0, 0, 0, 0.4)"
              }),
              (0, import_jsx_runtime.jsx)("path", {
                d: `M ${i.x} ${i.y} ${i.cp2x} ${i.cp2y}`,
                strokeWidth: 2,
                stroke: "rgba(0, 0, 0, 0.4)"
              }),
              (0, import_jsx_runtime.jsx)("circle", {
                cx: i.cp1x,
                cy: i.cp1y,
                r: 3,
                fill: "white",
                strokeWidth: 2,
                stroke: "black"
              }),
              (0, import_jsx_runtime.jsx)("circle", {
                cx: i.cp2x,
                cy: i.cp2y,
                r: 3,
                strokeWidth: 2,
                fill: "white",
                stroke: "black"
              })
            ]
          }, index);
        }
        return null;
      }) : null
    ]
  });
};
var Circle = ({ radius, ...props }) => {
  return (0, import_jsx_runtime2.jsx)(RenderSvg, {
    ...makeCircle({ radius }),
    ...props
  });
};
var makeEllipse = ({ rx, ry }) => {
  const instructions = [
    {
      type: "M",
      x: rx,
      y: 0
    },
    {
      type: "a",
      rx,
      ry,
      xAxisRotation: 0,
      largeArcFlag: true,
      sweepFlag: false,
      dx: 1,
      dy: 0
    },
    {
      type: "Z"
    }
  ];
  const path = serializeInstructions(instructions);
  return {
    width: rx * 2,
    height: ry * 2,
    path,
    instructions,
    transformOrigin: `${rx} ${ry}`
  };
};
var Ellipse = ({ rx, ry, ...props }) => {
  return (0, import_jsx_runtime3.jsx)(RenderSvg, {
    ...makeEllipse({ rx, ry }),
    ...props
  });
};
var makeHeart = ({
  height,
  aspectRatio = 1.1,
  bottomRoundnessAdjustment = 0,
  depthAdjustment = 0
}) => {
  const width = height * aspectRatio;
  const bottomControlPointX = 23 / 110 * width + bottomRoundnessAdjustment * width;
  const bottomControlPointY = 69 / 100 * height;
  const bottomLeftControlPointY = 60 / 100 * height;
  const topLeftControlPoint = 13 / 100 * height;
  const topBezierWidth = 29 / 110 * width;
  const topRightControlPointX = 15 / 110 * width;
  const innerControlPointX = 5 / 110 * width;
  const innerControlPointY = 7 / 100 * height;
  const depth = 17 / 100 * height + depthAdjustment * height;
  const instructions = [
    {
      type: "M",
      x: width / 2,
      y: height
    },
    {
      type: "C",
      cp1x: width / 2 - bottomControlPointX,
      cp1y: bottomControlPointY,
      cp2x: 0,
      cp2y: bottomLeftControlPointY,
      x: 0,
      y: height / 4
    },
    {
      type: "C",
      cp1x: 0,
      cp1y: topLeftControlPoint,
      cp2x: width / 4 - topBezierWidth / 2,
      cp2y: 0,
      x: width / 4,
      y: 0
    },
    {
      type: "C",
      cp1x: width / 4 + topBezierWidth / 2,
      cp1y: 0,
      cp2x: width / 2 - innerControlPointX,
      cp2y: innerControlPointY,
      x: width / 2,
      y: depth
    },
    {
      type: "C",
      cp1x: width / 2 + innerControlPointX,
      cp1y: innerControlPointY,
      cp2x: width / 2 + topRightControlPointX,
      cp2y: 0,
      x: width / 4 * 3,
      y: 0
    },
    {
      type: "C",
      cp1x: width / 4 * 3 + topBezierWidth / 2,
      cp1y: 0,
      cp2x: width,
      cp2y: topLeftControlPoint,
      x: width,
      y: height / 4
    },
    {
      type: "C",
      x: width / 2,
      y: height,
      cp1x: width,
      cp1y: bottomLeftControlPointY,
      cp2x: width / 2 + bottomControlPointX,
      cp2y: bottomControlPointY
    },
    {
      type: "Z"
    }
  ];
  const path = serializeInstructions(instructions);
  return {
    path,
    width,
    height,
    transformOrigin: `${width / 2} ${height / 2}`,
    instructions
  };
};
var Heart = ({
  aspectRatio,
  height,
  bottomRoundnessAdjustment = 0,
  depthAdjustment = 0,
  ...props
}) => {
  return (0, import_jsx_runtime4.jsx)(RenderSvg, {
    ...makeHeart({
      aspectRatio,
      height,
      bottomRoundnessAdjustment,
      depthAdjustment
    }),
    ...props
  });
};
var getCoord = ({
  counterClockwise,
  actualProgress,
  rotation,
  radius,
  coord
}) => {
  const factor = counterClockwise ? -1 : 1;
  const val = Math[coord === "x" ? "cos" : "sin"](factor * actualProgress * Math.PI * 2 + Math.PI * 1.5 + rotation) * radius + radius;
  const rounded = Math.round(val * 1e5) / 1e5;
  return rounded;
};
var makePie = ({
  progress,
  radius,
  closePath = true,
  counterClockwise = false,
  rotation = 0
}) => {
  const actualProgress = Math.min(Math.max(progress, 0), 1);
  const endAngleX = getCoord({
    actualProgress,
    coord: "x",
    counterClockwise,
    radius,
    rotation
  });
  const endAngleY = getCoord({
    actualProgress,
    coord: "y",
    counterClockwise,
    radius,
    rotation
  });
  const start = {
    x: getCoord({
      actualProgress: 0,
      coord: "x",
      counterClockwise,
      radius,
      rotation
    }),
    y: getCoord({
      actualProgress: 0,
      coord: "y",
      counterClockwise,
      radius,
      rotation
    })
  };
  const end = { x: endAngleX, y: endAngleY };
  const instructions = [
    {
      type: "M",
      ...start
    },
    {
      type: "A",
      rx: radius,
      ry: radius,
      xAxisRotation: 0,
      largeArcFlag: false,
      sweepFlag: !counterClockwise,
      x: actualProgress <= 0.5 ? endAngleX : getCoord({
        actualProgress: 0.5,
        coord: "x",
        counterClockwise,
        radius,
        rotation
      }),
      y: actualProgress <= 0.5 ? endAngleY : getCoord({
        actualProgress: 0.5,
        coord: "y",
        counterClockwise,
        radius,
        rotation
      })
    },
    actualProgress > 0.5 ? {
      type: "A",
      rx: radius,
      ry: radius,
      xAxisRotation: 0,
      largeArcFlag: false,
      sweepFlag: !counterClockwise,
      ...end
    } : null,
    actualProgress > 0 && actualProgress < 1 && closePath ? {
      type: "L",
      x: radius,
      y: radius
    } : null,
    closePath ? {
      type: "Z"
    } : null
  ].filter(Boolean);
  const path = serializeInstructions(instructions);
  return {
    height: radius * 2,
    width: radius * 2,
    path,
    instructions,
    transformOrigin: `${radius} ${radius}`
  };
};
var Pie = ({
  radius,
  progress,
  closePath,
  counterClockwise,
  rotation,
  ...props
}) => {
  return (0, import_jsx_runtime5.jsx)(RenderSvg, {
    ...makePie({ radius, progress, closePath, counterClockwise, rotation }),
    ...props
  });
};
var shortenVector = (vector, radius) => {
  const [x, y] = vector;
  const currentLength = Math.sqrt(x * x + y * y);
  const scalingFactor = (currentLength - radius) / currentLength;
  return [x * scalingFactor, y * scalingFactor];
};
var scaleVectorToLength = (vector, length) => {
  const [x, y] = vector;
  const currentLength = Math.sqrt(x * x + y * y);
  const scalingFactor = length / currentLength;
  return [x * scalingFactor, y * scalingFactor];
};
var joinPoints = (points, {
  edgeRoundness,
  cornerRadius,
  roundCornerStrategy
}) => {
  return points.map(([x, y], i) => {
    const prevPointIndex = i === 0 ? points.length - 2 : i - 1;
    const prevPoint = points[prevPointIndex];
    const nextPointIndex = i === points.length - 1 ? 1 : i + 1;
    const nextPoint = points[nextPointIndex];
    const middleOfLine = [(x + nextPoint[0]) / 2, (y + nextPoint[1]) / 2];
    const prevPointMiddleOfLine = [
      (x + prevPoint[0]) / 2,
      (y + prevPoint[1]) / 2
    ];
    const prevVector = [x - prevPoint[0], y - prevPoint[1]];
    const nextVector = [nextPoint[0] - x, nextPoint[1] - y];
    if (i === 0) {
      if (edgeRoundness !== null) {
        return [
          {
            type: "M",
            x: middleOfLine[0],
            y: middleOfLine[1]
          }
        ];
      }
      if (cornerRadius !== 0) {
        const computeRadius = shortenVector(nextVector, cornerRadius);
        return [
          {
            type: "M",
            x: computeRadius[0] + x,
            y: computeRadius[1] + y
          }
        ];
      }
      return [
        {
          type: "M",
          x,
          y
        }
      ];
    }
    if (cornerRadius && edgeRoundness !== null) {
      throw new Error(`"cornerRadius" and "edgeRoundness" cannot be specified at the same time.`);
    }
    if (edgeRoundness === null) {
      if (cornerRadius === 0) {
        return [
          {
            type: "L",
            x,
            y
          }
        ];
      }
      const prevVectorMinusRadius = shortenVector(prevVector, cornerRadius);
      const prevVectorLength = scaleVectorToLength(prevVector, cornerRadius);
      const nextVectorMinusRadius = scaleVectorToLength(nextVector, cornerRadius);
      const firstDraw = [
        prevPoint[0] + prevVectorMinusRadius[0],
        prevPoint[1] + prevVectorMinusRadius[1]
      ];
      return [
        {
          type: "L",
          x: firstDraw[0],
          y: firstDraw[1]
        },
        roundCornerStrategy === "arc" ? {
          type: "a",
          rx: cornerRadius,
          ry: cornerRadius,
          xAxisRotation: 0,
          dx: prevVectorLength[0] + nextVectorMinusRadius[0],
          dy: prevVectorLength[1] + nextVectorMinusRadius[1],
          largeArcFlag: false,
          sweepFlag: true
        } : {
          type: "C",
          x: firstDraw[0] + prevVectorLength[0] + nextVectorMinusRadius[0],
          y: firstDraw[1] + prevVectorLength[1] + nextVectorMinusRadius[1],
          cp1x: x,
          cp1y: y,
          cp2x: x,
          cp2y: y
        }
      ];
    }
    const controlPoint1 = [
      prevPointMiddleOfLine[0] + prevVector[0] * edgeRoundness * 0.5,
      prevPointMiddleOfLine[1] + prevVector[1] * edgeRoundness * 0.5
    ];
    const controlPoint2 = [
      middleOfLine[0] - nextVector[0] * edgeRoundness * 0.5,
      middleOfLine[1] - nextVector[1] * edgeRoundness * 0.5
    ];
    return [
      {
        type: "C",
        cp1x: controlPoint1[0],
        cp1y: controlPoint1[1],
        cp2x: controlPoint2[0],
        cp2y: controlPoint2[1],
        x: middleOfLine[0],
        y: middleOfLine[1]
      }
    ];
  }).flat(1);
};
function polygon({
  points,
  radius,
  centerX,
  centerY,
  cornerRadius,
  edgeRoundness
}) {
  const degreeIncrement = Math.PI * 2 / points;
  const d = new Array(points).fill(0).map((_, i) => {
    const angle = degreeIncrement * i - Math.PI / 2;
    const point = {
      x: centerX + radius * Math.cos(angle),
      y: centerY + radius * Math.sin(angle)
    };
    return [point.x, point.y];
  });
  return joinPoints([...d, d[0]], {
    edgeRoundness,
    cornerRadius,
    roundCornerStrategy: cornerRadius > 0 ? "bezier" : "arc"
  });
}
var makePolygon = ({
  points,
  radius,
  cornerRadius = 0,
  edgeRoundness = null
}) => {
  if (points < 3) {
    throw new Error(`"points" should be minimum 3, got ${points}`);
  }
  const width = 2 * radius;
  const height = 2 * radius;
  const centerX = width / 2;
  const centerY = height / 2;
  const polygonPathInstructions = polygon({
    points,
    radius,
    centerX,
    centerY,
    cornerRadius,
    edgeRoundness
  });
  const reduced = reduceInstructions(polygonPathInstructions);
  const path = resetPath(serializeInstructions(reduced));
  const boundingBox = PathInternals.getBoundingBoxFromInstructions(reduced);
  return {
    path,
    width: boundingBox.width,
    height: boundingBox.height,
    transformOrigin: `${centerX} ${centerY}`,
    instructions: polygonPathInstructions
  };
};
var Polygon = ({
  points,
  radius,
  cornerRadius,
  edgeRoundness,
  ...props
}) => {
  return (0, import_jsx_runtime6.jsx)(RenderSvg, {
    ...makePolygon({
      points,
      cornerRadius,
      edgeRoundness,
      radius
    }),
    ...props
  });
};
var makeRect = ({
  width,
  height,
  edgeRoundness = null,
  cornerRadius = 0
}) => {
  const transformOrigin = [width / 2, height / 2];
  const instructions = [
    ...joinPoints([
      [cornerRadius, 0],
      [width, 0],
      [width, height],
      [0, height],
      [0, 0]
    ], { edgeRoundness, cornerRadius, roundCornerStrategy: "arc" }),
    {
      type: "Z"
    }
  ];
  const path = serializeInstructions(instructions);
  return {
    width,
    height,
    instructions,
    path,
    transformOrigin: transformOrigin.join(" ")
  };
};
var Rect = ({
  width,
  edgeRoundness,
  height,
  cornerRadius,
  ...props
}) => {
  return (0, import_jsx_runtime7.jsx)(RenderSvg, {
    ...makeRect({ height, width, edgeRoundness, cornerRadius }),
    ...props
  });
};
var star = ({
  centerX,
  centerY,
  points,
  innerRadius,
  outerRadius,
  cornerRadius,
  edgeRoundness
}) => {
  const degreeIncrement = Math.PI * 2 / (points * 2);
  const d = new Array(points * 2).fill(true).map((_p, i) => {
    const radius = i % 2 === 0 ? outerRadius : innerRadius;
    const angle = degreeIncrement * i - Math.PI / 2;
    const point = {
      x: centerX + radius * Math.cos(angle),
      y: centerY + radius * Math.sin(angle)
    };
    return [point.x, point.y];
  });
  return [
    ...joinPoints([...d, d[0]], {
      edgeRoundness,
      cornerRadius,
      roundCornerStrategy: cornerRadius > 0 ? "bezier" : "arc"
    }),
    { type: "Z" }
  ];
};
var makeStar = ({
  points,
  innerRadius,
  outerRadius,
  cornerRadius = 0,
  edgeRoundness = null
}) => {
  const width = outerRadius * 2;
  const height = outerRadius * 2;
  const centerX = width / 2;
  const centerY = height / 2;
  const starPathInstructions = star({
    centerX,
    centerY,
    points,
    innerRadius,
    outerRadius,
    cornerRadius,
    edgeRoundness
  });
  const reduced = reduceInstructions(starPathInstructions);
  const path = resetPath(serializeInstructions(reduced));
  const boundingBox = PathInternals.getBoundingBoxFromInstructions(reduced);
  return {
    path,
    width: boundingBox.width,
    height: boundingBox.height,
    transformOrigin: `${centerX} ${centerY}`,
    instructions: starPathInstructions
  };
};
var Star = ({
  innerRadius,
  outerRadius,
  points,
  cornerRadius,
  edgeRoundness,
  ...props
}) => {
  return (0, import_jsx_runtime8.jsx)(RenderSvg, {
    ...makeStar({
      innerRadius,
      outerRadius,
      points,
      cornerRadius,
      edgeRoundness
    }),
    ...props
  });
};
var makeTriangle = ({
  length,
  direction = "right",
  edgeRoundness = null,
  cornerRadius = 0
}) => {
  if (typeof length !== "number") {
    throw new Error(`"length" of a triangle must be a number, got ${JSON.stringify(length)}`);
  }
  const longerDimension = length;
  const shorterSize = Math.sqrt(length ** 2 * 0.75);
  const points = {
    up: [
      [longerDimension / 2, 0],
      [0, shorterSize],
      [longerDimension, shorterSize],
      [longerDimension / 2, 0]
    ],
    right: [
      [0, 0],
      [0, longerDimension],
      [shorterSize, longerDimension / 2],
      [0, 0]
    ],
    down: [
      [0, 0],
      [longerDimension, 0],
      [longerDimension / 2, shorterSize],
      [0, 0]
    ],
    left: [
      [shorterSize, 0],
      [shorterSize, longerDimension],
      [0, longerDimension / 2],
      [shorterSize, 0]
    ]
  };
  const transformOriginX = {
    left: shorterSize / 3 * 2,
    right: shorterSize / 3,
    up: longerDimension / 2,
    down: longerDimension / 2
  }[direction];
  const transformOriginY = {
    up: shorterSize / 3 * 2,
    down: shorterSize / 3,
    left: longerDimension / 2,
    right: longerDimension / 2
  }[direction];
  const instructions = [
    ...joinPoints(points[direction], {
      edgeRoundness,
      cornerRadius,
      roundCornerStrategy: "bezier"
    }),
    {
      type: "Z"
    }
  ];
  const path = serializeInstructions(instructions);
  return {
    path,
    instructions,
    width: direction === "up" || direction === "down" ? length : shorterSize,
    height: direction === "up" || direction === "down" ? shorterSize : length,
    transformOrigin: `${transformOriginX} ${transformOriginY}`
  };
};
var Triangle = ({
  length,
  direction,
  edgeRoundness,
  cornerRadius,
  ...props
}) => {
  return (0, import_jsx_runtime9.jsx)(RenderSvg, {
    ...makeTriangle({ length, direction, edgeRoundness, cornerRadius }),
    ...props
  });
};
export {
  Circle,
  Ellipse,
  Heart,
  Pie,
  Polygon,
  Rect,
  Star,
  Triangle,
  makeCircle,
  makeEllipse,
  makeHeart,
  makePie,
  makePolygon,
  makeRect,
  makeStar,
  makeTriangle
};
//# sourceMappingURL=@remotion_shapes.js.map
